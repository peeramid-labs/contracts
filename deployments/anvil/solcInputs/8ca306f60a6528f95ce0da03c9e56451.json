{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.20;\n\nimport {IERC5805} from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../utils/NoncesUpgradeable.sol\";\nimport {EIP712Upgradeable} from \"../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\nabstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, NoncesUpgradeable, IERC5805 {\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Votes\n    struct VotesStorage {\n        mapping(address account => address) _delegatee;\n\n        mapping(address delegatee => Checkpoints.Trace208) _delegateCheckpoints;\n\n        Checkpoints.Trace208 _totalCheckpoints;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Votes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;\n\n    function _getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    function __Votes_init() internal onlyInitializing {\n    }\n\n    function __Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return $._delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return $._totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from == address(0)) {\n            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        VotesStorage storage $ = _getVotesStorage();\n        return SafeCast.toUint32($._delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208, uint208) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155\n    struct ERC1155Storage {\n        mapping(uint256 id => mapping(address account => uint256)) _balances;\n\n        mapping(address account => mapping(address operator => bool)) _operatorApprovals;\n\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n        string _uri;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;\n\n    function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {\n        assembly {\n            $.slot := ERC1155StorageLocation\n        }\n    }\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     */\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = $._balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    $._balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                $._balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\n            } else {\n                _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        $._uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n */\nabstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {\n    function __ERC1155Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(address account, uint256 id, uint256 value) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {VotesUpgradeable} from \"../../../governance/utils/VotesUpgradeable.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: This contract does not provide interface compatibility with Compound's COMP token.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20Upgradeable, VotesUpgradeable {\n    /**\n     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.\n     */\n    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);\n\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).\n     *\n     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,\n     * so that checkpoints can be stored in the Trace208 structure used by {{Votes}}. Increasing this value will not\n     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in\n     * {_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if\n     * additional logic requires it. When resolving override conflicts on this function, the minimum should be\n     * returned.\n     */\n    function _maxSupply() internal view virtual returns (uint256) {\n        return type(uint208).max;\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n        if (from == address(0)) {\n            uint256 supply = totalSupply();\n            uint256 cap = _maxSupply();\n            if (supply > cap) {\n                revert ERC20ExceededSafeSupply(supply, cap);\n            }\n        }\n        _transferVotingUnits(from, to, value);\n    }\n\n    /**\n     * @dev Returns the voting units of an `account`.\n     *\n     * WARNING: Overriding this function may compromise the internal vote accounting.\n     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _numCheckpoints(account);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _checkpoints(account, pos);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n */\ninterface IVotes {\n    /**\n     * @dev The signature used has expired.\n     */\n    error VotesExpiredSignature(uint256 expiry);\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../token/ERC1155/IERC1155.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5805.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.20;\n\nimport {IVotes} from \"../governance/utils/IVotes.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"./IERC1155.sol\";\nimport {IERC1155Receiver} from \"./IERC1155Receiver.sol\";\nimport {IERC1155MetadataURI} from \"./extensions/IERC1155MetadataURI.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {Arrays} from \"../../utils/Arrays.sol\";\nimport {IERC1155Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    mapping(uint256 id => mapping(address account => uint256)) private _balances;\n\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     */\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = _balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    _balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                _balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\n            } else {\n                _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1155} from \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(address account, uint256 id, uint256 value) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        _update(address(0), tokenId, _msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Safe Wallet (previously Gnosis Safe).\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary Checkpoints {\n    /**\n     * @dev A value was attempted to be inserted on a past checkpoint.\n     */\n    error CheckpointUnorderedInsertion();\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the\n     * library.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }\n\n    struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the\n     * library.\n     */\n    function push(Trace208 storage self, uint48 key, uint208 value) internal returns (uint208, uint208) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace208 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private returns (uint208, uint208) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint208 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the\n     * library.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/types/Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/abstracts/CloneDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../interfaces/IDistribution.sol\";\nimport \"./CodeIndexer.sol\";\n\nabstract contract CloneDistribution is IDistribution, CodeIndexer {\n    error CodeNotFoundInIndex(bytes32 codeId);\n\n    function sources() internal view virtual returns (address[] memory, bytes32 name, uint256 version);\n\n    // @inheritdoc IDistribution\n    function _instantiate()\n        internal\n        virtual\n        returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion)\n    {\n        (address[] memory _sources, bytes32 _distributionName, uint256 _distributionVersion) = sources();\n        uint256 srcsLength = _sources.length;\n        instances = new address[](srcsLength);\n        for (uint256 i; i < srcsLength; ++i) {\n            address clone = Clones.clone(_sources[i]);\n            instances[i] = clone;\n        }\n        emit Distributed(msg.sender, instances);\n        return (instances, _distributionName, _distributionVersion);\n    }\n    // @inheritdoc IDistribution\n    function get() external view virtual returns (address[] memory src, bytes32 name, uint256 version) {\n        return sources();\n    }\n    // @inheritdoc IDistribution\n    function contractURI() external view virtual returns (string memory);\n}\n"
    },
    "@peeramid-labs/eds/src/abstracts/CodeIndexer.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../ICodeIndexDep.sol\";\n\nabstract contract CodeIndexer {\n    //Create2 contract\n    ICodeIndex private constant INDEX_CONTRACT = ICodeIndex(0xc0D31d398c5ee86C5f8a23FA253ee8a586dA03Ce);\n    constructor() {}\n    // @inheritdoc ICodeIndex\n    function getContractsIndex() internal pure returns (ICodeIndex) {\n        return INDEX_CONTRACT;\n    }\n    // @inheritdoc ICodeIndex\n    function index(address source) internal {\n        INDEX_CONTRACT.register(source);\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/abstracts/Distributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\nimport \"../interfaces/IDistribution.sol\";\nimport \"../interfaces/IDistributor.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IInitializer.sol\";\nimport \"../abstracts/CodeIndexer.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {IContractURI} from \"../interfaces/IContractURI.sol\";\n/**\n * @title Distributor\n * @notice Abstract contract that implements the IDistributor interface, CodeIndexer, and ERC165.\n * This contract serves as a base for creating distributor contracts with specific functionalities.\n * It provides the necessary structure and functions to be extended by other contracts.\n * @author Peeramid Labs, 2024\n */\nabstract contract Distributor is IDistributor, CodeIndexer, ERC165 {\n    using LibSemver for LibSemver.Version;\n    struct DistributionComponent {\n        address distributionLocation;\n        address initializer;\n    }\n\n    struct VersionedDistribution {\n        LibSemver.VersionRequirement requirement;\n    }\n\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    EnumerableSet.Bytes32Set private distributionsSet;\n    mapping(address instance => uint256 instanceId) private instanceIds;\n    mapping(uint256 instance => bytes32 distributorsId) public distributionOf;\n    mapping(bytes32 distributorsId => DistributionComponent distribution) public distributionComponents;\n    mapping(bytes32 distributorsId => LibSemver.VersionRequirement VersionRequirement) public versionRequirements;\n    mapping(uint256 instanceId => LibSemver.Version instanceVersion) public instanceVersions;\n\n    uint256 public numInstances;\n    // @inheritdoc IDistributor\n    function getDistributions() external view returns (bytes32[] memory) {\n        return distributionsSet.values();\n    }\n    // @inheritdoc IDistributor\n    function getDistributionId(address instance) external view virtual returns (bytes32) {\n        return distributionOf[getInstanceId(instance)];\n    }\n    // @inheritdoc IDistributor\n    function getInstanceId(address instance) public view virtual returns (uint256) {\n        return instanceIds[instance];\n    }\n    // @inheritdoc IDistributor\n    function getDistributionURI(bytes32 distributorsId) external view returns (string memory) {\n        DistributionComponent memory distributionComponent = distributionComponents[distributorsId];\n        return IContractURI(distributionComponent.distributionLocation).contractURI();\n    }\n\n    function _addDistribution(\n        address repository,\n        address initializer,\n        LibSemver.VersionRequirement memory requirement\n    ) internal virtual returns (bytes32 distributorId) {\n        if (!ERC165Checker.supportsInterface(address(repository), type(IRepository).interfaceId)) {\n            revert InvalidRepository(repository);\n        }\n        distributorId = keccak256(abi.encode(repository, initializer));\n        if (LibSemver.toUint256(requirement.version) == 0) {\n            revert InvalidVersionRequested(distributorId, LibSemver.toString(requirement.version));\n        }\n        _newDistributionRecord(distributorId, repository, initializer);\n        versionRequirements[distributorId] = requirement;\n        emit VersionChanged(distributorId, requirement, requirement);\n    }\n\n    function calculateDistributorId(address repository, address initializer) public pure returns (bytes32) {\n        return keccak256(abi.encode(repository, initializer));\n    }\n\n    function calculateDistributorId(bytes32 sourceId, address initializer) public pure returns (bytes32) {\n        return keccak256(abi.encode(sourceId, initializer));\n    }\n\n    function _newDistributionRecord(bytes32 distributorId, address source, address initializer) private {\n        if (distributionsSet.contains(distributorId)) revert DistributionExists(distributorId);\n        distributionsSet.add(distributorId);\n        distributionComponents[distributorId] = DistributionComponent(source, initializer);\n        emit DistributionAdded(distributorId, source, initializer);\n    }\n    function _addDistribution(bytes32 id, address initializerAddress) internal virtual returns (bytes32 distributorId) {\n        ICodeIndex codeIndex = getContractsIndex();\n        address distributionLocation = codeIndex.get(id);\n        if (distributionLocation == address(0)) revert DistributionNotFound(id);\n        distributorId = keccak256(abi.encode(id, initializerAddress));\n        _newDistributionRecord(distributorId, distributionLocation, initializerAddress);\n    }\n\n    function _addDistribution(\n        bytes32 readableName,\n        bytes32 id,\n        address initializerAddress\n    ) internal virtual returns (bytes32 distributorId) {\n        ICodeIndex codeIndex = getContractsIndex();\n        address distributionLocation = codeIndex.get(id);\n        if (distributionLocation == address(0)) revert DistributionNotFound(id);\n        distributorId = readableName;\n        _newDistributionRecord(distributorId, distributionLocation, initializerAddress);\n    }\n\n    function _removeDistribution(bytes32 distributorsId) internal virtual {\n        if (!distributionsSet.contains(distributorsId)) revert DistributionNotFound(distributorsId);\n        distributionsSet.remove(distributorsId);\n        delete distributionComponents[distributorsId];\n        delete versionRequirements[distributorsId];\n        emit DistributionRemoved(distributorsId);\n    }\n\n    /**\n     * @notice Internal function to instantiate a new instance.\n     * @dev WARNING: This function will DELEGATECALL to initializer if such is provided. Initializer contract MUST be trusted by distributor.\n     */\n    function _instantiate(\n        bytes32 distributorsId,\n        bytes memory args\n    ) internal virtual returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion) {\n        if (!distributionsSet.contains(distributorsId)) revert DistributionNotFound(distributorsId);\n        DistributionComponent memory distributionComponent = distributionComponents[distributorsId];\n        LibSemver.VersionRequirement memory versionRequirement = versionRequirements[distributorsId];\n\n        // External initializer is provided, delegatecall to it\n        // Contrary, if no initializer is provided, the distribution is expected to be self-initializing\n        bool externallyInitialized = distributionComponent.initializer == address(0);\n        bytes4 selector = IInitializer.initialize.selector;\n        bytes memory instantiationArgs = externallyInitialized ? args : bytes(\"\");\n        address distributionLocation;\n        numInstances++;\n        uint256 instanceId = numInstances;\n\n        if (LibSemver.toUint256(versionRequirement.version) == 0) {\n            // Unversioned distribution, expect IDistribution\n            distributionLocation = distributionComponent.distributionLocation;\n            // Name and version are inferred from what the distribution provides\n            (instances, distributionName, distributionVersion) = IDistribution(distributionLocation).instantiate(\n                instantiationArgs\n            );\n            // Unversioned distributions are considered to be at version 0, and are not expected to change\n            // This might change in the future, as it could make sense to inherit `distributionVersion` from the distribution\n            // Yet for ease of runtime validation and to avoid potential issues, we keep it at 0\n            instanceVersions[numInstances] = LibSemver.parse(0);\n        } else {\n            // Versioned distribution, expect IRepository\n            IRepository repository = IRepository(distributionComponent.distributionLocation);\n            IRepository.Source memory repoSource = repository.get(versionRequirement);\n            ICodeIndex codeIndex = getContractsIndex();\n            distributionLocation = codeIndex.get(repoSource.sourceId);\n            if (distributionLocation == address(0)) revert DistributionNotFound(repoSource.sourceId);\n            (instances, , ) = IDistribution(distributionLocation).instantiate(instantiationArgs);\n            distributionName = repository.repositoryName();\n            distributionVersion = LibSemver.toUint256(repoSource.version);\n            instanceVersions[numInstances] = repoSource.version;\n        }\n\n        if (externallyInitialized) {\n            (bool success, bytes memory result) = address(distributionComponent.initializer).delegatecall(\n                abi.encodeWithSelector(selector, instances, args)\n            );\n            if (!success) {\n                if (result.length > 0) {\n                    assembly {\n                        let returndata_size := mload(result)\n                        revert(add(32, result), returndata_size)\n                    }\n                } else {\n                    revert(\"initializer delegatecall failed without revert reason\");\n                }\n            }\n        }\n\n        {\n            uint256 instancesLength = instances.length;\n            for (uint256 i; i < instancesLength; ++i) {\n                instanceIds[instances[i]] = instanceId;\n                distributionOf[instanceId] = distributorsId;\n            }\n        }\n        emit Instantiated(distributorsId, instanceId, distributionVersion, instances, args);\n    }\n\n    /**\n     * @inheritdoc IERC7746\n     * @notice This is ERC7746 hook must be called by instance methods that access scope is limited to the same instance or distribution\n     * @dev it will revert if: (1) `msg.sender` is not a valid instance; (2) `maybeInstance` is not a valid instance (3) `instanceId` belongs to disactivated distribution\n     */\n    function beforeCall(\n        bytes memory config,\n        bytes4,\n        address maybeInstance,\n        uint256,\n        bytes memory\n    ) external view virtual returns (bytes memory) {\n        address target = config.length > 0 ? abi.decode(config, (address)) : msg.sender;\n        bytes32 distributorsId = distributionOf[getInstanceId(maybeInstance)];\n        uint256 instanceId = getInstanceId(maybeInstance);\n        if (\n            distributorsId != bytes32(0) &&\n            getInstanceId(target) == instanceId &&\n            distributionsSet.contains(distributorsId)\n        ) {\n            // ToDo: This check could be based on DistributionOf, hence allowing cross-instance calls\n            // Use layerConfig to allow client to configure requirement for the call\n            if (!LibSemver.compare(instanceVersions[instanceId], versionRequirements[distributorsId])) {\n                revert VersionOutdated(distributorsId, LibSemver.toString(instanceVersions[instanceId]));\n            }\n            return abi.encode(distributorsId, \"\");\n        }\n        revert InvalidInstance(maybeInstance);\n    }\n    /**\n     * @inheritdoc IERC7746\n     * @notice This is ERC7746 hook must be called by instance methods that access scope is limited to the same instance or distribution\n     * @dev it will revert if: (1) `msg.sender` is not a valid instance; (2) `maybeInstance` is not a valid instance (3) `instanceId` belongs to disactivated distribution\n     */\n    function afterCall(\n        bytes memory config,\n        bytes4,\n        address maybeInstance,\n        uint256,\n        bytes memory,\n        bytes memory\n    ) external virtual {\n        address target = config.length > 0 ? abi.decode(config, (address)) : msg.sender;\n        bytes32 distributorsId = distributionOf[getInstanceId(maybeInstance)];\n        uint256 instanceId = getInstanceId(maybeInstance);\n        if ((getInstanceId(target) != getInstanceId(maybeInstance)) && distributionsSet.contains(distributorsId)) {\n            revert InvalidInstance(maybeInstance);\n        }\n        if (!LibSemver.compare(instanceVersions[instanceId], versionRequirements[distributorsId])) {\n            revert VersionOutdated(distributorsId, LibSemver.toString(instanceVersions[instanceId]));\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IDistributor).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _changeVersion(bytes32 distributionId, LibSemver.VersionRequirement memory newRequirement) internal {\n        if (!distributionsSet.contains(distributionId)) revert DistributionNotFound(distributionId);\n        LibSemver.VersionRequirement memory oldRequirement = versionRequirements[distributionId];\n        if (LibSemver.toUint256(oldRequirement.version) == 0) {\n            revert UnversionedDistribution(distributionId);\n        }\n        if (LibSemver.toUint256(newRequirement.version) == 0) {\n            revert InvalidVersionRequested(distributionId, LibSemver.toString(newRequirement.version));\n        }\n        if (LibSemver.areEqual(oldRequirement.version, newRequirement.version)) {\n            revert InvalidVersionRequested(distributionId, LibSemver.toString(newRequirement.version));\n        }\n        versionRequirements[distributionId] = newRequirement;\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/abstracts/ERC7746Middleware.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.8.0 <0.9.0;\nimport \"../libraries/LibMiddleware.sol\";\n\n/**\n * @title ERC7746Middleware\n * @notice Abstract contract that serves as a middleware for ERC7746 standard.\n * This contract is intended to be inherited by other contracts that implement\n * the ERC7746 functionality. It provides base functionality and structure\n * that can be extended and customized by derived contracts.\n * @author Peeramid Labs, 2024\n */\nabstract contract ERC7746Middleware {\n    /**\n     * @notice Modifier to apply custom logic for ERC7746 compliance.\n     * @param _selector The function selector to be checked.\n     * @param sender The address of the sender.\n     * @param data The calldata being passed to the function.\n     * @param value The value being transferred.\n     */\n    modifier ERC7746C(bytes4 _selector, address sender, bytes calldata data, uint256 value) {\n        bytes[] memory layerReturns = LibMiddleware.beforeCall(_selector, sender, data, value);\n        _;\n        LibMiddleware.afterCall(_selector, sender, data, value, layerReturns);\n    }\n\n    /**\n     * @notice Modifier to apply ERC7746 specific logic.\n     * This modifier can be used to enforce certain conditions or\n     * execute specific code before or after the function it modifies.\n     */\n    modifier ERC7746() {\n        bytes[] memory layerReturns = LibMiddleware.beforeCall(msg.sig, msg.sender, msg.data, msg.value);\n        _;\n        LibMiddleware.afterCall(msg.sig, msg.sender, msg.data, msg.value, layerReturns);\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/abstracts/Repository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../libraries/LibSemver.sol\";\nimport \"../interfaces/IRepository.sol\";\n\n/**\n * @title Repository\n * @notice Abstract contract that implements the IRepository interface. This contract serves as a base for other contracts that require repository functionalities.\n */\nabstract contract Repository is IRepository {\n    bytes32 public immutable repositoryName;\n    string private _cURI;\n    using LibSemver for LibSemver.Version;\n    mapping(uint256 => bytes32) internal versionedSources; // Flat version -> Source\n    mapping(uint64 => bytes) internal releaseMetadata; // Major version -> Metadata\n    mapping(uint128 => bytes) internal minorReleaseMetadata; // Major + Minor -> Metadata\n    mapping(uint256 => bytes) internal patchReleaseMetadata; // Major + Minor + Patch -> Metadata\n    mapping(uint64 => uint64) internal minorReleases;\n    mapping(uint128 => uint128) internal patchReleases;\n    uint64 internal majorReleases;\n    uint256 internal latestVersion;\n\n    constructor(bytes32 _repositoryName, string memory cURI) {\n        repositoryName = _repositoryName;\n        _cURI = cURI;\n    }\n\n    function _updateReleaseMetadata(LibSemver.Version memory version, bytes memory metadata) internal {\n        uint256 versionFlat = version.toUint256();\n        if (versionFlat == 0) revert VersionDoesNotExist(versionFlat);\n        if (version.major > majorReleases) revert VersionDoesNotExist(versionFlat);\n        if (version.minor > minorReleases[version.major]) revert VersionDoesNotExist(versionFlat);\n        if (version.patch > patchReleases[(uint128(version.major) << 64) | uint128(version.minor)])\n            revert VersionDoesNotExist(versionFlat);\n        if (version.patch == 0) {\n            if (version.minor == 0) {\n                if (version.major == 0) revert ReleaseZeroNotAllowed();\n                releaseMetadata[version.major] = metadata;\n            } else {\n                minorReleaseMetadata[(uint128(version.major) << 64) | uint128(version.minor)] = metadata;\n            }\n        } else {\n            patchReleaseMetadata[versionFlat] = metadata;\n        }\n        emit ReleaseMetadataUpdated(versionFlat, metadata);\n    }\n    function _newRelease(bytes32 sourceId, bytes memory metadata, LibSemver.Version memory version) internal {\n        uint256 versionFlat = version.toUint256();\n        if (versionFlat == 0 && version.major == 0) revert ReleaseZeroNotAllowed();\n        if (version.major > majorReleases) {\n            if (version.major != majorReleases + 1) revert VersionIncrementInvalid(versionFlat);\n            majorReleases = version.major;\n            minorReleases[version.major] = 0;\n            patchReleases[(uint128(version.major) << 64)] = 0;\n            releaseMetadata[version.major] = metadata;\n        } else if (version.minor > minorReleases[version.major]) {\n            if (version.minor != minorReleases[version.major] + 1) revert VersionIncrementInvalid(versionFlat);\n            minorReleases[version.major] = version.minor;\n            patchReleases[(uint128(version.major) << 64) | uint128(version.minor)] = 0;\n            minorReleaseMetadata[(uint128(version.major) << 64) | uint128(version.minor)] = metadata;\n        } else if (version.patch > patchReleases[(uint128(version.major) << 64) | uint128(version.minor)]) {\n            if (version.patch != patchReleases[(uint128(version.major) << 64) | uint128(version.minor)] + 1)\n                revert VersionIncrementInvalid(versionFlat);\n            patchReleases[(uint128(version.major) << 64) | uint128(version.minor)] = version.patch;\n            patchReleaseMetadata[versionFlat] = metadata;\n        } else {\n            revert VersionExists(versionFlat);\n        }\n        versionedSources[versionFlat] = sourceId;\n        latestVersion = versionFlat;\n        emit VersionAdded(versionFlat, sourceId, metadata);\n    }\n    // @inheritdoc IRepository\n    function getLatest() public view returns (Source memory) {\n        Source memory src;\n        src.sourceId = versionedSources[latestVersion];\n        src.version = LibSemver.parse(latestVersion);\n        src.metadata = releaseMetadata[uint64(latestVersion)];\n        return src;\n    }\n    // @inheritdoc IRepository\n    function get(LibSemver.VersionRequirement calldata required) public view returns (Source memory) {\n        Source memory src;\n        uint256 versionFlat = required.version.toUint256();\n        uint256 resolvedVersion;\n        if (required.version.major == 0) revert VersionDoesNotExist(versionFlat);\n        if (required.requirement == LibSemver.requirements.EXACT) resolvedVersion = versionFlat;\n        else if (required.requirement == LibSemver.requirements.MAJOR) {\n            if (required.version.major > majorReleases) revert VersionDoesNotExist(required.version.toUint256());\n            uint128 minorReleaseId = (uint128(required.version.major) << 64) |\n                uint128(minorReleases[required.version.major]);\n            resolvedVersion = (uint256(minorReleaseId) << 128) | uint256(patchReleases[minorReleaseId]);\n            src.sourceId = versionedSources[resolvedVersion];\n            src.version = LibSemver.parse(resolvedVersion);\n        } else if (required.requirement == LibSemver.requirements.MAJOR_MINOR) {\n            if (required.version.major > majorReleases) revert VersionDoesNotExist(required.version.toUint256());\n            if (required.version.major == majorReleases) {\n                if (required.version.minor > minorReleases[required.version.major])\n                    revert VersionDoesNotExist(required.version.toUint256());\n            }\n            uint128 minorReleaseId = (uint128(required.version.major) << 64) | uint128(required.version.minor);\n            resolvedVersion = (uint256(minorReleaseId) << 128) | uint256(patchReleases[minorReleaseId]);\n        } else if (required.requirement == LibSemver.requirements.GREATER_EQUAL) {\n            if (required.version.major > majorReleases) revert VersionDoesNotExist(required.version.toUint256());\n            if (required.version.major == majorReleases) {\n                if (required.version.minor > minorReleases[required.version.major])\n                    revert VersionDoesNotExist(required.version.toUint256());\n                if (required.version.minor == minorReleases[required.version.major]) {\n                    if (\n                        required.version.patch >\n                        patchReleases[(uint128(required.version.major) << 64) | uint128(required.version.minor)]\n                    ) revert VersionDoesNotExist(required.version.toUint256());\n                }\n            }\n            uint128 minorReleaseId = (uint128(majorReleases) << 64) | uint128(minorReleases[majorReleases]);\n            resolvedVersion = (uint256(minorReleaseId) << 128) | uint256(patchReleases[minorReleaseId]);\n        } else if (required.requirement == LibSemver.requirements.GREATER) {\n            if (required.version.major > majorReleases) revert VersionDoesNotExist(required.version.toUint256());\n            if (required.version.major == majorReleases) {\n                if (required.version.minor > minorReleases[required.version.major])\n                    revert VersionDoesNotExist(required.version.toUint256());\n                if (required.version.minor == minorReleases[required.version.major]) {\n                    if (\n                        required.version.patch >=\n                        patchReleases[(uint128(required.version.major) << 64) | uint128(required.version.minor)]\n                    ) revert VersionDoesNotExist(required.version.toUint256());\n                }\n            }\n            uint128 minorReleaseId = (uint128(majorReleases) << 64) | uint128(minorReleases[majorReleases]);\n            resolvedVersion = (uint256(minorReleaseId) << 128) | uint256(patchReleases[minorReleaseId]);\n        } else if (required.requirement == LibSemver.requirements.LESSER_EQUAL) {\n            revert(\"Not implemented\");\n        } else if (required.requirement == LibSemver.requirements.LESSER) {\n            revert(\"Not implemented\");\n        } else if (required.requirement == LibSemver.requirements.ANY) {\n            resolvedVersion = latestVersion;\n        } else {\n            revert VersionDoesNotExist(required.version.toUint256());\n        }\n        src.sourceId = versionedSources[resolvedVersion];\n        src.version = LibSemver.parse(resolvedVersion);\n        src.metadata = combineMetadata(resolvedVersion);\n        assert(src.sourceId != bytes32(0));\n        return src;\n    }\n\n    function combineMetadata(uint256 versionFlat) internal view returns (bytes memory) {\n        LibSemver.Version memory version = LibSemver.parse(versionFlat);\n        bytes memory majorMetadata = releaseMetadata[version.major];\n        bytes memory minorMetadata = minorReleaseMetadata[(uint128(version.major) << 64) | uint128(version.minor)];\n        bytes memory patchMetadata = patchReleaseMetadata[versionFlat];\n        return bytes.concat(majorMetadata, minorMetadata, patchMetadata);\n    }\n    // @inheritdoc IRepository\n    function getMajorReleaseMetadata(uint64 major) public view returns (bytes memory) {\n        return releaseMetadata[major];\n    }\n    // @inheritdoc IRepository\n    function getMinorReleaseMetadata(uint64 major, uint64 minor) public view returns (bytes memory) {\n        return minorReleaseMetadata[(uint128(major) << 64) | uint128(minor)];\n    }\n    // @inheritdoc IRepository\n    function getPatchReleaseMetadata(uint64 major, uint64 minor, uint64 patch) public view returns (bytes memory) {\n        return patchReleaseMetadata[(uint256(major) << 192) | (uint256(minor) << 128) | uint256(patch)];\n    }\n    // @inheritdoc IRepository\n    function getMajorReleases() public view returns (uint64) {\n        return majorReleases;\n    }\n    // @inheritdoc IRepository\n    function getMinorReleases(uint64 major) public view returns (uint64) {\n        return minorReleases[major];\n    }\n    // @inheritdoc IRepository\n    function getPatchReleases(uint64 major, uint64 minor) public view returns (uint128) {\n        return patchReleases[(uint128(major) << 64) | uint128(minor)];\n    }\n\n    function contractURI() public view returns (string memory) {\n        return _cURI;\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/abstracts/TokenizedDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Distributor.sol\";\n\nabstract contract TokenizedDistributor is Distributor {\n    event InstantiationCostChanged(bytes32 indexed id, uint256 cost);\n    IERC20 public paymentToken;\n    address public _beneficiary;\n    mapping(bytes32 id => uint256) public instantiationCosts;\n    uint256 public defaultInstantiationCost;\n    constructor(IERC20 token, uint256 defaultCost, address beneficiary) Distributor() {\n        paymentToken = token;\n        defaultInstantiationCost = defaultCost;\n        _beneficiary = beneficiary;\n    }\n\n    /**\n     * @notice Sets instantiation cost on a specific instantiation id\n     * @param distributorsId distributors id\n     * @param cost cost of instantiation\n     */\n    function _setInstantiationCost(bytes32 distributorsId, uint256 cost) internal {\n        instantiationCosts[distributorsId] = cost;\n        emit InstantiationCostChanged(distributorsId, cost);\n    }\n\n    /**\n     * @inheritdoc Distributor\n     */\n    function _addDistribution(\n        bytes32 id,\n        address initializerAddress\n    ) internal override returns (bytes32 distributorsId) {\n        distributorsId = super._addDistribution(id, initializerAddress);\n        _setInstantiationCost(distributorsId, defaultInstantiationCost);\n    }\n\n    function _addDistribution(\n        bytes32 readableName,\n        bytes32 id,\n        address initializerAddress\n    ) internal override returns (bytes32 distributorsId) {\n        distributorsId = super._addDistribution(readableName, id, initializerAddress);\n        _setInstantiationCost(distributorsId, defaultInstantiationCost);\n    }\n\n    function _addDistribution(\n        address repository,\n        address initializer,\n        LibSemver.VersionRequirement memory requirement\n    ) internal override returns (bytes32 distributorsId) {\n        distributorsId = super._addDistribution(repository, initializer, requirement);\n        _setInstantiationCost(distributorsId, defaultInstantiationCost);\n    }\n\n    /**\n     * @inheritdoc Distributor\n     */\n    function _instantiate(\n        bytes32 distributorsId,\n        bytes memory args\n    )\n        internal\n        virtual\n        override\n        returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion)\n    {\n        paymentToken.transferFrom(msg.sender, _beneficiary, instantiationCosts[distributorsId]);\n        return super._instantiate(distributorsId, args);\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/ICodeIndexDep.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity >=0.8.0 <0.9.0;\n\n// This file is exactly same as ./ICodeIndexer.sol\\\n// With exception for more loose pragma version\n// Updating the CodeIndex pragma directly would cause changing the deployed bytecode for ERC7744\ninterface ICodeIndex {\n    event Indexed(address indexed container, bytes32 indexed codeHash);\n    error alreadyExists(bytes32 id, address source);\n\n    function register(address container) external;\n\n    function get(bytes32 id) external view returns (address);\n}\n"
    },
    "@peeramid-labs/eds/src/interfaces/IContractURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IContractURI {\n    function contractURI() external view returns (string memory);\n}\n"
    },
    "@peeramid-labs/eds/src/interfaces/IDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport {IContractURI} from \"./IContractURI.sol\";\n/**\n * @title IDistribution\n * @notice Interface for distribution-related functionalities. It can get sources and produce a new instances out from them. It also provides metadata about the distribution.\n * @dev It is highly recommended to keep implementation stateless, and use `immutable` variables for any state. This allows your code to be referred in distributor and respositories via ERC7744. It's also easier to reason about, and more gas efficient.\n * @author Peeramid Labs, 2024\n */\ninterface IDistribution is IContractURI {\n    /**\n     * @notice Emitted when a distribution occurs.\n     * @param distributor The address of the entity that performed the distribution.\n     * @param instances An array of addresses that were produced.\n     */\n    event Distributed(address indexed distributor, address[] instances);\n\n    /**\n     * @notice Instantiates a new instance with the given parameters.\n     * @param data The data to be used for instantiation.\n     * @return instances An array of addresses that were produced.\n     * @return distributionName The name of the distribution.\n     * @return distributionVersion The version of the distribution.\n     * @dev WARNING: It MUST emit Distributed event.\n     */\n    function instantiate(\n        bytes memory data\n    ) external returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion);\n\n    /**\n     * @notice Retrieves the current distribution sources.\n     * @return sources An array of addresses that are used for instantiation.\n     * @return distributionName The name of the distribution.\n     * @return distributionVersion The version of the distribution.\n     */\n    function get()\n        external\n        view\n        returns (address[] memory sources, bytes32 distributionName, uint256 distributionVersion);\n}\n"
    },
    "@peeramid-labs/eds/src/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport {IERC7746} from \"../interfaces/IERC7746.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IRepository.sol\";\nimport \"../libraries/LibSemver.sol\";\nimport {IERC7746} from \"../interfaces/IERC7746.sol\";\n\n/**\n * @title IDistributor Interface\n * @notice Defines the standard functions for a distributor contract.\n * @dev If you want to use {IRepository} for versioned distributions, use {IVersionDistributor} interface.\n * @author Peeramid Labs, 2024\n */\ninterface IDistributor is IERC7746, IERC165 {\n    error InvalidVersionRequested(bytes32 distributionId, string version);\n    error InvalidRepository(address repository);\n    error RepositoryAlreadyExists(address repository);\n    error VersionOutdated(bytes32 distributionId, string version);\n    error InvalidInstance(address instance);\n    error UnversionedDistribution(bytes32 distributionId);\n\n    /**\n     * @notice Emitted when the version of the distributor is changed.\n     * @param distributionId The unique identifier of the distribution.\n     * @param newRequirement The new version requirement (hashed for indexing).\n     * @param newRequirementData The new version requirement data.\n     */\n    event VersionChanged(\n        bytes32 indexed distributionId,\n        LibSemver.VersionRequirement indexed newRequirement,\n        LibSemver.VersionRequirement newRequirementData\n    );\n\n    /**\n     * @notice Error indicating that the distribution with the specified ID was not found.\n     * @param id The unique identifier of the distribution that was not found.\n     */\n    error DistributionNotFound(bytes32 id);\n    /**\n     * @notice Error indicating that a distribution with the specified ID already exists.\n     * @param id The unique identifier of the distribution that already exists.\n     */\n    error DistributionExists(bytes32 id);\n    /**\n     * @notice Error indicating that the initializer for the distribution was not found.\n     * @param id The unique identifier of the distribution that was not found.\n     */\n    error InitializerNotFound(bytes32 id);\n\n    /**\n     * @notice Event emitted when a new distribution is instantiated.\n     * @param distributionId The unique identifier of the distribution.\n     * @param newInstanceId The unique identifier of the instance.\n     * @param version The version of the distribution, taken either from IDistribution or from IRepository.\n     * @param instances The addresses of the instances that were created.\n     * @param args The arguments that were used for instantiation.\n     * @dev It MUST emit when {IDistributor.instantiate} is called.\n     */\n    event Instantiated(\n        bytes32 indexed distributionId,\n        uint256 indexed newInstanceId,\n        uint256 indexed version,\n        address[] instances,\n        bytes args\n    );\n    /**\n     * @notice Event emitted when a distribution is removed.\n     * @param id The unique identifier of the distribution that was removed.\n     * @dev It MUST emit when {IDistributor.removeDistribution} is called.\n     */\n    event DistributionRemoved(bytes32 indexed id);\n\n    /**\n     * @notice Event emitted when a distribution is added.\n     * @param id The unique identifier of the distribution that was added.\n     * @param distribution The address of the distribution that was added.\n     * @param initializer The address of the initializer for the distribution.\n     * @dev It MUST emit when {IDistributor.addDistribution} is called.\n     */\n    event DistributionAdded(bytes32 indexed id, address distribution, address indexed initializer);\n\n    /**\n     * @notice Retrieves the unique identifiers of all distributions.\n     * @return distributorIds An array of unique identifiers of all distributions.\n     */\n    function getDistributions() external view returns (bytes32[] memory distributorIds);\n\n    /**\n     * @notice Retrieves the URI of the distribution.\n     * @param distributorId The unique identifier of the distribution.\n     * @return uri The URI of the distribution.\n     */\n    function getDistributionURI(bytes32 distributorId) external view returns (string memory);\n\n    /**\n     * @notice Instantiates a new instance with the given distributor ID and arguments.\n     * @param distributorId The unique identifier of the distributor.\n     * @param args The arguments to be used for instantiation.\n     * @return instances The addresses of the instances that were created.\n     * @return distributionName The name of the distribution.\n     * @return distributionVersion The version of the distribution.\n     * @dev It MUST emit {Instantiated} event.\n     */\n    function instantiate(\n        bytes32 distributorId,\n        bytes calldata args\n    ) external returns (address[] memory, bytes32 distributionName, uint256 distributionVersion);\n\n    /**\n     * @notice Adds a new distribution with the specified distributor ID and initializer address.\n     * @param distributorId The unique identifier for the distributor.\n     * @param initializer The address of the initializer for the distribution.\n     * @dev WARNING: If initializer is provided, it will DELEGATECALL to the initializer. Otherwise, instantiation arguments will be passed to the distribution for self-initialization. Initializer contract MUST be trusted by the distributor.\n     */\n    function addDistribution(bytes32 distributorId, address initializer) external;\n\n    /**\n     * @notice Removes a distribution identified by the given distributorId.\n     * @param distributorId The unique identifier of the distribution to be removed.\n     */\n    function removeDistribution(bytes32 distributorId) external;\n\n    /**\n     * @notice Retrieves the distribution ID associated with a given instance address.\n     * @param instance The address of the instance for which the distribution ID is being requested.\n     * @return The distribution ID as a bytes32 value.\n     */\n    function getDistributionId(address instance) external view returns (bytes32);\n    /**\n     * @notice Retrieves the unique identifier for a given instance address.\n     * @param instance The address of the instance whose ID is to be retrieved.\n     * @return The unique identifier (uint256) associated with the specified instance address.\n     */\n    function getInstanceId(address instance) external view returns (uint256);\n\n    /**\n     * @notice Adds a new versioned distribution to the repository.\n     * @param repository The repository to which the distribution will be added.\n     * @param initializer The address that initializes the distribution.\n     * @param requirement The version requirements for the distribution.\n     * @dev WARNING: If initializer is provided, it will DELEGATECALL to the initializer. Otherwise, instantiation arguments will be passed to the distribution for self-initialization. Initializer contract MUST be trusted by the distributor.\n     */\n    function addDistribution(\n        IRepository repository,\n        address initializer,\n        LibSemver.VersionRequirement memory requirement\n    ) external;\n\n    /**\n     * @notice Changes the version requirement for a specific distribution.\n     * @param distributionId The unique identifier of the distribution whose version requirement is to be changed.\n     * @param newRequirement The new version requirement to be set for the distribution.\n     */\n    function changeVersion(bytes32 distributionId, LibSemver.VersionRequirement memory newRequirement) external;\n\n    /**\n     * @notice Adds a new versioned distribution to the repository.\n     * @param name The name of the distribution.\n     * @param distributorId The unique identifier of the distributor.\n     * @param initializer The address that initializes the distribution.\n     */\n    function addNamedDistribution(bytes32 name, bytes32 distributorId, address initializer) external;\n}\n"
    },
    "@peeramid-labs/eds/src/interfaces/IERC7746.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title IERC7746 Interface\n * @dev Interface for the ERC7746 standard.\n */\ninterface IERC7746 {\n    /// @notice Validates a function call before execution.\n    /// @param configuration Middleware-specific configuration data.\n    /// @param selector The function selector being called.\n    /// @param sender The address initiating the call.\n    /// @param value The amount of ETH sent with the call (if any).\n    /// @param data The calldata for the function call.\n    /// @return beforeCallResult Arbitrary data to be passed to `afterCallValidation`.\n    /// @dev MUST revert if validation fails.\n    function beforeCall(\n        bytes memory configuration,\n        bytes4 selector,\n        address sender,\n        uint256 value,\n        bytes memory data\n    ) external returns (bytes memory);\n\n    /// @notice Validates a function call after execution.\n    /// @param configuration Middleware-specific configuration data.\n    /// @param selector The function selector being called.\n    /// @param sender The address initiating the call.\n    /// @param value The amount of ETH sent with the call (if any).\n    /// @param data The calldata for the function call.\n    /// @param beforeCallResult The data returned by `beforeCallValidation`.\n    /// @dev MUST revert if validation fails.\n    function afterCall(\n        bytes memory configuration,\n        bytes4 selector,\n        address sender,\n        uint256 value,\n        bytes memory data,\n        bytes memory beforeCallResult\n    ) external;\n}\n"
    },
    "@peeramid-labs/eds/src/interfaces/IInitializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title IInitializer\n * @notice Interface for the Initializer contract. This is intended to be used\n * as distribution initializer within the Distributor contract.\n */\ninterface IInitializer {\n    event Initialized(address indexed container, bytes32 indexed codeHash);\n    error initializationFailed(bytes32 id, string reason);\n\n    /**\n     * @notice Initializes the contract with necessary parameters.\n     * @dev This function should be delegete-called by the distributor contract.\n     * @param distributionId The ID of the distribution being initialized\n     * @param instances The addresses of the instances being initialized\n     * @param distributionName The name of the distribution\n     * @param distributionVersion The version of the distribution\n     * @param args The additional arguments to be used for initialization\n     */\n    function initialize(\n        bytes32 distributionId,\n        address[] memory instances,\n        bytes32 distributionName,\n        uint256 distributionVersion,\n        bytes calldata args\n    ) external;\n}\n"
    },
    "@peeramid-labs/eds/src/interfaces/IRepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../libraries/LibSemver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IContractURI} from \"./IContractURI.sol\";\n/**\n * @title IRepository Interface\n * @notice It is intended to be implemented by contracts that manage a collection of versions of a byte code.\n * @author Peeramid Labs, 2024\n */\ninterface IRepository is IERC165, IContractURI {\n    /**\n     * @notice Represents a source with version information, a unique identifier, and associated metadata.\n     * @param version The version of the source, represented using the LibSemver.Version struct.\n     * @param sourceId A unique identifier for the source.\n     * @param metadata Additional data associated with the source.\n     */\n    struct Source {\n        LibSemver.Version version;\n        bytes32 sourceId;\n        bytes metadata;\n    }\n\n    /**\n     * @notice Error indicating that the specified version does not exist.\n     * @param version The version number that does not exist.\n     */\n    error VersionDoesNotExist(uint256 version);\n    /**\n     * @notice Error indicating that a release with a zero value is not allowed.\n     */\n    error ReleaseZeroNotAllowed();\n    /**\n     * @notice Error indicating that the specified version already exists.\n     * @param version The version number that already exists.\n     */\n    error VersionExists(uint256 version);\n    /**\n     * @notice Error indicating that the version increment is invalid.\n     * @param version The version number that caused the error.\n     * @dev The version increment must be exactly one for either major, minor, or patch.\n     */\n    error VersionIncrementInvalid(uint256 version);\n    /**\n     * @dev Error indicating that the release metadata is empty.\n     */\n    error EmptyReleaseMetadata();\n\n    /**\n     * @notice Emitted when a new version is added to the repository.\n     * @param version The version number of the added item.\n     * @param source The source identifier of the added item.\n     * @param buildMetadata Additional metadata related to the build.\n     */\n    event VersionAdded(uint256 indexed version, bytes32 indexed source, bytes buildMetadata);\n    /**\n     * @notice Emitted when the metadata of a release is updated.\n     * @param version The version number of the release.\n     * @param releaseMetadata The metadata associated with the release.\n     */\n    event ReleaseMetadataUpdated(uint256 indexed version, bytes releaseMetadata);\n\n    /**\n     * @notice Updates the metadata for a specific release version.\n     * @param version The version of the release to update.\n     * @param releaseMetadata The new metadata to associate with the release.\n     * @dev It MUST emit `ReleaseMetadataUpdated` event.\n     */\n    function updateReleaseMetadata(LibSemver.Version memory version, bytes calldata releaseMetadata) external;\n    /**\n     * @notice Retrieves the name of the repository.\n     * @return The name of the repository as a bytes32 value.\n     */\n    function repositoryName() external view returns (bytes32);\n    /**\n     * @notice Creates a new release for the given source ID.\n     * @param sourceId The unique identifier of the source.\n     * @param metadata The metadata associated with the release.\n     * @param version The semantic version of the new release.\n     * @dev It MUST emit `VersionAdded` event.\n     */\n    function newRelease(bytes32 sourceId, bytes memory metadata, LibSemver.Version memory version) external;\n    /**\n     * @notice Retrieves the latest source.\n     * @return The requested source\n     */\n    function getLatest() external view returns (Source memory);\n    /**\n     * @notice Retrieves a specific item from the repository.\n     * @param required the required version\n     * @return The requested `Source`.\n     */\n    function get(LibSemver.VersionRequirement calldata required) external view returns (Source memory);\n}\n"
    },
    "@peeramid-labs/eds/src/libraries/LibMiddleware.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport {IERC7746} from \"../interfaces/IERC7746.sol\";\n\nlibrary LibMiddleware {\n    bytes32 private constant ACCESS_LAYERS_STORAGE_POSITION = keccak256(\"lib.access.layer.storage\");\n\n    struct LayerStruct {\n        address layerAddess;\n        bytes layerConfigData;\n    }\n\n    function accessLayersStorage() internal pure returns (LayerStruct[] storage ls) {\n        bytes32 position = ACCESS_LAYERS_STORAGE_POSITION;\n        assembly {\n            ls.slot := position\n        }\n    }\n\n    function setLayer(address layerAddress, uint256 layerIndex, bytes memory layerConfigData) internal {\n        LayerStruct[] storage ls = accessLayersStorage();\n        ls[layerIndex].layerAddess = layerAddress;\n        ls[layerIndex].layerConfigData = layerConfigData;\n    }\n\n    function addLayer(LayerStruct memory newLayer) internal {\n        LayerStruct[] storage ls = accessLayersStorage();\n        ls.push(newLayer);\n    }\n\n    function setLayers(LayerStruct[] memory newLayers) internal {\n        uint256 length = newLayers.length;\n        for (uint256 i; i < length; ++i) {\n            addLayer(newLayers[i]);\n        }\n    }\n\n    function addLayer(address layerAddress, bytes memory layerConfigData) internal {\n        LayerStruct[] storage ls = accessLayersStorage();\n        LayerStruct memory newLayer = LayerStruct({layerAddess: layerAddress, layerConfigData: layerConfigData});\n        ls.push(newLayer);\n    }\n\n    function popLayer() internal {\n        LayerStruct[] storage ls = accessLayersStorage();\n        ls.pop();\n    }\n\n    function getLayer(uint256 layerIdx) internal view returns (LayerStruct storage) {\n        LayerStruct[] storage ls = accessLayersStorage();\n        return ls[layerIdx];\n    }\n\n    function beforeCall(\n        bytes4 _selector,\n        address sender,\n        bytes calldata data,\n        uint256 value\n    ) internal returns (bytes[] memory) {\n        LayerStruct[] storage ls = accessLayersStorage();\n        uint256 length = ls.length;\n        bytes[] memory layerReturns = new bytes[](length);\n        for (uint256 i; i < length; ++i) {\n            layerReturns[i] = validateLayerBeforeCall(ls[i], _selector, sender, data, value);\n        }\n        return layerReturns;\n    }\n\n    function validateLayerBeforeCall(\n        LayerStruct storage layer,\n        bytes4 _selector,\n        address sender,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        bytes memory retval = IERC7746(layer.layerAddess).beforeCall(\n            layer.layerConfigData,\n            _selector,\n            sender,\n            value,\n            data\n        );\n\n        return retval;\n    }\n\n    function afterCall(\n        bytes4 _selector,\n        address sender,\n        bytes calldata data,\n        uint256 value,\n        bytes[] memory beforeCallReturns\n    ) internal {\n        LayerStruct[] storage ls = accessLayersStorage();\n        uint256 length = ls.length;\n        for (uint256 i; i < length; ++i) {\n            validateLayerAfterCall(ls[length - 1 - i], _selector, sender, data, value, beforeCallReturns[i]);\n        }\n    }\n\n    function extractRevertReason(bytes memory revertData) internal pure returns (string memory reason) {\n        uint256 l = revertData.length;\n        if (l < 68) return \"\";\n        uint256 t;\n        assembly {\n            revertData := add(revertData, 4)\n            t := mload(revertData) // Save the content of the length slot\n            mstore(revertData, sub(l, 4)) // Set proper length\n        }\n        reason = abi.decode(revertData, (string));\n        assembly {\n            mstore(revertData, t) // Restore the content of the length slot\n        }\n    }\n\n    function validateLayerAfterCall(\n        LayerStruct storage layer,\n        bytes4 _selector,\n        address sender,\n        bytes calldata data,\n        uint256 value,\n        bytes memory beforeCallReturnValue\n    ) internal {\n        IERC7746(layer.layerAddess).afterCall(\n            layer.layerConfigData,\n            _selector,\n            sender,\n            value,\n            data,\n            beforeCallReturnValue\n        );\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/libraries/LibSemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nlibrary LibSemver {\n    error versionMismatch(string message);\n    struct Version {\n        uint64 major;\n        uint64 minor;\n        uint128 patch;\n    }\n\n    enum requirements {\n        ANY, // *\n        EXACT, // =\n        MAJOR, // ^\n        MAJOR_MINOR, // ~\n        GREATER_EQUAL, // >=\n        GREATER, // >\n        LESSER_EQUAL, // <=\n        LESSER // <\n    }\n\n    struct VersionRequirement {\n        Version version;\n        requirements requirement;\n    }\n\n    function toUint256(Version memory _version) internal pure returns (uint256) {\n        return (uint256(_version.major) << 192) | (uint256(_version.minor) << 128) | uint256(_version.patch);\n    }\n\n    function parse(uint256 _version) internal pure returns (Version memory) {\n        return Version(uint64(_version >> 192), uint64(_version >> 128), uint128(_version));\n    }\n\n    function toString(Version memory _version) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Strings.toString(uint256(_version.major)),\n                    \".\",\n                    Strings.toString(uint256(_version.minor)),\n                    \".\",\n                    Strings.toString(uint256(_version.patch))\n                )\n            );\n    }\n\n    function require_exact(Version memory _version1, Version memory _version2) internal pure {\n        if (toUint256(_version1) != toUint256(_version2)) revert versionMismatch(\"Version mismatch\");\n    }\n\n    function require_major(Version memory _version1, Version memory _version2) internal pure {\n        if (_version1.major != _version2.major) revert versionMismatch(\"Major version mismatch\");\n    }\n\n    function require_major_minor(Version memory _version1, Version memory _version2) internal pure {\n        if (_version1.major != _version2.major || _version1.minor != _version2.minor)\n            revert versionMismatch(\"Major and minor version mismatch\");\n    }\n\n    function require_greater_equal(Version memory _version1, Version memory _version2) internal pure {\n        if (toUint256(_version1) < toUint256(_version2)) revert versionMismatch(\"Version is not greater or equal\");\n    }\n\n    function require_greater(Version memory _version1, Version memory _version2) internal pure {\n        if (toUint256(_version1) <= toUint256(_version2)) revert versionMismatch(\"Version is not greater\");\n    }\n\n    function require_lesser_equal(Version memory _version1, Version memory _version2) internal pure {\n        if (toUint256(_version1) > toUint256(_version2)) revert versionMismatch(\"Version is not lesser or equal\");\n    }\n\n    function require_lesser(Version memory _version1, Version memory _version2) internal pure {\n        if (toUint256(_version1) >= toUint256(_version2)) revert versionMismatch(\"Version is not lesser\");\n    }\n\n    function areEqual(Version memory _version1, Version memory _version2) internal pure returns (bool) {\n        return toUint256(_version1) == toUint256(_version2);\n    }\n\n    function compare(Version memory has, VersionRequirement memory needs) internal pure returns (bool) {\n        if (needs.requirement == requirements.ANY) return true;\n        if (needs.requirement == requirements.EXACT) return toUint256(has) == toUint256(needs.version);\n        if (needs.requirement == requirements.MAJOR) return has.major == needs.version.major;\n        if (needs.requirement == requirements.MAJOR_MINOR)\n            return has.major == needs.version.major && has.minor == needs.version.minor;\n        if (needs.requirement == requirements.GREATER_EQUAL) return toUint256(has) >= toUint256(needs.version);\n        if (needs.requirement == requirements.GREATER) return toUint256(has) > toUint256(needs.version);\n        if (needs.requirement == requirements.LESSER_EQUAL) return toUint256(has) <= toUint256(needs.version);\n        if (needs.requirement == requirements.LESSER) return toUint256(has) < toUint256(needs.version);\n        return false;\n    }\n\n    function getNextMajor(Version memory _version) internal pure returns (Version memory) {\n        return Version(_version.major + 1, 0, 0);\n    }\n\n    function getNextMinor(Version memory _version) internal pure returns (Version memory) {\n        return Version(_version.major, _version.minor + 1, 0);\n    }\n\n    function getNextPatch(Version memory _version) internal pure returns (Version memory) {\n        return Version(_version.major, _version.minor, _version.patch + 1);\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/managers/SimpleAccessManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC7746} from \"../interfaces/IERC7746.sol\";\nimport {IDistributor} from \"../interfaces/IDistributor.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\ncontract SimpleAccessManager is Initializable, IERC7746, ERC165 {\n    struct MethodSettings {\n        bool isDistributionOnly;\n        mapping(address => bool) disallowedAddresses;\n    }\n\n    struct Storage {\n        mapping(bytes4 => MethodSettings) methodSettings;\n        address target;\n        IDistributor distributor;\n    }\n\n    bytes32 private constant SACM_STORAGE_POSITION = keccak256(\"simple.access.manager.storage.position\");\n\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 position = SACM_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    struct SimpleAccessManagerInitializer {\n        bytes4 selector;\n        address[] disallowedAddresses;\n        bool distributionComponentsOnly;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n    error ERC165CheckFailed(address distributor, bytes4 interfaceId, string interfaceName);\n    function initialize(\n        SimpleAccessManagerInitializer[] memory methodSettings,\n        address target,\n        IDistributor distributor\n    ) public initializer {\n        Storage storage s = getStorage();\n        s.distributor = distributor;\n        s.target = target;\n        if (!ERC165Checker.supportsInterface(address(distributor), type(IDistributor).interfaceId)) {\n            revert ERC165CheckFailed(address(distributor), type(IDistributor).interfaceId, \"IDistributor\");\n        }\n        uint256 length = methodSettings.length;\n        for (uint256 i; i < length; ++i) {\n            s.methodSettings[methodSettings[i].selector].isDistributionOnly = methodSettings[i]\n                .distributionComponentsOnly;\n            uint256 disallowedMethodsLength = methodSettings[i].disallowedAddresses.length;\n            for (uint256 j; j < disallowedMethodsLength; ++j) {\n                s.methodSettings[methodSettings[i].selector].disallowedAddresses[\n                    methodSettings[i].disallowedAddresses[j]\n                ] = true;\n            }\n        }\n    }\n\n    error OnlyTargetAllowed(address sender, address target);\n    error disallowedAddress(address sender, bytes4 selector);\n\n    function beforeCall(\n        bytes memory,\n        bytes4 selector,\n        address sender,\n        uint256 value,\n        bytes memory data\n    ) external returns (bytes memory) {\n        Storage storage s = getStorage();\n        if (msg.sender != s.target) {\n            revert OnlyTargetAllowed(msg.sender, s.target);\n        }\n        if (s.methodSettings[selector].disallowedAddresses[sender]) {\n            revert disallowedAddress(sender, selector);\n        } else {\n            if (s.methodSettings[selector].isDistributionOnly) {\n                return s.distributor.beforeCall(abi.encode(msg.sender), selector, sender, value, data);\n            }\n            return \"\";\n        }\n    }\n\n    function afterCall(\n        bytes memory,\n        bytes4 selector,\n        address sender,\n        uint256 value,\n        bytes memory data,\n        bytes memory beforeCallResult\n    ) external {\n        Storage storage s = getStorage();\n        if (msg.sender != s.target) {\n            revert OnlyTargetAllowed(msg.sender, s.target);\n        }\n        if (s.methodSettings[selector].isDistributionOnly) {\n            s.distributor.afterCall(abi.encode(msg.sender), selector, sender, value, data, beforeCallResult);\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\n        return interfaceId == type(IERC7746).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@peeramid-labs/eds/src/repositories/OwnableRepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../abstracts/Repository.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../interfaces/IRepository.sol\";\ncontract OwnableRepository is Repository, Ownable, ERC165 {\n    constructor(address owner, bytes32 name, string memory cURI) Ownable(owner) Repository(name, cURI) {}\n\n    function updateReleaseMetadata(LibSemver.Version memory version, bytes calldata releaseMetadata) public onlyOwner {\n        super._updateReleaseMetadata(version, releaseMetadata);\n    }\n    function newRelease(bytes32 sourceId, bytes memory metadata, LibSemver.Version memory version) public onlyOwner {\n        super._newRelease(sourceId, metadata, version);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IRepository).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "src/abstracts/DiamondReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Author: @Peersky https://github.com/peersky\n * Adapted this diamond reentrancy guard from:\n\n * Authors: Moonstream Engineering (engineering@moonstream.to)\n * GitHub: https://github.com/bugout-dev/dao\n */\n\npragma solidity ^0.8.20;\nimport \"../libraries/LibReentrancyGuard.sol\";\n\nabstract contract DiamondReentrancyGuard {\n    modifier nonReentrant() {\n        LibReentrancyGuard.ReentrancyGuardStruct storage rgs = LibReentrancyGuard.reentrancyGuardStorage();\n        require(!rgs._entered, \"REG: You shall not pass!\");\n        rgs._entered = true;\n        _;\n        rgs._entered = false;\n    }\n}\n"
    },
    "src/abstracts/draft-EIP712Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport \"../libraries/LibEIP712Storage.sol\";\nimport \"../modifiers/OnlyOwnerDiamond.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 is OnlyOwnerDiamond {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor() {}\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\n        if (address(this) == ss._CACHED_THIS && block.chainid == ss._CACHED_CHAIN_ID) {\n            return ss._CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(ss._TYPE_HASH, ss._HASHED_NAME, ss._HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "src/abstracts/LockableERC1155.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol\";\nimport {ILockableERC1155} from \"../interfaces/ILockableERC1155.sol\";\n\n/**\n * @title LockableERC1155\n * @dev This is an abstract contract that extends the ERC1155 token contract and implements the ILockableERC1155 interface.\n *      It provides functionality to lock and unlock token amounts for specific accounts and IDs.\n */\nabstract contract LockableERC1155 is ERC1155BurnableUpgradeable, ILockableERC1155 {\n    struct LockableERC1155Storage {\n        mapping(address => mapping(uint256 tokenId => uint256)) lockedAmounts;\n    }\n\n    bytes32 constant LOCKABLE_TOKEN_STORAGE_POSITION = keccak256(\"erc1155.lockable.storage.position\");\n\n    function getLockableERC1155Storage() private pure returns (LockableERC1155Storage storage s) {\n        bytes32 position = LOCKABLE_TOKEN_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /**\n     * @dev Locks a specified amount of tokens for a given account and token ID.\n     * If the account does not have enough balance to lock the specified amount,\n     * the function will revert with an \"insufficient\" error message.\n     * Emits a `TokensLocked` event after successfully locking the tokens.\n     * @param account The address of the account to lock tokens for.\n     * @param id The ID of the token to lock.\n     * @param amount The amount of tokens to lock.\n     */\n    function lock(address account, uint256 id, uint256 amount) public virtual {\n        LockableERC1155Storage storage s = getLockableERC1155Storage();\n        if (balanceOf(account, id) < s.lockedAmounts[account][id] + amount)\n            revert insufficient(id, s.lockedAmounts[account][id], amount);\n        s.lockedAmounts[account][id] += amount;\n        emit TokensLocked(account, id, amount);\n    }\n\n    /**\n     * @dev Unlocks a specified amount of tokens for a given account and token ID.\n     * If the locked amount is less than the specified amount, it reverts with an \"insufficient\" error message.\n     * Emits a `TokensUnlocked` event after unlocking the tokens.\n     * @param account The address of the account to unlock tokens for.\n     * @param id The ID of the token to unlock.\n     * @param amount The amount of tokens to unlock.\n     */\n    function unlock(address account, uint256 id, uint256 amount) public virtual {\n        LockableERC1155Storage storage s = getLockableERC1155Storage();\n        if (s.lockedAmounts[account][id] < amount) revert insufficient(id, s.lockedAmounts[account][id], amount);\n        s.lockedAmounts[account][id] -= amount;\n        emit TokensUnlocked(account, id, amount);\n    }\n\n    /**\n     * @dev Returns the unlocked balance of a specific ERC1155 token for an account.\n     * The unlocked balance is calculated by subtracting the locked amount from the total balance.\n     * @param account The address of the account.\n     * @param id The ID of the ERC1155 token.\n     * @return The unlocked balance of the ERC1155 token for the account.\n     */\n    function unlockedBalanceOf(address account, uint256 id) public view returns (uint256) {\n        LockableERC1155Storage storage s = getLockableERC1155Storage();\n        return balanceOf(account, id) - s.lockedAmounts[account][id];\n    }\n\n    /**\n     * @dev Hook function that is called before any token transfer.\n     * It checks if the transfer is allowed based on the locked amounts of the tokens.\n     * If the transfer is not allowed, it reverts with an error message.\n     * @param from The address from which the tokens are being transferred.\n     * @param to The address to which the tokens are being transferred.\n     * @param ids An array of token IDs being transferred.\n     * @param values An array of token amounts being transferred.\n     */\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override {\n        for (uint256 i = 0; i < ids.length; ++i) {\n            if (from != address(0)) {\n                if (getLockableERC1155Storage().lockedAmounts[from][ids[i]] + values[i] > balanceOf(from, ids[i])) {\n                    revert insufficient(\n                        ids[i],\n                        balanceOf(from, ids[i]),\n                        getLockableERC1155Storage().lockedAmounts[from][ids[i]] + values[i]\n                    );\n                }\n            }\n        }\n        super._update(from, to, ids, values);\n    }\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual override(ERC1155BurnableUpgradeable, ILockableERC1155) {\n        if (getLockableERC1155Storage().lockedAmounts[account][id] + value > balanceOf(account, id))\n            revert insufficient(\n                id,\n                balanceOf(account, id),\n                getLockableERC1155Storage().lockedAmounts[account][id] + value\n            );\n        super.burn(account, id, value);\n    }\n}\n"
    },
    "src/distributions/ArguableVotingTournament.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\n\nimport \"./InitializedDiamondDistribution.sol\";\nimport \"../vendor/diamond/facets/DiamondLoupeFacet.sol\";\nimport \"../facets/EIP712InspectorFacet.sol\";\nimport \"../vendor/diamond/facets/OwnershipFacet.sol\";\nimport \"../facets/RankifyInstanceMainFacet.sol\";\nimport \"../facets/RankifyInstanceRequirementsFacet.sol\";\nimport \"../facets/RankifyInstanceGameMastersFacet.sol\";\nimport \"../initializers/RankifyInstanceInit.sol\";\nimport \"../vendor/diamond/interfaces/IDiamondCut.sol\";\nimport \"@peeramid-labs/eds/src/libraries/LibSemver.sol\";\n\n/**\n * @title ArguableVotingTournament Distribution\n * @notice This contract implements a diamond distribution for the Ethereum Distribution System (EDS).\n *         It creates and manages instances of ArguableVotingTournament, enabling decentralized\n *         tournament management with voting capabilities.\n * @dev This contract follows the Diamond pattern and is designed to be used exclusively by the\n *      Distributor contract. It manages facets for tournament operations, voting, and game master functions.\n * @author Peeramid Labs, 2024\n */\ncontract ArguableVotingTournament is InitializedDiamondDistribution {\n    DiamondLoupeFacet private immutable _loupeFacet;\n    EIP712InspectorFacet private immutable _inspectorFacet;\n    RankifyInstanceMainFacet private immutable _RankifyMainFacet;\n    RankifyInstanceRequirementsFacet private immutable _RankifyReqsFacet;\n    RankifyInstanceGameMastersFacet private immutable _RankifyGMFacet;\n    OwnershipFacet private immutable _OwnershipFacet;\n    address private immutable _initializer;\n\n    bytes32 private immutable distributionName;\n    uint256 private immutable distributionVersion;\n\n    /**\n     * @dev Utility function to convert function signature strings to selectors\n     * @param signature The function signature as a string\n     * @return bytes4 The corresponding function selector\n     */\n    function stringToSelector(string memory signature) private pure returns (bytes4) {\n        return bytes4(keccak256(bytes(signature)));\n    }\n\n    /**\n     * @dev Groups the addresses of all required facets for the tournament\n     * @notice This struct helps organize the deployment of the diamond proxy system\n     */\n    struct ArguableTournamentAddresses {\n        address loupeFacet;\n        address inspectorFacet;\n        address RankifyMainFacet;\n        address RankifyReqsFacet;\n        address RankifyGMFacet;\n        address OwnershipFacet;\n    }\n\n    /**\n     * @dev Constructor for the ArguableVotingTournament contract\n     * @notice Sets up the diamond proxy system with all required facets and initializes core components\n     * @dev The initializer function is added as a regular facet to the Diamond Proxy.\n     *      Since initialization is handled by the distributor contract, it's expected that\n     *      the distributor will remove this facet after successful initialization.\n     */\n    constructor(\n        address initializer,\n        bytes4 initializerSelector,\n        bytes32 _distributionName,\n        LibSemver.Version memory version,\n        ArguableTournamentAddresses memory addresses\n    ) InitializedDiamondDistribution(address(this), bytes32(0), initializerSelector) {\n        _initializer = initializer;\n        _loupeFacet = DiamondLoupeFacet(addresses.loupeFacet);\n        _inspectorFacet = EIP712InspectorFacet(addresses.inspectorFacet);\n        _RankifyMainFacet = RankifyInstanceMainFacet(addresses.RankifyMainFacet);\n        _RankifyReqsFacet = RankifyInstanceRequirementsFacet(addresses.RankifyReqsFacet);\n        _RankifyGMFacet = RankifyInstanceGameMastersFacet(addresses.RankifyGMFacet);\n        _OwnershipFacet = OwnershipFacet(addresses.OwnershipFacet);\n\n        distributionName = _distributionName;\n        distributionVersion = LibSemver.toUint256(version);\n    }\n\n    /**\n     * @notice see Ethereum Distribution System IDistribute for interface specification.\n     * @return instances Array[8]: [diamond proxy, 8x diamond facets..]\n     * @return distributionName: bytes32 encoded name to be used in EIP712 signing flow\n     * @return distributionVersion: uint256 encoded distribution version. Can be parsed to eip712 signature with EDS LibSemver\n     * @dev   // instances: 0 - diamond; 1 - DiamondLoupeFacet; 2 - EIP712InspectorFacet; 3 - RankifyInstanceMainFacet; 4 - RankifyInstanceRequirementsFacet; 5 - RankifyInstanceGameMastersFacet // 6 - OwnershipFacet\n     */\n    function instantiate(bytes memory) external override returns (address[] memory instances, bytes32, uint256) {\n        (address[] memory _instances, , ) = super._instantiate();\n        address diamond = _instances[0];\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](7);\n\n        bytes4[] memory loupeSelectors = new bytes4[](4);\n        loupeSelectors[0] = DiamondLoupeFacet.facets.selector;\n        loupeSelectors[1] = DiamondLoupeFacet.facetFunctionSelectors.selector;\n        loupeSelectors[2] = DiamondLoupeFacet.facetAddresses.selector;\n        loupeSelectors[3] = DiamondLoupeFacet.facetAddress.selector;\n        facetCuts[0] = IDiamondCut.FacetCut({\n            facetAddress: address(_loupeFacet),\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: loupeSelectors\n        });\n\n        bytes4[] memory EIP712InspectorFacetSelectors = new bytes4[](2);\n        EIP712InspectorFacetSelectors[0] = EIP712InspectorFacet.inspectEIP712Hashes.selector;\n        EIP712InspectorFacetSelectors[1] = EIP712InspectorFacet.currentChainId.selector;\n\n        facetCuts[1] = IDiamondCut.FacetCut({\n            facetAddress: address(_inspectorFacet),\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: EIP712InspectorFacetSelectors\n        });\n        bytes4[] memory RankifyInstanceMainFacetSelectors = new bytes4[](28);\n        RankifyInstanceMainFacetSelectors[0] = RankifyInstanceMainFacet.cancelGame.selector;\n        RankifyInstanceMainFacetSelectors[1] = RankifyInstanceMainFacet.gameCreator.selector;\n        RankifyInstanceMainFacetSelectors[2] = RankifyInstanceMainFacet.createGame.selector;\n        RankifyInstanceMainFacetSelectors[3] = RankifyInstanceMainFacet.leaveGame.selector;\n        RankifyInstanceMainFacetSelectors[4] = RankifyInstanceMainFacet.joinGame.selector;\n        RankifyInstanceMainFacetSelectors[5] = RankifyInstanceMainFacet.openRegistration.selector;\n        RankifyInstanceMainFacetSelectors[6] = RankifyInstanceMainFacet.startGame.selector;\n        RankifyInstanceMainFacetSelectors[7] = RankifyInstanceMainFacet.onERC1155BatchReceived.selector;\n        RankifyInstanceMainFacetSelectors[8] = RankifyInstanceMainFacet.onERC1155Received.selector;\n        RankifyInstanceMainFacetSelectors[9] = RankifyInstanceMainFacet.onERC721Received.selector;\n        RankifyInstanceMainFacetSelectors[10] = RankifyInstanceMainFacet.getContractState.selector;\n        RankifyInstanceMainFacetSelectors[11] = RankifyInstanceMainFacet.getTurn.selector;\n        RankifyInstanceMainFacetSelectors[12] = RankifyInstanceMainFacet.getGM.selector;\n        RankifyInstanceMainFacetSelectors[13] = RankifyInstanceMainFacet.getScores.selector;\n        RankifyInstanceMainFacetSelectors[14] = RankifyInstanceMainFacet.isOvertime.selector;\n        RankifyInstanceMainFacetSelectors[15] = RankifyInstanceMainFacet.isGameOver.selector;\n        RankifyInstanceMainFacetSelectors[16] = RankifyInstanceMainFacet.getPlayersGame.selector;\n        RankifyInstanceMainFacetSelectors[17] = RankifyInstanceMainFacet.isLastTurn.selector;\n        RankifyInstanceMainFacetSelectors[18] = RankifyInstanceMainFacet.isRegistrationOpen.selector;\n        RankifyInstanceMainFacetSelectors[19] = RankifyInstanceMainFacet.getGameRank.selector;\n        RankifyInstanceMainFacetSelectors[20] = RankifyInstanceMainFacet.getPlayers.selector;\n        RankifyInstanceMainFacetSelectors[21] = RankifyInstanceMainFacet.canStartGame.selector;\n        RankifyInstanceMainFacetSelectors[22] = RankifyInstanceMainFacet.canEndTurn.selector;\n        RankifyInstanceMainFacetSelectors[23] = RankifyInstanceMainFacet.isPlayerTurnComplete.selector;\n        RankifyInstanceMainFacetSelectors[24] = RankifyInstanceMainFacet.getPlayerVotedArray.selector;\n        RankifyInstanceMainFacetSelectors[25] = RankifyInstanceMainFacet.getPlayersMoved.selector;\n        RankifyInstanceMainFacetSelectors[26] = RankifyInstanceMainFacet.estimateGamePrice.selector;\n        RankifyInstanceMainFacetSelectors[27] = RankifyInstanceMainFacet.isActive.selector;\n\n        facetCuts[2] = IDiamondCut.FacetCut({\n            facetAddress: address(_RankifyMainFacet),\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: RankifyInstanceMainFacetSelectors\n        });\n\n        bytes4[] memory RankifyInstanceRequirementsFacetSelectors = new bytes4[](3);\n        RankifyInstanceRequirementsFacetSelectors[0] = RankifyInstanceRequirementsFacet.setJoinRequirements.selector;\n        RankifyInstanceRequirementsFacetSelectors[1] = RankifyInstanceRequirementsFacet.getJoinRequirements.selector;\n        RankifyInstanceRequirementsFacetSelectors[2] = RankifyInstanceRequirementsFacet\n            .getJoinRequirementsByToken\n            .selector;\n\n        facetCuts[3] = IDiamondCut.FacetCut({\n            facetAddress: address(_RankifyReqsFacet),\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: RankifyInstanceRequirementsFacetSelectors\n        });\n\n        bytes4[] memory RankifyInstanceGameMastersFacetSelectors = new bytes4[](3);\n        RankifyInstanceGameMastersFacetSelectors[0] = RankifyInstanceGameMastersFacet.submitVote.selector;\n        RankifyInstanceGameMastersFacetSelectors[1] = RankifyInstanceGameMastersFacet.submitProposal.selector;\n        RankifyInstanceGameMastersFacetSelectors[2] = RankifyInstanceGameMastersFacet.endTurn.selector;\n\n        facetCuts[4] = IDiamondCut.FacetCut({\n            facetAddress: address(_RankifyGMFacet),\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: RankifyInstanceGameMastersFacetSelectors\n        });\n\n        bytes4[] memory OwnershipFacetSelectors = new bytes4[](2);\n        OwnershipFacetSelectors[0] = _OwnershipFacet.transferOwnership.selector;\n        OwnershipFacetSelectors[1] = _OwnershipFacet.owner.selector;\n\n        facetCuts[5] = IDiamondCut.FacetCut({\n            facetAddress: address(_OwnershipFacet),\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: OwnershipFacetSelectors\n        });\n        bytes4[] memory initializerSelectors = new bytes4[](1);\n        initializerSelectors[0] = RankifyInstanceInit.init.selector;\n        facetCuts[6] = IDiamondCut.FacetCut({\n            facetAddress: _initializer,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: initializerSelectors\n        });\n\n        super.initialize(DiamondCutFacet(diamond), facetCuts, \"\");\n        address[] memory returnValue = new address[](8);\n        returnValue[0] = diamond;\n        returnValue[1] = facetCuts[0].facetAddress;\n        returnValue[2] = facetCuts[1].facetAddress;\n        returnValue[3] = facetCuts[2].facetAddress;\n        returnValue[4] = facetCuts[3].facetAddress;\n        returnValue[5] = facetCuts[4].facetAddress;\n        returnValue[6] = facetCuts[5].facetAddress;\n        returnValue[7] = facetCuts[6].facetAddress;\n        //renouncing ownership\n        OwnershipFacet(diamond).transferOwnership(address(0));\n\n        return (returnValue, distributionName, distributionVersion);\n    }\n\n    function contractURI() public pure virtual override returns (string memory) {\n        return string(abi.encodePacked(super.contractURI(), \";\", \"ArguableVotingTournament\"));\n    }\n\n    function sources() internal view virtual override returns (address[] memory, bytes32, uint256) {\n        (address[] memory srcs, , ) = super.sources();\n        return (srcs, distributionName, distributionVersion);\n    }\n}\n"
    },
    "src/distributions/DiamondDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\n\nimport \"@peeramid-labs/eds/src/abstracts/CloneDistribution.sol\";\nimport \"../vendor/diamond/DiamondClonable.sol\";\nimport \"../vendor/diamond/facets/DiamondCutFacet.sol\";\n\n/**\n * @title Diamond Proxy Distribution\n * @notice This contract is EDS compatible factory for diamond proxies\n * @dev This uses modified version of Diamond Proxy, which allows proxy itself to cloned\n * @author Peeramid Labs, 2024\n */\ncontract DiamondDistribution is CloneDistribution {\n    address private immutable _reference;\n\n    constructor(address owner) {\n        address diamondCutFacet = address(new DiamondCutFacet());\n        // Deploy the diamond proxy contract\n        address diamondProxy = address(new DiamondClonable(owner, diamondCutFacet));\n        _reference = diamondProxy;\n    }\n\n    function instantiate(bytes memory) external virtual override returns (address[] memory, bytes32, uint256) {\n        return super._instantiate();\n    }\n\n    function sources() internal view virtual override returns (address[] memory, bytes32 name, uint256 version) {\n        address[] memory _sources = new address[](1);\n        _sources[0] = _reference;\n        return (_sources, bytes32(abi.encodePacked(\"DiamondDistribution\")), uint256(0));\n    }\n\n    function contractURI() public pure virtual override returns (string memory) {\n        return \"\";\n    }\n}\n"
    },
    "src/distributions/InitializedDiamondDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../vendor/diamond/DiamondClonable.sol\";\nimport \"../vendor/diamond/facets/DiamondCutFacet.sol\";\nimport \"./DiamondDistribution.sol\";\nimport \"../vendor/diamond/libraries/LibDiamond.sol\";\nimport \"../vendor/diamond/interfaces/IDiamondCut.sol\";\n\n/**\n * @title Initialized Diamond Proxy Distribution\n * @notice This contract is EDS compatible factory for diamond proxies\n * @dev This allows to store immutable initializer logic for a cloned diamond proxy\n * @author Peeramid Labs, 2024\n */\nabstract contract InitializedDiamondDistribution is DiamondDistribution {\n    address private immutable initializer;\n    bytes4 private immutable initializerSelector;\n\n    constructor(address owner, bytes32 _initializerId, bytes4 _initializerSelector) DiamondDistribution(owner) {\n        initializer = getContractsIndex().get(_initializerId);\n        initializerSelector = _initializerSelector;\n    }\n\n    function initialize(\n        DiamondCutFacet instance,\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        bytes memory args\n    ) internal virtual {\n        bytes memory _calldata = args.length > 0 ? abi.encodeWithSelector(initializerSelector, args) : bytes(\"\");\n        instance.diamondCut(_diamondCut, initializer, _calldata);\n    }\n\n    function get() public view virtual override returns (address[] memory, bytes32 name, uint256 version) {\n        (address[] memory srcs, , ) = super.sources();\n        address[] memory _sources = new address[](2);\n        assert(srcs.length == 1);\n        _sources[0] = srcs[0];\n        _sources[1] = initializer;\n        return (srcs, bytes32(abi.encodePacked(\"InitializedDiamondDistribution\")), uint256(0));\n    }\n\n    function contractURI() public pure virtual override returns (string memory) {\n        return string(abi.encodePacked(super.contractURI(), \";\", \"InitializedDiamondDistribution\")); //ToDo: Add IPFS link with readme!\n    }\n}\n"
    },
    "src/distributions/MAODistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@peeramid-labs/eds/src/interfaces/IDistribution.sol\";\nimport \"@peeramid-labs/eds/src/libraries/LibSemver.sol\";\nimport {DistributableGovernanceERC20, MintSettings} from \"../tokens/DistributableGovernanceERC20.sol\";\nimport {IERC7746} from \"@peeramid-labs/eds/src/interfaces/IERC7746.sol\";\nimport {SimpleAccessManager} from \"@peeramid-labs/eds/src/managers/SimpleAccessManager.sol\";\nimport {IDistributor} from \"@peeramid-labs/eds/src/interfaces/IDistributor.sol\";\nimport {RankToken} from \"../tokens/RankToken.sol\";\nimport \"../initializers/RankifyInstanceInit.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@peeramid-labs/eds/src/abstracts/CodeIndexer.sol\";\nimport \"hardhat/console.sol\";\nimport {TokenSettings} from \"../vendor/aragon/interfaces.sol\";\n\n/**\n * @title MAODistribution\n * @dev This contract implements the IDistribution and CodeIndexer interfaces. It uses the Clones library for address cloning.\n *\n * @notice The contract is responsible for creating and managing DAOs and Rankify distributions.\n * @author Peeramid Labs, 2024\n */\ncontract MAODistribution is IDistribution, CodeIndexer {\n    struct UserRankifySettings {\n        uint256 principalCost;\n        uint96 principalTimeConstant;\n        string metadata;\n        string rankTokenURI;\n        string rankTokenContractURI;\n    }\n\n    struct TokenArguments {\n        string tokenName;\n        string tokenSymbol;\n    }\n\n    struct DistributorArguments {\n        TokenArguments tokenSettings;\n        UserRankifySettings rankifySettings;\n    }\n\n    using Clones for address;\n    address private immutable _trustedForwarder;\n    bytes32 private immutable _distributionName;\n    uint256 private immutable _distributionVersion;\n    address private immutable _rankTokenBase;\n    IDistribution private immutable _RankifyDistributionBase;\n    address private immutable _governanceERC20Base;\n    address private immutable _accessManagerBase;\n    address private immutable _paymentToken;\n    address private immutable _beneficiary;\n\n    /**\n     * @notice Initializes the contract with the provided parameters and performs necessary checks.\n     * @dev Retrieves contract addresses from a contract index using the provided identifiers\n     *      and initializes the distribution system.\n     * @param trustedForwarder Address of the trusted forwarder for meta-transactions (WARNING: Not yet reviewed)\n     * @param paymentToken Address of the token used for payments in the system\n     * @param beneficiary Address that receives payments and fees\n     * @param rankTokenCodeId Identifier for the rank token implementation in CodeIndex\n     * @param RankifyDIistributionId Identifier for the Rankify distribution implementation\n     * @param accessManagerId Identifier for the access manager implementation\n     * @param governanceERC20BaseId Identifier for the governance token implementation\n     * @param distributionName Name identifier for this distribution\n     * @param distributionVersion Semantic version information as LibSemver.Version struct\n     */\n    constructor(\n        address trustedForwarder,\n        address paymentToken,\n        address beneficiary,\n        bytes32 rankTokenCodeId,\n        bytes32 RankifyDIistributionId,\n        bytes32 accessManagerId,\n        bytes32 governanceERC20BaseId,\n        bytes32 distributionName,\n        LibSemver.Version memory distributionVersion\n    ) {\n        _trustedForwarder = trustedForwarder;\n        _distributionName = distributionName;\n        _distributionVersion = LibSemver.toUint256(distributionVersion);\n        _rankTokenBase = getContractsIndex().get(rankTokenCodeId);\n        _governanceERC20Base = getContractsIndex().get(governanceERC20BaseId);\n\n        if (_governanceERC20Base == address(0)) {\n            revert(\"Governance ERC20 base not found\");\n        }\n\n        if (beneficiary == address(0)) {\n            revert(\"Beneficiary not found\");\n        }\n        _beneficiary = beneficiary;\n        if (paymentToken == address(0)) {\n            revert(\"Payment token not found\");\n        }\n        _paymentToken = paymentToken;\n        if (_rankTokenBase == address(0)) {\n            revert(\"Rank token base not found\");\n        }\n        _RankifyDistributionBase = IDistribution(getContractsIndex().get(RankifyDIistributionId));\n        if (address(_RankifyDistributionBase) == address(0)) {\n            revert(\"Rankify distribution base not found\");\n        }\n\n        _accessManagerBase = getContractsIndex().get(accessManagerId);\n        if (_accessManagerBase == address(0)) {\n            revert(\"Access manager base not found\");\n        }\n        require(\n            ERC165Checker.supportsInterface(_accessManagerBase, type(IERC7746).interfaceId),\n            \"Access manager does not support IERC7746\"\n        );\n    }\n\n    function createToken(TokenArguments memory args) internal returns (address[] memory instances, bytes32, uint256) {\n        MintSettings memory mintSettings = MintSettings(new address[](1), new uint256[](1));\n        mintSettings.receivers[0] = address(this);\n        mintSettings.amounts[0] = 0;\n        address token = _governanceERC20Base.clone();\n        TokenSettings memory tokenSettings = TokenSettings(token, args.tokenName, args.tokenSymbol);\n\n        SimpleAccessManager.SimpleAccessManagerInitializer[]\n            memory govTokenAccessSettings = new SimpleAccessManager.SimpleAccessManagerInitializer[](1);\n        govTokenAccessSettings[0].selector = DistributableGovernanceERC20.mint.selector;\n        govTokenAccessSettings[0].disallowedAddresses = new address[](1);\n        govTokenAccessSettings[0].distributionComponentsOnly = true;\n\n        SimpleAccessManager govTokenAccessManager = SimpleAccessManager(_accessManagerBase.clone());\n\n        govTokenAccessManager.initialize(govTokenAccessSettings, tokenSettings.addr, IDistributor(msg.sender)); // msg.sender must be IDistributor or it will revert\n        DistributableGovernanceERC20(tokenSettings.addr).initialize(\n            tokenSettings.name,\n            tokenSettings.symbol,\n            mintSettings,\n            address(govTokenAccessManager)\n        );\n\n        address[] memory returnValue = new address[](2);\n        returnValue[0] = token;\n        returnValue[1] = address(govTokenAccessManager);\n\n        return (returnValue, \"OSxDistribution\", 1);\n    }\n\n    function createRankify(\n        UserRankifySettings memory args\n    ) internal returns (address[] memory instances, bytes32, uint256) {\n        address rankToken = _rankTokenBase.clone();\n\n        bytes4[] memory rankTokenSelectors = new bytes4[](6);\n        rankTokenSelectors[0] = RankToken.mint.selector;\n        rankTokenSelectors[1] = RankToken.lock.selector;\n        rankTokenSelectors[2] = RankToken.unlock.selector;\n        rankTokenSelectors[3] = RankToken.batchMint.selector;\n        rankTokenSelectors[4] = RankToken.setURI.selector;\n        rankTokenSelectors[5] = RankToken.setContractURI.selector;\n        SimpleAccessManager rankTokenAccessManager = SimpleAccessManager(_accessManagerBase.clone());\n\n        SimpleAccessManager.SimpleAccessManagerInitializer[]\n            memory RankTokenAccessSettings = new SimpleAccessManager.SimpleAccessManagerInitializer[](6);\n\n        RankTokenAccessSettings[0].selector = RankToken.mint.selector;\n        RankTokenAccessSettings[0].disallowedAddresses = new address[](1);\n        RankTokenAccessSettings[0].distributionComponentsOnly = true;\n\n        RankTokenAccessSettings[1].selector = RankToken.lock.selector;\n        RankTokenAccessSettings[1].disallowedAddresses = new address[](1);\n        RankTokenAccessSettings[1].distributionComponentsOnly = true;\n\n        RankTokenAccessSettings[2].selector = RankToken.unlock.selector;\n        RankTokenAccessSettings[2].disallowedAddresses = new address[](1);\n        RankTokenAccessSettings[2].distributionComponentsOnly = true;\n\n        RankTokenAccessSettings[3].selector = RankToken.batchMint.selector;\n        RankTokenAccessSettings[3].disallowedAddresses = new address[](1);\n        RankTokenAccessSettings[3].distributionComponentsOnly = true;\n\n        RankTokenAccessSettings[4].selector = RankToken.setURI.selector;\n        RankTokenAccessSettings[4].distributionComponentsOnly = true;\n\n        RankTokenAccessSettings[5].selector = RankToken.setContractURI.selector;\n        RankTokenAccessSettings[5].distributionComponentsOnly = true;\n\n        rankTokenAccessManager.initialize(RankTokenAccessSettings, rankToken, IDistributor(msg.sender)); // msg.sender must be IDistributor or it will revert\n        RankToken(rankToken).initialize(args.rankTokenURI, args.rankTokenContractURI, address(rankTokenAccessManager));\n\n        (\n            address[] memory RankifyDistrAddresses,\n            bytes32 RankifyDistributionName,\n            uint256 RankifyDistributionVersion\n        ) = _RankifyDistributionBase.instantiate(\"\");\n\n        RankifyInstanceInit.contractInitializer memory RankifyInit = RankifyInstanceInit.contractInitializer({\n            rewardToken: rankToken,\n            principalCost: args.principalCost,\n            principalTimeConstant: args.principalTimeConstant,\n            paymentToken: _paymentToken,\n            beneficiary: _beneficiary\n        });\n\n        RankifyInstanceInit(RankifyDistrAddresses[0]).init(\n            string(abi.encodePacked(RankifyDistributionName)),\n            LibSemver.toString(LibSemver.parse(RankifyDistributionVersion)),\n            RankifyInit\n        );\n        address[] memory returnValue = new address[](RankifyDistrAddresses.length + 2);\n        for (uint256 i; i < RankifyDistrAddresses.length; ++i) {\n            returnValue[i] = RankifyDistrAddresses[i];\n        }\n        returnValue[RankifyDistrAddresses.length] = address(rankTokenAccessManager);\n        returnValue[RankifyDistrAddresses.length + 1] = rankToken;\n\n        return (returnValue, RankifyDistributionName, RankifyDistributionVersion);\n    }\n\n    /**\n     * @notice Instantiates a new instance with the provided data.\n     * @param data The initialization data for the new instance, typeof {DistributorArguments}.\n     * @return instances An array of addresses representing the new instances.\n     * @return distributionName A bytes32 value representing the name of the distribution.\n     * @return distributionVersion A uint256 value representing the version of the distribution.\n     * @dev `instances` array contents: DAO, GovernanceToken, Gov Token AccessManager, Rankify Diamond, 8x Rankify Diamond facets, RankTokenAccessManager, RankToken\n     */\n    function instantiate(\n        bytes memory data\n    ) public override returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion) {\n        DistributorArguments memory args = abi.decode(data, (DistributorArguments));\n\n        (address[] memory tokenInstances, , ) = createToken(args.tokenSettings);\n        (address[] memory RankifyInstances, , ) = createRankify(args.rankifySettings);\n\n        address[] memory returnValue = new address[](tokenInstances.length + RankifyInstances.length);\n\n        for (uint256 i; i < tokenInstances.length; ++i) {\n            returnValue[i] = tokenInstances[i];\n        }\n        for (uint256 i; i < RankifyInstances.length; ++i) {\n            returnValue[tokenInstances.length + i] = RankifyInstances[i];\n        }\n        return (returnValue, _distributionName, _distributionVersion);\n    }\n\n    function contractURI() public pure virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function get() external view returns (address[] memory sources, bytes32, uint256) {\n        address[] memory srcs = new address[](5);\n        srcs[0] = address(_trustedForwarder);\n        srcs[1] = address(_rankTokenBase);\n        srcs[2] = address(_RankifyDistributionBase);\n        srcs[3] = address(_governanceERC20Base);\n        srcs[4] = address(_accessManagerBase);\n        return (srcs, _distributionName, _distributionVersion);\n    }\n\n    /**\n     * @notice Returns the schema of the distribution.\n     * @dev This is only needed to ensure `DistributorArguments` are provided in ABI, as it would be internal otherwise.\n     * @return DistributorArguments The schema of the distribution.\n     */\n    function distributionSchema() external pure returns (DistributorArguments memory) {\n        return\n            DistributorArguments({\n                tokenSettings: TokenArguments(\"\", \"\"),\n                rankifySettings: UserRankifySettings(0, 0, \"\", \"\", \"\")\n            });\n    }\n}\n"
    },
    "src/facets/EIP712InspectorFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"../libraries/LibEIP712Storage.sol\";\n\ncontract EIP712InspectorFacet {\n    function inspectEIP712Hashes()\n        public\n        view\n        returns (\n            bytes32 _CACHED_DOMAIN_SEPARATOR,\n            uint256 _CACHED_CHAIN_ID,\n            address _CACHED_THIS,\n            bytes32 _HASHED_NAME,\n            bytes32 _HASHED_VERSION,\n            bytes32 _TYPE_HASH\n        )\n    {\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\n\n        return (\n            ss._CACHED_DOMAIN_SEPARATOR,\n            ss._CACHED_CHAIN_ID,\n            ss._CACHED_THIS,\n            ss._HASHED_NAME,\n            ss._HASHED_VERSION,\n            ss._TYPE_HASH\n        );\n    }\n\n    function currentChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n}\n"
    },
    "src/facets/RankifyInstanceGameMastersFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\n\nimport {LibTBG} from \"../libraries/LibTurnBasedGame.sol\";\nimport {LibRankify} from \"../libraries/LibRankify.sol\";\nimport {IRankifyInstance} from \"../interfaces/IRankifyInstance.sol\";\nimport \"../abstracts/DiamondReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../abstracts/draft-EIP712Diamond.sol\";\nimport {LibCoinVending} from \"../libraries/LibCoinVending.sol\";\nimport \"hardhat/console.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"../vendor/diamond/libraries/LibDiamond.sol\";\n\n/**\n * @title RankifyInstanceGameMastersFacet\n * @notice Facet handling game master functionality for Rankify instances\n * @dev Implements game master specific operations like vote submission and game management\n * @author Peeramid Labs, 2024\n */\ncontract RankifyInstanceGameMastersFacet is DiamondReentrancyGuard, EIP712 {\n    using LibTBG for uint256;\n    using LibRankify for uint256;\n    using LibTBG for LibTBG.State;\n    event OverTime(uint256 indexed gameId);\n    event ProposalScore(\n        uint256 indexed gameId,\n        uint256 indexed turn,\n        string indexed proposalHash,\n        string proposal,\n        uint256 score\n    );\n    event TurnEnded(\n        uint256 indexed gameId,\n        uint256 indexed turn,\n        address[] players,\n        uint256[] scores,\n        string[] newProposals,\n        uint256[] proposerIndices,\n        uint256[][] votes\n    );\n    event LastTurn(uint256 indexed gameId);\n    event GameOver(uint256 indexed gameId, address[] players, uint256[] scores);\n    event ProposalSubmitted(\n        uint256 indexed gameId,\n        uint256 indexed turn,\n        address indexed proposer,\n        bytes32 commitmentHash,\n        string proposalEncryptedByGM\n    );\n    struct ProposalParams {\n        uint256 gameId;\n        string encryptedProposal;\n        bytes32 commitmentHash;\n        address proposer;\n    }\n\n    event VoteSubmitted(uint256 indexed gameId, uint256 indexed turn, address indexed player, string votesHidden);\n\n    /**\n     * @dev Handles the end of the game for a player. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Modifies:\n     *\n     * - Releases the coins for the game with `gameId`, the game creator, the top player, and `player`.\n     */\n    function onPlayersGameEnd(uint256 gameId, address player) private {\n        LibRankify.GameState storage game = gameId.getGameState();\n        LibCoinVending.release(bytes32(gameId), game.createdBy, gameId.getLeaderBoard()[0], player);\n    }\n\n    /**\n     * @dev Submits a vote for a game. `gameId` is the ID of the game. `encryptedVotes` is the encrypted votes. `voter` is the address of the voter.\n     *\n     * Emits a _VoteSubmitted_ event.\n     *\n     * Requirements:\n     *\n     * - The caller must be a game master of the game with `gameId`.\n     * - The game with `gameId` must exist.\n     * - The game with `gameId` must have started.\n     * - The game with `gameId` must not be over.\n     * - `voter` must be in the game with `gameId`.\n     * - The current turn of the game with `gameId` must be greater than 1.\n     */\n    function submitVote(uint256 gameId, string memory encryptedVotes, address voter) public {\n        LibRankify.enforceIsGM(gameId, msg.sender);\n        gameId.enforceGameExists();\n        gameId.enforceHasStarted();\n        require(!gameId.isGameOver(), \"Game over\");\n        gameId.enforceIsPlayingGame(voter);\n        require(gameId.getTurn() > 1, \"No proposals exist at turn 1: cannot vote\");\n        LibRankify.GameState storage game = gameId.getGameState();\n        require(!game.playerVoted[voter], \"Already voted\");\n        game.numVotesThisTurn += 1;\n        game.playerVoted[voter] = true;\n        gameId.tryPlayerMove(voter);\n        emit VoteSubmitted(gameId, gameId.getTurn(), voter, encryptedVotes);\n    }\n\n    /**\n     * @dev Submits a proposal for a game. `proposalData` is the proposal data.\n     *\n     * Requirements:\n     *\n     * - The game with `proposalData.gameId` must exist.\n     * - The caller must be a game master of the game with `proposalData.gameId`.\n     */\n    function submitProposal(ProposalParams memory proposalData) public {\n        proposalData.gameId.enforceGameExists();\n        proposalData.gameId.enforceIsGM(msg.sender);\n        require(!proposalData.gameId.isGameOver(), \"Game over\");\n        proposalData.gameId.enforceHasStarted();\n\n        LibRankify.GameState storage game = proposalData.gameId.getGameState();\n        require(LibTBG.getPlayersGame(proposalData.proposer) == proposalData.gameId, \"not a player\");\n        // require(!proposalData.gameId.isLastTurn(), \"Cannot propose in last turn\");\n        require(bytes(proposalData.encryptedProposal).length != 0, \"Cannot propose empty\");\n        require(game.proposalCommitmentHashes[proposalData.proposer] == \"\", \"Already proposed!\");\n        uint256 turn = proposalData.gameId.getTurn();\n        game.proposalCommitmentHashes[proposalData.proposer] = proposalData.commitmentHash;\n        game.numCommitments += 1;\n        proposalData.gameId.tryPlayerMove(proposalData.proposer);\n        emit ProposalSubmitted(\n            proposalData.gameId,\n            turn,\n            proposalData.proposer,\n            proposalData.commitmentHash,\n            proposalData.encryptedProposal\n        );\n    }\n\n    /**\n     * @dev Handles the actions after the next turn of a game with the provided game ID. `gameId` is the ID of the game. `newProposals` is the array of new proposals.\n     *\n     * Modifies:\n     *\n     * - Sets the ongoing proposals of the game with `gameId` to `newProposals`.\n     * - Increments the number of ongoing proposals of the game with `gameId` by the number of `newProposals`.\n     */\n    function _afterNextTurn(uint256 gameId, string[] memory newProposals) private {\n        LibRankify.GameState storage game = gameId.getGameState();\n        for (uint256 i = 0; i < newProposals.length; ++i) {\n            game.ongoingProposals[i] = newProposals[i];\n        }\n    }\n\n    /**\n     * @dev Handles the next turn of a game with the provided game ID. `gameId` is the ID of the game. `newProposals` is the array of new proposals.\n     *\n     * Emits an {OverTime_ event if the game is in the last turn and overtime.\n     * emits a _LastTurn_ event if the game is in the last turn.\n     * emits a _GameOver_ event if the game is over.\n     *\n     * Modifies:\n     *\n     * - Calls the `_afterNextTurn` function with `gameId` and `newProposals`.\n     */\n    function _nextTurn(uint256 gameId, string[] memory newProposals) private {\n        (bool _isLastTurn, bool _isOvertime, bool _isGameOver) = gameId.nextTurn();\n        if (_isLastTurn && _isOvertime) {\n            emit OverTime(gameId);\n        }\n        if (_isLastTurn) {\n            emit LastTurn(gameId);\n        }\n        if (_isGameOver) {\n            uint256[] memory finalScores = gameId.closeGame(onPlayersGameEnd);\n            address[] memory players = gameId.getPlayers();\n            emit GameOver(gameId, players, finalScores);\n        }\n        _afterNextTurn(gameId, newProposals);\n    }\n\n    /**\n     * @dev Ends the current turn of a game with the provided game ID. `gameId` is the ID of the game. `votes` is the array of votes.\n     *  `newProposals` is the array of new proposals for the upcoming voting round.\n     *  `proposerIndices` is the array of indices of the proposers in the previous voting round.\n     *\n     * emits a _ProposalScore_ event for each player if the turn is not the first.\n     * emits a _TurnEnded_ event.\n     *\n     * Modifies:\n     *\n     * - Calls the `_nextTurn` function with `gameId` and `newProposals`.\n     * - Resets the number of commitments of the game with `gameId` to 0.\n     * - Resets the proposal commitment hash and ongoing proposal of each player in the game with `gameId`.\n     *\n     * Requirements:\n     *\n     * - The caller must be a game master of the game with `gameId`.\n     * - The game with `gameId` must have started.\n     * - The game with `gameId` must not be over.\n     * -  newProposals array MUST be sorted randomly to ensure privacy\n     * votes and proposerIndices MUST correspond to players array from game.getPlayers()\n     */\n    function endTurn(\n        uint256 gameId,\n        uint256[][] memory votes,\n        string[] memory newProposals, //REFERRING TO UPCOMING VOTING ROUND\n        uint256[] memory proposerIndices //REFERRING TO game.players index in PREVIOUS VOTING ROUND\n    ) public {\n        gameId.enforceIsGM(msg.sender);\n        gameId.enforceHasStarted();\n        gameId.enforceIsNotOver();\n        LibRankify.GameState storage game = gameId.getGameState();\n        uint256 turn = gameId.getTurn();\n\n        address[] memory players = gameId.getPlayers();\n        if (turn != 1) {\n            uint256[][] memory votesSorted = new uint256[][](players.length);\n            for (uint256 player = 0; player < players.length; ++player) {\n                votesSorted[player] = new uint256[](players.length);\n            }\n            for (uint256 votee = 0; votee < players.length; ++votee) {\n                uint256 voteesColumn = proposerIndices[votee];\n                if (voteesColumn < players.length) {\n                    // if index is above length of players array, it means the player did not propose\n                    for (uint256 voter = 0; voter < players.length; voter++) {\n                        votesSorted[voter][votee] = votes[voter][voteesColumn];\n                    }\n                }\n            }\n\n            (, uint256[] memory roundScores) = gameId.calculateScoresQuadratic(votesSorted, proposerIndices);\n            for (uint256 i = 0; i < players.length; ++i) {\n                string memory proposal = game.ongoingProposals[proposerIndices[i]];\n                emit ProposalScore(gameId, turn, proposal, proposal, roundScores[i]);\n            }\n        }\n        (, uint256[] memory scores) = gameId.getScores();\n        emit TurnEnded(gameId, gameId.getTurn(), players, scores, newProposals, proposerIndices, votes);\n\n        // Clean up game instance for upcoming round\n\n        for (uint256 i = 0; i < players.length; ++i) {\n            game.proposalCommitmentHashes[players[i]] = bytes32(0);\n            game.ongoingProposals[i] = \"\";\n            game.playerVoted[players[i]] = false;\n            game.votesHidden[players[i]].hash = bytes32(0);\n        }\n        // This data is to needed to correctly determine \"PlayerMove\" conditions during next turn\n        game.numVotesPrevTurn = game.numVotesThisTurn;\n        game.numVotesThisTurn = 0;\n        game.numPrevProposals = game.numCommitments;\n        game.numCommitments = 0;\n\n        _nextTurn(gameId, newProposals);\n    }\n}\n"
    },
    "src/facets/RankifyInstanceMainFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {LibTBG} from \"../libraries/LibTurnBasedGame.sol\";\nimport {IRankifyInstance} from \"../interfaces/IRankifyInstance.sol\";\n\nimport {IERC1155Receiver} from \"../interfaces/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"../abstracts/DiamondReentrancyGuard.sol\";\nimport {LibRankify} from \"../libraries/LibRankify.sol\";\nimport {LibCoinVending} from \"../libraries/LibCoinVending.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../abstracts/draft-EIP712Diamond.sol\";\nimport \"hardhat/console.sol\";\nimport {IErrors} from \"../interfaces/IErrors.sol\";\n\n/**\n * @title RankifyInstanceMainFacet\n * @notice Main facet for the Rankify protocol that handles game creation and management\n * @dev Implements core game functionality, ERC token receivers, and reentrancy protection\n * @author Peeramid Labs, 2024\n */\ncontract RankifyInstanceMainFacet is\n    IRankifyInstance,\n    IERC1155Receiver,\n    DiamondReentrancyGuard,\n    IERC721Receiver,\n    EIP712,\n    IErrors\n{\n    using LibTBG for LibTBG.Instance;\n    using LibTBG for uint256;\n    using LibTBG for LibTBG.Settings;\n    using LibRankify for uint256;\n\n    /**\n     * @dev Internal function to create a new game with the specified parameters\n     * @param params Struct containing all necessary parameters for game creation\n     * @notice This function handles the core game creation logic, including:\n     *         - Setting up the game state\n     *         - Configuring the coin vending system\n     *         - Emitting the game creation event\n     */\n    function createGame(LibRankify.NewGameParams memory params) private nonReentrant {\n        LibRankify.newGame(params);\n        LibCoinVending.ConfigPosition memory emptyConfig;\n        LibCoinVending.configure(bytes32(params.gameId), emptyConfig);\n        emit gameCreated(params.gameId, params.gameMaster, msg.sender, params.gameRank);\n    }\n\n    /**\n     * @dev External function to create a new game\n     * @param params Input parameters for creating a new game\n     * @notice This function:\n     *         - Validates the contract is initialized\n     *         - Processes input parameters\n     *         - Creates a new game with specified settings\n     * @custom:security nonReentrant\n     */\n    function createGame(IRankifyInstance.NewGameParamsInput memory params) public {\n        LibRankify.enforceIsInitialized();\n        LibRankify.InstanceState storage settings = LibRankify.instanceState();\n        LibRankify.NewGameParams memory newGameParams = LibRankify.NewGameParams({\n            gameId: settings.numGames + 1,\n            gameRank: params.gameRank,\n            creator: msg.sender,\n            minPlayerCnt: params.minPlayerCnt,\n            maxPlayerCnt: params.maxPlayerCnt,\n            gameMaster: params.gameMaster,\n            nTurns: params.nTurns,\n            voteCredits: params.voteCredits,\n            minGameTime: params.minGameTime,\n            timePerTurn: params.timePerTurn,\n            timeToJoin: params.timeToJoin\n        });\n\n        createGame(newGameParams);\n    }\n\n    /**\n     * @dev Handles a player quitting a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\n     * @param gameId The ID of the game.\n     * @param player The address of the player.\n     * @notice This function:\n     *         - Refunds the coins for `player` in the game with `gameId`.\n     *         - Emits a _PlayerLeft_ event.\n     */\n    function onPlayerQuit(uint256 gameId, address player) private {\n        LibCoinVending.refund(bytes32(gameId), player);\n        emit PlayerLeft(gameId, player);\n    }\n\n    /**\n     * @dev Cancels a game with the provided game ID. `gameId` is the ID of the game.\n     * @param gameId The ID of the game.\n     * @notice This function:\n     *         - Calls the `enforceIsGameCreator` function with `msg.sender`.\n     *         - Cancels the game.\n     *         - Emits a _GameClosed_ event.\n     * @custom:security nonReentrant\n     */\n    function cancelGame(uint256 gameId) public nonReentrant {\n        gameId.enforceIsGameCreator(msg.sender);\n        gameId.cancelGame(onPlayerQuit);\n        emit GameClosed(gameId);\n    }\n\n    /**\n     * @dev Allows a player to leave a game with the provided game ID. `gameId` is the ID of the game.\n     * @param gameId The ID of the game.\n     * @notice This function:\n     *         - Calls the `quitGame` function with `msg.sender`, `true`, and `onPlayerQuit`.\n     * @custom:security nonReentrant\n     */\n    function leaveGame(uint256 gameId) public nonReentrant {\n        gameId.quitGame(msg.sender, onPlayerQuit);\n    }\n\n    /**\n     * @dev Opens registration for a game with the provided game ID. `gameId` is the ID of the game.\n     * @param gameId The ID of the game.\n     * @notice This function:\n     *         - Calls the `enforceIsGameCreator` function with `msg.sender`.\n     *         - Calls the `enforceIsPreRegistrationStage` function.\n     *         - Calls the `openRegistration` function.\n     *         - Emits a _RegistrationOpen_ event.\n     */\n    function openRegistration(uint256 gameId) public {\n        gameId.enforceGameExists();\n        gameId.enforceIsGameCreator(msg.sender);\n        gameId.enforceIsPreRegistrationStage();\n        gameId.openRegistration();\n        emit RegistrationOpen(gameId);\n    }\n\n    /**\n     * @dev Allows a player to join a game with the provided game ID. `gameId` is the ID of the game.\n     * @param gameId The ID of the game.\n     * @notice This function:\n     *         - Calls the `joinGame` function with `msg.sender`.\n     *         - Calls the `fund` function with `bytes32(gameId)`.\n     *         - Emits a _PlayerJoined_ event.\n     * @custom:security nonReentrant\n     */\n    function joinGame(uint256 gameId) public payable nonReentrant {\n        gameId.joinGame(msg.sender);\n        LibCoinVending.fund(bytes32(gameId));\n        emit PlayerJoined(gameId, msg.sender);\n    }\n\n    /**\n     * @dev Starts a game with the provided game ID early. `gameId` is the ID of the game.\n     * @param gameId The ID of the game.\n     * @notice This function:\n     *         - Calls the `enforceGameExists` function.\n     *         - Calls the `startGameEarly` function.\n     *         - Emits a _GameStarted_ event.\n     */\n    function startGame(uint256 gameId) public {\n        gameId.enforceGameExists();\n        gameId.startGameEarly();\n        emit GameStarted(gameId);\n    }\n\n    function onERC1155Received(\n        address operator,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public view override returns (bytes4) {\n        LibRankify.enforceIsInitialized();\n        if (operator == address(this)) {\n            return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n        }\n        return bytes4(\"\");\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        LibRankify.enforceIsInitialized();\n        if (operator == address(this)) {\n            return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n        }\n        return bytes4(\"\");\n    }\n\n    function onERC721Received(\n        address operator,\n        address,\n        uint256,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        LibRankify.enforceIsInitialized();\n        if (operator == address(this)) {\n            return IERC721Receiver.onERC721Received.selector;\n        }\n        return bytes4(\"\");\n    }\n\n    /**\n     * @dev Returns the current state of the contract\n     * @return LibRankify.InstanceState The current state of the contract\n     */\n    function getContractState() public pure returns (LibRankify.InstanceState memory) {\n        LibRankify.InstanceState memory state = LibRankify.instanceState();\n        return state;\n    }\n\n    /**\n     * @dev Returns the current turn of the game with the specified ID\n     * @param gameId The ID of the game\n     * @return uint256 The current turn of the game\n     */\n    function getTurn(uint256 gameId) public view returns (uint256) {\n        return gameId.getTurn();\n    }\n\n    /**\n     * @dev Returns the game master of the game with the specified ID\n     * @param gameId The ID of the game\n     * @return address The game master of the game\n     */\n    function getGM(uint256 gameId) public view returns (address) {\n        return gameId.getGM();\n    }\n\n    /**\n     * @dev Returns the scores of the game with the specified ID\n     * @param gameId The ID of the game\n     * @return address[] The players in the game\n     * @return uint256[] The scores of the players\n     */\n    function getScores(uint256 gameId) public view returns (address[] memory, uint256[] memory) {\n        return gameId.getScores();\n    }\n\n    /**\n     * @dev Returns whether the game with the specified ID is in overtime\n     * @param gameId The ID of the game\n     * @return bool Whether the game is in overtime\n     */\n    function isOvertime(uint256 gameId) public view returns (bool) {\n        return gameId.isOvertime();\n    }\n\n    /**\n     * @dev Returns whether the game with the specified ID is over\n     * @param gameId The ID of the game\n     * @return bool Whether the game is over\n     */\n    function isGameOver(uint256 gameId) public view returns (bool) {\n        return gameId.isGameOver();\n    }\n\n    /**\n     * @dev Returns the game ID of the game that the specified player is in\n     * @param player The address of the player\n     * @return uint256 The ID of the game\n     */\n    function getPlayersGame(address player) public view returns (uint256) {\n        return LibTBG.getPlayersGame(player);\n    }\n\n    /**\n     * @dev Returns whether the game with the specified ID is in the last turn\n     * @param gameId The ID of the game\n     * @return bool Whether the game is in the last turn\n     */\n    function isLastTurn(uint256 gameId) public view returns (bool) {\n        return gameId.isLastTurn();\n    }\n\n    /**\n     * @dev Returns whether registration is open for the game with the specified ID\n     * @param gameId The ID of the game\n     * @return bool Whether registration is open\n     */\n    function isRegistrationOpen(uint256 gameId) public view returns (bool) {\n        return gameId.isRegistrationOpen();\n    }\n\n    /**\n     * @dev Returns the creator of the game with the specified ID\n     * @param gameId The ID of the game\n     * @return address The creator of the game\n     */\n    function gameCreator(uint256 gameId) public view returns (address) {\n        return gameId.getGameState().createdBy;\n    }\n\n    /**\n     * @dev Returns the rank of the game with the specified ID\n     * @param gameId The ID of the game\n     * @return uint256 The rank of the game\n     */\n    function getGameRank(uint256 gameId) public view returns (uint256) {\n        return gameId.getGameState().rank;\n    }\n\n    /**\n     * @dev Estimates the price of a game with the specified minimum game time\n     * @param minGameTime The minimum game time\n     * @return uint256 The estimated price of the game\n     */\n    function estimateGamePrice(uint128 minGameTime) public pure returns (uint256) {\n        LibRankify.InstanceState memory state = LibRankify.instanceState();\n        return LibRankify.getGamePrice(minGameTime, state.commonParams);\n    }\n\n    /**\n     * @dev Returns the players in the game with the specified ID\n     * @param gameId The ID of the game\n     * @return address[] The players in the game\n     */\n    function getPlayers(uint256 gameId) public view returns (address[] memory) {\n        return gameId.getPlayers();\n    }\n\n    /**\n     * @dev Returns whether the game with the specified ID can be started early\n     * @param gameId The ID of the game\n     * @return bool Whether the game can be started early\n     */\n    function canStartGame(uint256 gameId) public view returns (bool) {\n        return gameId.canStartEarly();\n    }\n\n    /**\n     * @dev Returns whether the turn can be ended early for the game with the specified ID\n     * @param gameId The ID of the game\n     * @return bool Whether the turn can be ended early\n     */\n    function canEndTurn(uint256 gameId) public view returns (bool) {\n        return gameId.canEndTurnEarly();\n    }\n\n    /**\n     * @dev Returns whether the player has completed their turn in the game with the specified ID\n     * @param gameId The ID of the game\n     * @param player The address of the player\n     * @return bool Whether the player has completed their turn\n     */\n    function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool) {\n        return gameId.isPlayerTurnComplete(player);\n    }\n\n    /**\n     * @dev Returns the voted array for the game with the specified ID\n     * @param gameId The ID of the game\n     * @return bool[] The voted array\n     */\n    function getPlayerVotedArray(uint256 gameId) public view returns (bool[] memory) {\n        LibRankify.GameState storage game = gameId.getGameState();\n        address[] memory players = gameId.getPlayers();\n        bool[] memory playerVoted = new bool[](players.length);\n        for (uint256 i = 0; i < players.length; ++i) {\n            playerVoted[i] = game.playerVoted[players[i]];\n        }\n        return playerVoted;\n    }\n\n    /**\n     * @dev Returns the players who have moved in the game with the specified ID\n     * @param gameId The ID of the game\n     * @return bool[] The players who have moved\n     * @return uint256 The number of players who have moved\n     */\n    function getPlayersMoved(uint256 gameId) public view returns (bool[] memory, uint256) {\n        LibTBG.State storage game = gameId._getState();\n        address[] memory players = gameId.getPlayers();\n        bool[] memory playersMoved = new bool[](players.length);\n        for (uint256 i = 0; i < players.length; ++i) {\n            playersMoved[i] = game.madeMove[players[i]];\n        }\n        return (playersMoved, game.numPlayersMadeMove);\n    }\n\n    function isActive(uint256 gameId, address player) public view returns (bool) {\n        return gameId.isActive(player);\n    }\n}\n"
    },
    "src/facets/RankifyInstanceRequirementsFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {LibTBG} from \"../libraries/LibTurnBasedGame.sol\";\nimport {LibCoinVending} from \"../libraries/LibCoinVending.sol\";\nimport {LibRankify} from \"../libraries/LibRankify.sol\";\n\n/**\n * @title RankifyInstanceRequirementsFacet\n * @notice Facet handling game requirements and conditions for Rankify instances\n * @dev Implements functionality for setting and checking join requirements for games,\n *      utilizing the LibCoinVending library for configuration management\n * @author Peeramid Labs, 2024\n */\ncontract RankifyInstanceRequirementsFacet {\n    using LibTBG for uint256;\n    using LibRankify for uint256;\n    using LibTBG for LibTBG.State;\n    event RequirementsConfigured(uint256 indexed gameId, LibCoinVending.ConfigPosition config);\n\n    /**\n     * @dev Sets the join requirements for a specific game.\n     * Only the game creator can call this function.\n     * The game must be in the pre-registration stage.\n     *\n     * @param gameId The ID of the game.\n     * @param config The configuration position for the join requirements.\n     */\n    function setJoinRequirements(uint256 gameId, LibCoinVending.ConfigPosition memory config) public {\n        gameId.enforceIsGameCreator(msg.sender);\n        gameId.enforceIsPreRegistrationStage();\n        LibCoinVending.configure(bytes32(gameId), config);\n        emit RequirementsConfigured(gameId, config);\n    }\n\n    /**\n     * @dev Retrieves the join requirements for a specific game.\n     * @param gameId The ID of the game.\n     * @return The join requirements as a `LibCoinVending.ConditionReturn` struct.\n     */\n    function getJoinRequirements(uint256 gameId) public view returns (LibCoinVending.ConditionReturn memory) {\n        return LibCoinVending.getPosition(bytes32(gameId));\n    }\n\n    /**\n     * @dev Retrieves the join requirements for a specific token in a game.\n     * @param gameId The ID of the game.\n     * @param contractAddress The address of the contract.\n     * @param contractId The ID of the contract.\n     * @param contractType The type of the contract.\n     * @return The join requirements for the specified token.\n     */\n    function getJoinRequirementsByToken(\n        uint256 gameId,\n        address contractAddress,\n        uint256 contractId,\n        LibCoinVending.ContractTypes contractType\n    ) public view returns (LibCoinVending.ContractCondition memory) {\n        return LibCoinVending.getPositionByContract(bytes32(gameId), contractAddress, contractId, contractType);\n    }\n}\n"
    },
    "src/initializers/RankifyInstanceInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../vendor/diamond/libraries/LibDiamond.sol\";\nimport {IDiamondLoupe} from \"../vendor/diamond/interfaces/IDiamondLoupe.sol\";\nimport {IDiamondCut} from \"../vendor/diamond/interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"../vendor/diamond/interfaces/IERC173.sol\";\nimport {IERC165} from \"../vendor/diamond/interfaces/IERC165.sol\";\nimport {LibEIP712WithStorage} from \"../libraries/LibEIP712Storage.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IRankifyInstance} from \"../interfaces/IRankifyInstance.sol\";\nimport {IRankToken} from \"../interfaces/IRankToken.sol\";\nimport {LibTBG} from \"../libraries/LibTurnBasedGame.sol\";\nimport {LibQuadraticVoting} from \"../libraries/LibQuadraticVoting.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {LibRankify} from \"../libraries/LibRankify.sol\";\n// import {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init function if you need to.\n\ncontract RankifyInstanceInit is Initializable {\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    struct contractInitializer {\n        address rewardToken;\n        uint256 principalCost;\n        uint96 principalTimeConstant;\n        address paymentToken;\n        address beneficiary;\n    }\n\n    // You can add parameters to this function in order to pass in\n    // data to set your own state variables\n    function init(string memory name, string memory version, contractInitializer memory initData) external initializer {\n        // adding ERC165 data\n        // LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\n        ss._HASHED_NAME = hashedName;\n        ss._HASHED_VERSION = hashedVersion;\n        ss._CACHED_CHAIN_ID = block.chainid;\n        ss._CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        ss._CACHED_THIS = address(this);\n        ss._TYPE_HASH = typeHash;\n\n        LibRankify.CommonParams storage commons = LibRankify.instanceState().commonParams;\n\n        commons.principalCost = initData.principalCost;\n        commons.principalTimeConstant = initData.principalTimeConstant;\n        commons.gamePaymentToken = initData.paymentToken;\n        commons.rankTokenAddress = initData.rewardToken;\n        commons.beneficiary = initData.beneficiary;\n\n        LibRankify.InstanceState storage _RInstance = LibRankify.instanceState();\n        require(initData.paymentToken != address(0), \"initializer.paymentToken not set\");\n\n        IRankToken rankContract = IRankToken(initData.rewardToken);\n        require(\n            rankContract.supportsInterface(type(IRankToken).interfaceId),\n            \"RankifyInstance->init: rank token address does not support Rank interface\"\n        );\n        _RInstance.contractInitialized = true;\n    }\n}\n"
    },
    "src/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "src/interfaces/IErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IErrors {\n    error invalidConfiguration(string message);\n    error zeroValue();\n}\n"
    },
    "src/interfaces/ILockableERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"@openzeppelin/contracts/interfaces/IERC1155.sol\";\n\n/**\n * @title ILockableERC1155\n * @dev Interface for a lockable ERC1155 token contract.\n */\ninterface ILockableERC1155 is IERC1155 {\n    error insufficient(uint256 id, uint256 balance, uint256 required);\n\n    event TokensLocked(address indexed account, uint256 indexed id, uint256 value);\n\n    event TokensUnlocked(address indexed account, uint256 indexed id, uint256 value);\n\n    /**\n     * @dev Locks a specified amount of tokens for a given account and token ID. `account` is the address of the account to lock the tokens for. `id` is the ID of the token to lock. `amount` is the amount of tokens to lock.\n     *\n     * emits a _TokensLocked_ event.\n     */\n    function lock(address account, uint256 id, uint256 amount) external;\n\n    /**\n     * @dev Unlocks a specified amount of tokens for a given account and token ID. `account` is the address of the account to unlock the tokens for. `id` is the ID of the token to unlock. `amount` is the amount of tokens to unlock.\n     *\n     * emits a _TokensUnlocked_ event.\n     */\n    function unlock(address account, uint256 id, uint256 amount) external;\n\n    /**\n     * @dev Returns the unlocked balance of tokens for a given account and token ID. `account` is the address of the account to check the unlocked balance for. `id` is the ID of the token to check the unlocked balance for.\n     *\n     * Returns:\n     *\n     * - The unlocked balance of tokens.\n     */\n    function unlockedBalanceOf(address account, uint256 id) external view returns (uint256);\n\n    function burn(address account, uint256 id, uint256 value) external;\n}\n"
    },
    "src/interfaces/IRankifyInstance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {LibTBG} from \"../libraries/LibTurnBasedGame.sol\";\nimport {LibQuadraticVoting} from \"../libraries/LibQuadraticVoting.sol\";\n\ninterface IRankifyInstance {\n    error NoDivisionReminderAllowed(uint256 a, uint256 b);\n    error invalidTurnCount(uint256 nTurns);\n    error RankNotSpecified();\n\n    event RegistrationOpen(uint256 indexed gameId);\n    event PlayerJoined(uint256 indexed gameId, address participant);\n    event GameStarted(uint256 indexed gameId);\n    event gameCreated(uint256 gameId, address indexed gm, address indexed creator, uint256 indexed rank);\n    event GameClosed(uint256 indexed gameId);\n    event PlayerLeft(uint256 indexed gameId, address indexed player);\n\n    struct NewGameParamsInput {\n        uint256 gameRank;\n        uint256 minPlayerCnt;\n        uint256 maxPlayerCnt;\n        uint96 nTurns;\n        uint256 voteCredits;\n        address gameMaster;\n        uint128 minGameTime;\n        uint128 timePerTurn;\n        uint128 timeToJoin;\n    }\n}\n"
    },
    "src/interfaces/IRankToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ILockableERC1155} from \"./ILockableERC1155.sol\";\n\ninterface IRankToken is ILockableERC1155 {\n    event RankingInstanceUpdated(address indexed newRankingInstance);\n\n    // event LevelUp(address indexed account, uint256 id);\n\n    /**\n     * @dev Mints a specified amount of tokens to an account. `to` is the address of the account to mint the tokens to. `amount` is the amount of tokens to mint. `poolId` is the ID of the pool. `data` is the additional data.\n     */\n    function mint(address to, uint256 amount, uint256 poolId, bytes memory data) external;\n\n    /**\n     * @dev Mints specified amounts of tokens to an account. `to` is the address of the account to mint the tokens to. `ids` is the array of IDs of the tokens to mint. `amounts` is the array of amounts of tokens to mint. `data` is the additional data.\n     */\n    function batchMint(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\n\n    // /**\n    //  * @dev Updates the ranking instance. `newRankingInstance` is the address of the new ranking instance.\n    //  *\n    //  * emits a _RankingInstanceUpdated_ event.\n    //  */\n    // function updateRankingInstance(address newRankingInstance) external;\n\n    /**\n     * @dev Gets the ranking instance which can emit new rank updates and mint rank tokens.\n     *\n     * Returns:\n     *\n     * - The address of the ranking instance.\n     */\n    // function getRankingInstance() external view returns (address);\n\n    // /**\n    //  * @dev Finds the new rank of an account. `account` is the address of the account. `oldRank` is the old rank of the account.\n    //  * It checks the balance of the account and returns the new rank that can be upgraded to.\n    //  *\n    //  * Returns:\n    //  *\n    //  * - The new rank of the account.\n    //  */\n    // function findNewRank(address account, uint256 oldRank) external view returns (uint256);\n\n    // /**\n    //  * @dev Gets the rank of an account. `account` is the address of the account.\n    //  *\n    //  * Returns:\n    //  *\n    //  * - The rank of the account.\n    //  */\n    // function getAccountRank(address account) external view returns (uint256);\n}\n"
    },
    "src/libraries/LibArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"hardhat/console.sol\";\n\nlibrary LibArray {\n    /**\n     * @dev Sorts the elements of the array in ascending order using the quicksort algorithm.\n     *\n     * Requirements:\n     *\n     * - The array to be sorted must not be empty.\n     * - The starting and ending indices must be within the bounds of the array.\n     *\n     * Modifies:\n     *\n     * - The array is sorted in ascending order.\n     *\n     * Note:\n     *\n     * - This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2).\n     */\n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal view {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] > pivot) ++i;\n            while (pivot > arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                ++i;\n                j--;\n            }\n        }\n        if (left < j) quickSort(arr, left, j);\n        if (i < right) quickSort(arr, i, right);\n    }\n}\n"
    },
    "src/libraries/LibCoinVending.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Tim Pechersky <@Peersky>\n\npragma solidity ^0.8.20;\n\nimport {MockERC20} from \"../mocks/MockERC20.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\n/**\n * @dev This library is used to simulate the vending machine coin acceptor state machine that:\n *  - Supports large number of positions; Each represents requirements to access different goods of the virtual vending machine.\n *  - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together.\n *  - Allows for each individual asset action promise can be one of following:\n *      - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time.\n *      - Bet: The asset is locked in the acceptor with promise that asset will be awarded to beneficiary at release funds time.\n *      - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time.\n *      - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time.\n *  - Maintains each position balance, hence allowing multiple participants to line up for the same position.\n *  - Allows three actions:\n *      - Fund position with assets\n *      - Refund assets to user\n *      - Consume assets and provide goods to user\n *      - Consuming asset might take a form of\n *      - Transferring assets to payee\n *      - Burning assets\n *      - Awarding beneficiary with assets\n *      - Returning locked assets back to sender\n *\n * This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries\n * This library DOES NOT store the addresses of senders, nor beneficiaries, nor payees.\n * This is to be stored within implementation contract.\n *\n *\n *  !!!!! IMPORTANT !!!!!\n * This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards.\n * Reentrancy guards MUST be implemented in an implementing contract.\n *\n *  Usage:\n *\n *  0. Configure position via configure(...)\n *  1. fund position with assets via fund(...)\n *  2. release or refund assets via release(...) or refund(...)\n *  3. repeat steps 1 and 2 as needed.\n *  Position can be reconfigured at any time when it's effective balance is zero: `timesFunded - timesRefund - timesReleased = 0`\n *\n *\n * Test state:\n * This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details.\n *\n * ERC721 token is checked only for \"HAVE\" condition since putting requirements on non fungible token id yet to be resolved.\n * (see ERC721 section in the code below)\n *\n * This library has not been yet audited\n *\n */\nlibrary LibCoinVending {\n    struct Condition {\n        mapping(ContractTypes => mapping(address => mapping(uint256 => ContractCondition))) contracts;\n        NumericCondition ethValues;\n        uint256 timesRefunded;\n        uint256 timesReleased;\n        uint256 timesFunded;\n        ContractTypes[] contractTypes;\n        address[] contractAddresses;\n        uint256[] contractIds;\n        bool _isConfigured;\n    }\n    enum RequirementTypes {\n        HAVE,\n        LOCK,\n        BURN,\n        BET,\n        PAY\n    }\n\n    struct TransactionProperties {\n        bytes data;\n        uint256 amount;\n    }\n    struct ContractCondition {\n        TransactionProperties have;\n        TransactionProperties lock;\n        TransactionProperties burn;\n        TransactionProperties pay;\n        TransactionProperties bet;\n    }\n\n    struct NumericCondition {\n        uint256 have;\n        uint256 lock;\n        uint256 burn;\n        uint256 pay;\n        uint256 bet;\n    }\n\n    enum TransferTypes {\n        FUND,\n        REFUND,\n        RELEASE\n    }\n\n    struct ConditionReturn {\n        NumericCondition ethValues;\n        uint256 timesRefunded;\n        uint256 timesReleased;\n        uint256 timesFunded;\n        address[] contractAddresses;\n        uint256[] contractIds;\n        ContractTypes[] contractTypes;\n        bool _isConfigured;\n    }\n\n    struct configSmartRequirement {\n        address contractAddress;\n        uint256 contractId;\n        ContractTypes contractType;\n        ContractCondition contractRequirement;\n    }\n\n    struct ConfigPosition {\n        NumericCondition ethValues;\n        configSmartRequirement[] contracts;\n    }\n\n    struct LibCoinVendingStorage {\n        mapping(bytes32 => Condition) positions;\n        address beneficiary;\n    }\n\n    enum ContractTypes {\n        ERC20,\n        ERC1155,\n        ERC721\n    }\n\n    bytes32 constant COIN_VENDING_STORAGE_POSITION = keccak256(\"coin.vending.storage.position\");\n\n    function coinVendingPosition(bytes32 position) internal view returns (Condition storage) {\n        return coinVendingStorage().positions[keccak256(abi.encode(position))];\n    }\n\n    function coinVendingStorage() internal pure returns (LibCoinVendingStorage storage es) {\n        bytes32 position = COIN_VENDING_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from one address to another, or burns them if the destination address is zero.\n     *\n     * Requirements:\n     *\n     * - The `value` must be non-zero.\n     * - The `from` address must have a sufficient token balance.\n     * - If the `from` address is not this contract, it must have approved this contract to transfer tokens on its behalf.\n     *\n     * Modifies:\n     *\n     * - The token balances of the `from` and `to` addresses, or the total supply of tokens if `to` is the zero address.\n     */\n    function transferFromAny(address erc20Addr, address from, address to, uint256 value) private {\n        MockERC20 token = MockERC20(erc20Addr);\n        if (value != 0) {\n            if (from == address(this)) {\n                if (to != address(0)) {\n                    token.transfer(to, value);\n                } else {\n                    token.burn(value);\n                }\n            } else {\n                if (to != address(0)) {\n                    token.transferFrom(from, to, value);\n                } else {\n                    token.transferFrom(from, address(this), value);\n                    token.burn(value);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Fulfills the ERC20 token transfer according to the specified rules.\n     *\n     * Requirements:\n     *\n     * - The `from` address must have a sufficient token balance.\n     * - If the `from` address is not this contract, it must have approved this contract to transfer tokens on its behalf.\n     *\n     * Modifies:\n     *\n     * - The token balances of the `from` and `to` addresses.\n     */\n    function fulfillERC20(\n        address erc20Addr,\n        ContractCondition storage tokenReq,\n        address from,\n        address payee,\n        address beneficiary,\n        address burnAddress,\n        address lockAddress\n    ) private {\n        transferFromAny(erc20Addr, from, lockAddress, tokenReq.lock.amount);\n        transferFromAny(erc20Addr, from, burnAddress, tokenReq.burn.amount);\n        transferFromAny(erc20Addr, from, payee, tokenReq.pay.amount);\n        transferFromAny(erc20Addr, from, beneficiary, tokenReq.bet.amount);\n        MockERC20 token = MockERC20(erc20Addr);\n        uint256 value = tokenReq.have.amount;\n        if (value != 0 && from != address(this)) {\n            require(token.balanceOf(from) >= value, \"Not enough erc20 tokens\");\n        }\n    }\n\n    /**\n     * @dev Fulfills the ERC721 token transfer according to the specified rules.\n     *\n     * Requirements:\n     *\n     * - The `from` address must own the token.\n     * - If the `from` address is not this contract, it must have approved this contract to transfer the token on its behalf.\n     *\n     * Modifies:\n     *\n     * - The token ownership from the `from` address to the `to` address.\n     *\n     * Notes:\n     *\n     * Due to non fungible nature it's an open question how to implement this method correctly for lock/burn/pay/bet cases.\n     * In this library I assume that requirements are for multiple members, hence it makes no sense to put requirement on particular tokenId for ERC721.\n     * I think best approach would be to split in to two methods:\n     *  1. fulfillERC72Balance: Treats tokens as fungible - requires one to lock/burn/pay/bet ANY token id, but in total should be equal to desired value.\n     *  2. fulfillERC721Ids: Requires one to lock/burn/pay/bet specific token id. (useful when requirements are unique per applicant).\n     * fulfillERC72Balance is easy. fulfillERC721Ids brings up a question of how to select those ID's(since must specify for ERC721 contract on transfer method).\n     *  Two possible solutions:\n     *  1: modify fund() method to accept array of address+id pairs of NFT's and parse trough it. computationally inefficient.\n     *  2: implement onERC721Received such that there is NFT vault in the contract, later fill funding position from that vault. That way applicant could pre-send NFT's to the contract and calling fund later would pull those out from the vault.\n\n     */\n    function fulfillERC72Balance(address erc721addr, ContractCondition storage tokenReq, address from) private view {\n        ERC721 token = ERC721(erc721addr);\n\n        require(\n            tokenReq.lock.amount == 0 &&\n                tokenReq.burn.amount == 0 &&\n                tokenReq.pay.amount == 0 &&\n                tokenReq.bet.amount == 0,\n            \"ERC721 transfers not supported\"\n        );\n        if (tokenReq.have.amount != 0 && from != address(this)) {\n            uint256 balance = token.balanceOf(from);\n            require(balance >= tokenReq.have.amount, \"Not enough ERC721 balance\");\n        }\n    }\n\n    /**\n     * @dev Fulfills the ERC1155 token transfer according to the specified rules.\n     *\n     * Requirements:\n     *\n     * - The `from` address must own the token.\n     * - If the `from` address is not this contract, it must have approved this contract to transfer the token on its behalf.\n     *\n     * Modifies:\n     *\n     * - The token ownership from the `from` address to the `to` address.\n     */\n    function fulfillERC1155(\n        address erc1155addr,\n        uint256 id,\n        ContractCondition storage tokenReq,\n        address from,\n        address payee,\n        address beneficiary,\n        address burnAddress,\n        address lockAddress\n    ) private {\n        ERC1155Burnable token = ERC1155Burnable(erc1155addr);\n        uint256 value = tokenReq.have.amount;\n        if (value != 0) {\n            uint256 balance = token.balanceOf(from, id);\n            require(balance >= value, \"ERC1155 balance is not valid\");\n        }\n        value = tokenReq.pay.amount;\n        if (value != 0) {\n            token.safeTransferFrom(from, payee, id, value, tokenReq.pay.data);\n        }\n        value = tokenReq.bet.amount;\n        if (value != 0) {\n            token.safeTransferFrom(from, beneficiary, id, value, tokenReq.bet.data);\n        }\n        value = tokenReq.burn.amount;\n        if (value != 0) {\n            if (burnAddress == address(0)) {\n                token.burn(from, id, value);\n            } else {\n                token.safeTransferFrom(from, burnAddress, id, value, tokenReq.burn.data);\n            }\n        }\n        value = tokenReq.lock.amount;\n        if (value != 0) {\n            token.safeTransferFrom(from, lockAddress, id, value, tokenReq.lock.data);\n        }\n    }\n\n    /**\n     * @dev Fulfills the conditions of a position.\n     *\n     * Requirements:\n     *\n     * - If `from` is not this contract, the sent value must be greater than or equal to the sum of the locked, paid, bet, and burned values.\n     *\n     * Modifies:\n     *\n     * - Transfers the specified amounts of Ether to the lock, payee, beneficiary, and burn addresses.\n     */\n    function fulfill(\n        Condition storage position,\n        address from,\n        address payee,\n        address beneficiary,\n        address burnAddress,\n        address lockAddress\n    ) private {\n        if (from == address(this)) {\n            if (position.ethValues.lock != 0) {\n                payable(lockAddress).transfer(position.ethValues.lock);\n            }\n            if (position.ethValues.pay != 0) {\n                payable(payee).transfer(position.ethValues.pay);\n            }\n            if (position.ethValues.bet != 0) {\n                payable(beneficiary).transfer(position.ethValues.bet);\n            }\n            if (position.ethValues.burn != 0) {\n                payable(burnAddress).transfer(position.ethValues.burn);\n            }\n        } else {\n            uint256 VLReq = position.ethValues.lock +\n                position.ethValues.pay +\n                position.ethValues.bet +\n                position.ethValues.burn;\n            require(msg.value >= VLReq, \"msg.value too low\");\n        }\n        for (uint256 i = 0; i < position.contractAddresses.length; ++i) {\n            address contractAddress = position.contractAddresses[i];\n            uint256 id = position.contractIds[i];\n            ContractTypes contractType = position.contractTypes[i];\n            ContractCondition storage requirement = position.contracts[contractType][contractAddress][id];\n            if (contractType == ContractTypes.ERC20) {\n                fulfillERC20(contractAddress, requirement, from, payee, beneficiary, burnAddress, lockAddress);\n            } else if (contractType == ContractTypes.ERC721) {\n                fulfillERC72Balance(\n                    contractAddress,\n                    // id,\n                    requirement,\n                    from\n                    // payee,\n                    // beneficiary,\n                    // burnAddress,\n                    // lockAddress\n                );\n            } else if (contractType == ContractTypes.ERC1155) {\n                fulfillERC1155(contractAddress, id, requirement, from, payee, beneficiary, burnAddress, lockAddress);\n            }\n        }\n    }\n\n    /**\n     * @dev Refunds the balance of a condition to the specified address.\n     *\n     * `reqPos` The storage reference to the condition.\n     * `to` The address to refund the balance to.\n     *\n     * Requirements:\n     *\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\n     *\n     * Modifies:\n     *\n     * - Transfers the remaining balance of the condition to the `to` address.\n     * - Increments the `timesRefunded` counter for the condition.\n     */\n    function _refund(Condition storage reqPos, address to) private {\n        require((reqPos.timesRefunded + reqPos.timesReleased) < reqPos.timesFunded, \"Not enough balance to refund\");\n        fulfill(reqPos, address(this), to, to, to, to);\n        reqPos.timesRefunded += 1;\n    }\n\n    /**\n     * @dev Returns all position requirements back to founder. `position` is the identifier of the condition. `to` is the address to refund the balance to.\n     *\n     * Requirements:\n     *\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\n     *\n     * Modifies:\n     *\n     * - Transfers the remaining balance of the condition to the `to` address.\n     * - Increments the `timesRefunded` counter for the condition.\n     */\n    function refund(bytes32 position, address to) internal {\n        Condition storage reqPos = coinVendingPosition(position);\n        _refund(reqPos, to);\n    }\n\n    /**\n     * @dev Returns all position requirements back to multiple founders. `position` is the identifier of the condition. `returnAddresses` is an array of addresses to refund the balance to.\n     *\n     * Requirements:\n     *\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\n     *\n     * Modifies:\n     *\n     * - Transfers the remaining balance of the condition to each address in `returnAddresses`.\n     * - Increments the `timesRefunded` counter for the condition for each address in `returnAddresses`.\n     */\n    function batchRefund(bytes32 position, address[] memory returnAddresses) internal {\n        Condition storage reqPos = coinVendingPosition(position);\n        for (uint256 i = 0; i < returnAddresses.length; ++i) {\n            _refund(reqPos, returnAddresses[i]);\n        }\n    }\n\n    function _release(Condition storage reqPos, address payee, address beneficiary, address returnAddress) private {\n        require((reqPos.timesRefunded + reqPos.timesReleased) < reqPos.timesFunded, \"Not enough balance to release\");\n        fulfill(reqPos, address(this), payee, beneficiary, address(0), returnAddress);\n        reqPos.timesReleased += 1;\n    }\n\n    /**\n     * @dev Releases the funds from a coin vending position to the specified addresses. `position` is the identifier of the condition. `payee`, `beneficiary`, and `returnAddress` are the addresses to release the funds to.\n     *\n     * Requirements:\n     *\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\n     *\n     * Modifies:\n     *\n     * - Transfers the remaining balance of the condition to the `payee`, `beneficiary`, and `returnAddress`.\n     * - Increments the `timesReleased` counter for the condition.\n     */\n    function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal {\n        Condition storage reqPos = coinVendingPosition(position);\n        _release(reqPos, payee, beneficiary, returnAddress);\n    }\n\n    /**\n     * @dev Releases the funds from a coin vending position to multiple return addresses. `position` is the identifier of the condition. `payee`, `beneficiary`, and `returnAddresses` are the addresses to release the funds to.\n     *\n     * Requirements:\n     *\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\n     *\n     * Modifies:\n     *\n     * - Transfers the remaining balance of the condition to the `payee`, `beneficiary`, and each address in `returnAddresses`.\n     * - Increments the `timesReleased` counter for the condition for each address in `returnAddresses`.\n     */\n    function batchRelease(\n        bytes32 position,\n        address payee,\n        address beneficiary,\n        address[] memory returnAddresses\n    ) internal {\n        Condition storage reqPos = coinVendingPosition(position);\n        for (uint256 i = 0; i < returnAddresses.length; ++i) {\n            {\n                _release(reqPos, payee, beneficiary, returnAddresses[i]);\n            }\n        }\n    }\n\n    function _fund(Condition storage reqPos, address founder) private {\n        require(reqPos._isConfigured, \"Position does not exist\");\n        fulfill(reqPos, founder, address(this), address(this), address(this), address(this));\n        reqPos.timesFunded += 1;\n    }\n\n    /**\n     * @dev Funds the position by `msg.sender`. `position` is the identifier of the condition.\n     *\n     * Requirements:\n     *\n     * - The condition must be configured.\n     *\n     * Modifies:\n     *\n     * - Transfers the funds from `msg.sender` to this contract.\n     * - Increments the `timesFunded` counter for the condition.\n     */\n    function fund(bytes32 position) internal {\n        Condition storage reqPos = coinVendingPosition(position);\n        _fund(reqPos, msg.sender);\n    }\n\n    /**\n     * @dev Configures the position. `position` is the identifier of the condition. `configuration` is the new configuration for the condition.\n     *\n     * Requirements:\n     *\n     * - The condition must not have a positive balance.\n     *\n     * Modifies:\n     *\n     * - Sets the configuration of the condition to `configuration`.\n     */\n    function configure(bytes32 position, ConfigPosition memory configuration) internal {\n        Condition storage mustDo = coinVendingPosition(position);\n        require(\n            mustDo.timesFunded == 0 || (mustDo.timesFunded == (mustDo.timesRefunded + mustDo.timesReleased)),\n            \"Cannot mutate position with currently positive balance\"\n        );\n        mustDo.ethValues = configuration.ethValues;\n        delete mustDo.contractAddresses;\n        delete mustDo.contractIds;\n        delete mustDo.contractTypes;\n        for (uint256 i = 0; i < configuration.contracts.length; ++i) {\n            mustDo.contractAddresses.push(configuration.contracts[i].contractAddress);\n            mustDo.contractIds.push(configuration.contracts[i].contractId);\n            mustDo.contractTypes.push(configuration.contracts[i].contractType);\n            mustDo.contracts[configuration.contracts[i].contractType][configuration.contracts[i].contractAddress][\n                configuration.contracts[i].contractId\n            ] = configuration.contracts[i].contractRequirement;\n        }\n        mustDo._isConfigured = true;\n    }\n\n    /**\n     * @dev Returns the condition associated with the given position. `position` is the identifier of the condition.\n     *\n     * Returns:\n     *\n     * - The condition associated with `position`.\n     */\n    function getPosition(bytes32 position) internal view returns (ConditionReturn memory) {\n        Condition storage pos = coinVendingPosition(position);\n        ConditionReturn memory ret;\n        ret.ethValues = pos.ethValues;\n        ret.timesFunded = pos.timesFunded;\n        ret.timesRefunded = pos.timesRefunded;\n        ret.timesReleased = pos.timesReleased;\n        ret._isConfigured = pos._isConfigured;\n        ret.contractAddresses = pos.contractAddresses;\n        ret.contractIds = pos.contractIds;\n        ret.contractTypes = pos.contractTypes;\n        return ret;\n    }\n\n    /**\n     * @dev Returns the contract condition associated with the given position, contract address, contract ID, and contract type. `position` is the identifier of the condition. `contractAddress` is the address of the contract. `contractId` is the ID of the contract. `contractType` is the type of the contract.\n     *\n     * Returns:\n     *\n     * - The contract condition associated with `position`, `contractAddress`, `contractId`, and `contractType`.\n     */\n    function getPositionByContract(\n        bytes32 position,\n        address contractAddress,\n        uint256 contractId,\n        ContractTypes contractType\n    ) internal view returns (ContractCondition memory) {\n        Condition storage pos = coinVendingPosition(position);\n        return pos.contracts[contractType][contractAddress][contractId];\n    }\n}\n"
    },
    "src/libraries/LibEIP712Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IDiamondCut} from \"../vendor/diamond/interfaces/IDiamondCut.sol\";\n\nlibrary LibEIP712WithStorage {\n    bytes32 constant EIP712_STORAGE_POSITION = keccak256(\"EIP.712.STORAGE.POSITION\");\n\n    struct LibEIP712WithStorageStorage {\n        bytes32 _CACHED_DOMAIN_SEPARATOR;\n        uint256 _CACHED_CHAIN_ID;\n        address _CACHED_THIS;\n        bytes32 _HASHED_NAME;\n        bytes32 _HASHED_VERSION;\n        bytes32 _TYPE_HASH;\n    }\n\n    function EIP712WithStorage() internal pure returns (LibEIP712WithStorageStorage storage ds) {\n        bytes32 position = EIP712_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "src/libraries/LibQuadraticVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nerror quadraticVotingError(string parameter, uint256 arg, uint256 arg2);\n\n/**\n * @title LibQuadraticVoting\n * @dev A library for quadratic voting calculations.\n */\nlibrary LibQuadraticVoting {\n    struct qVotingStruct {\n        uint256 voteCredits;\n        uint256 maxQuadraticPoints;\n        uint256 minQuadraticPositions;\n    }\n\n    /**\n     * @dev Pre-computes the values for quadratic voting. `voteCredits` is the total number of vote credits. `minExpectedVoteItems` is the minimum expected number of vote items.\n     *\n     * Returns:\n     *\n     * - A `qVotingStruct` containing the precomputed values.\n     */\n    function precomputeValues(\n        uint256 voteCredits,\n        uint256 minExpectedVoteItems\n    ) internal pure returns (qVotingStruct memory) {\n        qVotingStruct memory q;\n\n        q.maxQuadraticPoints = Math.sqrt(voteCredits);\n\n        // This block finds how many vote positions are needed to distribute all quadratic vote points.\n        uint256 iterator = 0;\n        uint256 accumulator = 0;\n        do {\n            accumulator += (q.maxQuadraticPoints - iterator) ** 2;\n            iterator++;\n        } while (accumulator < voteCredits);\n        // This enforces requirement that all vote credits can indeed be spent (no leftovers)\n        if (accumulator != voteCredits) require(false, \"quadraticVotingError: voteCredits bust be i^2 series\"); //revert quadraticVotingError(\"voteCredits bust be i^2 series\", accumulator, voteCredits);\n        q.minQuadraticPositions = iterator;\n        // In order to spend all vote credits there must be at least minQuadraticPositions+1 (because proposer is also a player and cannot vote for himself)\n        if (minExpectedVoteItems <= q.minQuadraticPositions)\n            require(false, \"quadraticVotingError: Minimum Voting positions above min players\");\n        // revert quadraticVotingError(\n        //     \"Minimum Voting positions above min players\",\n        //     q.minQuadraticPositions,\n        //     minExpectedVoteItems\n        // );\n        q.voteCredits = voteCredits;\n        return q;\n    }\n\n    /**\n     * @dev Computes the scores for each proposal by voter preference index. `q` is the precomputed quadratic voting values. `VotersVotes` is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. `isActive` is an array indicating whether each voter has voted.\n     *\n     * Returns:\n     *\n     * - An array of scores for each proposal.\n     */\n    function computeScoresByVPIndex(\n        qVotingStruct memory q,\n        uint256[][] memory VotersVotes,\n        bool[] memory isActive,\n        uint256 proposalsLength\n    ) internal pure returns (uint256[] memory) {\n        uint256 notVotedGivesEveryone = q.maxQuadraticPoints;\n        uint256[] memory scores = new uint256[](proposalsLength);\n        uint256[] memory creditsUsed = new uint256[](VotersVotes.length);\n\n        for (uint256 proposalIdx = 0; proposalIdx < proposalsLength; proposalIdx++) {\n            //For each proposal\n            scores[proposalIdx] = 0;\n            for (uint256 vi = 0; vi < VotersVotes.length; vi++) {\n                // For each potential voter\n                uint256[] memory voterVotes = VotersVotes[vi];\n                if (!isActive[vi]) {\n                    // Check if voter wasn't voting\n                    scores[proposalIdx] += notVotedGivesEveryone; // Gives benefits to everyone but himself\n                    creditsUsed[vi] = q.voteCredits;\n                } else {\n                    //If voter voted\n                    scores[proposalIdx] += voterVotes[proposalIdx];\n                    creditsUsed[vi] += voterVotes[proposalIdx] ** 2;\n                    require(\n                        creditsUsed[vi] <= q.voteCredits,\n                        quadraticVotingError(\"Quadratic: vote credits overrun\", q.voteCredits, creditsUsed[vi])\n                    );\n                }\n            }\n        }\n        return scores;\n    }\n}\n"
    },
    "src/libraries/LibRankify.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\nimport {LibTBG} from \"../libraries/LibTurnBasedGame.sol\";\nimport {IRankifyInstance} from \"../interfaces/IRankifyInstance.sol\";\nimport {IRankToken} from \"../interfaces/IRankToken.sol\";\nimport \"../tokens/Rankify.sol\";\nimport {LibQuadraticVoting} from \"./LibQuadraticVoting.sol\";\nimport \"hardhat/console.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SignedMath} from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title LibRankify\n * @dev Core library for the Rankify protocol that handles game state management, voting, and player interactions\n * @author Peeramid Labs, 2024\n */\nlibrary LibRankify {\n    using LibTBG for LibTBG.Instance;\n    using LibTBG for uint256;\n    using LibTBG for LibTBG.Settings;\n    using LibTBG for LibTBG.State;\n    using LibQuadraticVoting for LibQuadraticVoting.qVotingStruct;\n\n    /**\n     * @dev Main state structure for a Rankify instance\n     * @param numGames Total number of games created in this instance\n     * @param contractInitialized Whether the contract has been properly initialized\n     * @param commonParams Common parameters shared across all games in this instance\n     */\n    struct InstanceState {\n        uint256 numGames;\n        bool contractInitialized;\n        CommonParams commonParams;\n    }\n\n    /**\n     * @dev Common parameters shared across all games in a Rankify instance\n     * @param principalCost Base cost for creating a game\n     * @param principalTimeConstant Time constant used for game duration calculations\n     * @param gamePaymentToken Address of the token used for game payments\n     * @param rankTokenAddress Address of the rank token contract\n     * @param beneficiary Address that receives a portion of game fees\n     */\n    struct CommonParams {\n        uint256 principalCost;\n        uint96 principalTimeConstant;\n        address gamePaymentToken;\n        address rankTokenAddress;\n        address beneficiary;\n    }\n\n    /**\n     * @dev Structure for storing hidden votes with their proof\n     * @param hash Hash of the vote\n     * @param proof Cryptographic proof associated with the vote\n     */\n    struct VoteHidden {\n        bytes32 hash;\n        bytes proof;\n    }\n\n    /**\n     * @dev Comprehensive state structure for an individual game\n     * @param gamePrice Price paid to create this game\n     * @param rank Required rank level for participation\n     * @param minGameTime Minimum duration the game must run\n     * @param createdBy Address of the game creator\n     * @param numOngoingProposals Number of active proposals\n     * @param numPrevProposals Number of completed proposals\n     * @param numCommitments Number of vote commitments received\n     * @param numVotesThisTurn Vote count in current turn\n     * @param numVotesPrevTurn Vote count from previous turn\n     * @param voting Quadratic voting state for this game\n     */\n    struct GameState {\n        uint256 gamePrice;\n        uint256 rank;\n        uint256 minGameTime;\n        address createdBy;\n        uint256 numOngoingProposals;\n        uint256 numPrevProposals;\n        uint256 numCommitments;\n        uint256 numVotesThisTurn;\n        uint256 numVotesPrevTurn;\n        LibQuadraticVoting.qVotingStruct voting;\n        mapping(uint256 => string) ongoingProposals; //Previous Turn Proposals (These are being voted on)\n        mapping(address => bytes32) proposalCommitmentHashes; //Current turn Proposal submission\n        mapping(address => VoteHidden) votesHidden;\n        mapping(address => bool) playerVoted;\n    }\n\n    /**\n     * @dev Compares two strings for equality. `a` and `b` are the strings to compare.\n     *\n     * Returns:\n     *\n     * - `true` if the strings are equal, `false` otherwise.\n     */\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    /**\n     * @dev Returns the game storage for the given game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - The game storage for `gameId`.\n     */\n    function getGameState(uint256 gameId) internal view returns (GameState storage game) {\n        bytes32 position = LibTBG.getGameDataStorage(gameId);\n        assembly {\n            game.slot := position\n        }\n    }\n\n    /**\n     * @dev Returns the Rankify InstanceSettings storage.\n     *\n     * Returns:\n     *\n     * - The instanceState storage.\n     */\n    function instanceState() internal pure returns (InstanceState storage contractState) {\n        bytes32 position = LibTBG.getDataStorage();\n        assembly {\n            contractState.slot := position\n        }\n    }\n\n    bytes32 internal constant _PROPOSAL_PROOF_TYPEHASH =\n        keccak256(\"signProposalByGM(uint256 gameId,uint256 turn,bytes32 proposalNHash,string encryptedProposal)\");\n    bytes32 internal constant _VOTE_PROOF_TYPEHASH =\n        keccak256(\"signVote(uint256 vote1,uint256 vote2,uint256 vote3,uint256 gameId,uint256 turn,bytes32 salt)\");\n    bytes32 internal constant _VOTE_SUBMIT_PROOF_TYPEHASH =\n        keccak256(\"publicSignVote(uint256 gameId,uint256 turn,bytes32 vote1,bytes32 vote2,bytes32 vote3)\");\n\n    /**\n     * @dev Ensures that the contract is initialized.\n     *\n     * Requirements:\n     *\n     * - The contract must be initialized.\n     */\n    function enforceIsInitialized() internal view {\n        InstanceState storage settings = instanceState();\n        require(settings.contractInitialized, \"onlyInitialized\");\n    }\n\n    /**\n     * @dev Ensures that the game with the given ID exists. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     */\n    function enforceGameExists(uint256 gameId) internal view {\n        enforceIsInitialized();\n        require(gameId.gameExists(), \"game not found\");\n    }\n\n    struct NewGameParams {\n        uint256 gameId;\n        uint256 gameRank;\n        address creator;\n        uint256 minPlayerCnt;\n        uint256 maxPlayerCnt;\n        uint256 voteCredits;\n        address gameMaster;\n        uint96 nTurns;\n        uint128 minGameTime;\n        uint128 timePerTurn;\n        uint128 timeToJoin;\n    }\n\n    function getGamePrice(uint128 minGameTime, CommonParams memory commonParams) internal pure returns (uint256) {\n        return\n            Math.mulDiv(\n                uint256(commonParams.principalCost),\n                uint256(commonParams.principalTimeConstant),\n                uint256(minGameTime)\n            );\n    }\n\n    /**\n     * @dev Creates a new game with the given parameters. `gameId` is the ID of the new game. `gameMaster` is the address of the game master. `gameRank` is the rank of the game. `creator` is the address of the creator of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must not already exist.\n     * - `gameRank` must not be 0.\n     * - If the game price is not 0, the `creator` must have approved this contract to transfer the game price amount of the game payment token on their behalf.\n     *\n     * Modifies:\n     *\n     * - Creates a new game with `gameId`.\n     * - Transfers the game price amount of the game payment token from `creator` to this contract.\n     * - Sets the payments balance of the game to the game price.\n     * - Sets the creator of the game to `creator`.\n     * - Increments the number of games.\n     * - Sets the rank of the game to `gameRank`.\n     * - Mints new rank tokens.\n     */\n    function newGame(NewGameParams memory params) internal {\n        enforceIsInitialized();\n        CommonParams storage commonParams = instanceState().commonParams;\n\n        require(\n            commonParams.principalTimeConstant % params.nTurns == 0,\n            IRankifyInstance.NoDivisionReminderAllowed(commonParams.principalTimeConstant, params.nTurns)\n        );\n        require(\n            commonParams.principalTimeConstant % params.nTurns == 0,\n            IRankifyInstance.NoDivisionReminderAllowed(commonParams.principalTimeConstant, params.minGameTime)\n        );\n        require(\n            params.minGameTime % params.nTurns == 0,\n            IRankifyInstance.NoDivisionReminderAllowed(params.nTurns, params.minGameTime)\n        );\n        require(params.minGameTime > 0, \"LibRankify::newGame->Min game time zero\");\n        require(params.nTurns > 2, IRankifyInstance.invalidTurnCount(params.nTurns));\n\n        LibTBG.Settings memory newSettings = LibTBG.Settings({\n            timePerTurn: params.timePerTurn,\n            maxPlayerCnt: params.maxPlayerCnt,\n            minPlayerCnt: params.minPlayerCnt,\n            timeToJoin: params.timeToJoin,\n            maxTurns: params.nTurns,\n            voteCredits: params.voteCredits,\n            gameMaster: params.gameMaster,\n            implementationStoragePointer: bytes32(0)\n        });\n\n        InstanceState storage state = instanceState();\n\n        params.gameId.createGame(newSettings); // This will enforce game does not exist yet\n        GameState storage game = getGameState(params.gameId);\n        game.voting = LibQuadraticVoting.precomputeValues(params.voteCredits, params.maxPlayerCnt);\n        require(\n            SignedMath.abs(int256(uint256(params.minGameTime)) - int256(uint256(commonParams.principalTimeConstant))) <\n                uint256(commonParams.principalTimeConstant) * 16,\n            \"Min game time out of bounds\"\n        );\n        uint256 principalGamePrice = getGamePrice(params.minGameTime, commonParams);\n        uint256 burnAmount = Math.mulDiv(principalGamePrice, 9, 10);\n        uint256 daoAmount = principalGamePrice - burnAmount;\n        address beneficiary = commonParams.beneficiary;\n\n        Rankify(commonParams.gamePaymentToken).burnFrom(params.creator, burnAmount);\n        Rankify(commonParams.gamePaymentToken).transferFrom(params.creator, beneficiary, daoAmount);\n\n        require(params.gameRank != 0, IRankifyInstance.RankNotSpecified());\n\n        game.createdBy = params.creator;\n        state.numGames += 1;\n        game.rank = params.gameRank;\n        game.minGameTime = params.minGameTime;\n\n        IRankToken rankTokenContract = IRankToken(state.commonParams.rankTokenAddress);\n        rankTokenContract.mint(address(this), 1, params.gameRank + 1, \"\");\n    }\n\n    /**\n     * @dev Ensures that the candidate is the creator of the game with the given ID. `gameId` is the ID of the game. `candidate` is the address of the candidate.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - `candidate` must be the creator of the game.\n     */\n    function enforceIsGameCreator(uint256 gameId, address candidate) internal view {\n        enforceGameExists(gameId);\n        GameState storage game = getGameState(gameId);\n        require(game.createdBy == candidate, \"Only game creator\");\n    }\n\n    /**\n     * @dev Ensures that the candidate is the game master of the game with the given ID. `gameId` is the ID of the game. `candidate` is the address of the candidate.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - `candidate` must be the game master of the game.\n     */\n    function enforceIsGM(uint256 gameId, address candidate) internal view {\n        enforceGameExists(gameId);\n        require(gameId.getGM() == candidate, \"Only game master\");\n    }\n\n    /**\n     * @dev Locks the rank token of the player. `player` is the address of the player. `gameRank` is the rank of the game. `rankTokenAddress` is the address of the rank token contract.\n     *\n     * Requirements:\n     *\n     * - `RankTokenAddress` must support `IRankToken` interface\n     *\n     * Modifies:\n     *\n     * - Locks `gameRank` rank of `player` in the rank token contract.\n     */\n    function _fulfillRankRq(address player, uint256 gameRank, address rankTokenAddress) private {\n        IRankToken rankToken = IRankToken(rankTokenAddress);\n        rankToken.lock(player, gameRank, 1);\n    }\n\n    /**\n     * @dev Allows a player to join a game. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - If the join game price is not 0, the `player` must have approved this contract to transfer the join game price amount of the game payment token on their behalf.\n     *\n     * Modifies:\n     *\n     * - Transfers the join game price amount of the game payment token from `player` to this contract.\n     * - Increases the payments balance of the game by the join game price.\n     * - Adds `player` to the game.\n     */\n    function joinGame(uint256 gameId, address player) internal {\n        enforceGameExists(gameId);\n        fulfillRankRq(gameId, player);\n        gameId.addPlayer(player);\n    }\n\n    /**\n     * @dev Closes the game with the given ID and transfers the game's balance to the beneficiary. `gameId` is the ID of the game. `beneficiary` is the address to transfer the game's balance to. `playersGameEndedCallback` is a callback function to call for each player when the game ends.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - Emits rank rewards for the game.\n     * - Removes and unlocks each player from the game.\n     * - Calls `playersGameEndedCallback` for each player.\n     * - Transfers the game's balance to `beneficiary`.\n     *\n     * Returns:\n     *\n     * - The final scores of the game.\n     */\n    function closeGame(\n        uint256 gameId,\n        function(uint256, address) playersGameEndedCallback\n    ) internal returns (uint256[] memory) {\n        enforceGameExists(gameId);\n\n        // Get game state and check minimum time\n        GameState storage game = getGameState(gameId);\n        LibTBG.State storage tbgState = gameId._getState();\n        require(\n            block.timestamp - tbgState.startedAt >= game.minGameTime,\n            \"Game duration less than minimum required time\"\n        );\n\n        (, uint256[] memory finalScores) = gameId.getScores();\n        address[] memory players = gameId.getPlayers();\n        for (uint256 i = 0; i < players.length; ++i) {\n            removeAndUnlockPlayer(gameId, players[i]);\n            playersGameEndedCallback(gameId, players[i]);\n        }\n        emitRankRewards(gameId, gameId.getLeaderBoard());\n        return finalScores;\n    }\n\n    /**\n     * @dev Allows a player to quit a game. `gameId` is the ID of the game. `player` is the address of the player. `slash` is a boolean indicating whether to slash the player's payment refund. `onPlayerLeftCallback` is a callback function to call when the player leaves.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - If the join game price is not 0, transfers a refund to `player` and decreases the game's payments balance by the refund amount.\n     * - Removes and unlocks `player` from the game.\n     * - Calls `onPlayerLeftCallback` for `player`.\n     */\n    function quitGame(uint256 gameId, address player, function(uint256, address) onPlayerLeftCallback) internal {\n        removeAndUnlockPlayer(gameId, player); // this will throw if game has started or doesn't exist\n        onPlayerLeftCallback(gameId, player);\n    }\n\n    /**\n     * @dev Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. `gameId` is the ID of the game. `onPlayerLeftCallback` is a callback function to call for each player when they leave. `beneficiary` is the address to transfer the remaining balance to.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - Calls `quitGame` for each player in the game.\n     * - Transfers half of the game's payment to the game creator.\n     * - Decreases the game's payments balance by the refund amount.\n     * - Transfers the remaining balance of the game to `beneficiary`.\n     * - Deletes the game.\n     */ function cancelGame(uint256 gameId, function(uint256, address) onPlayerLeftCallback) internal {\n        // Cancel the game for each player\n        address[] memory players = gameId.getPlayers();\n        for (uint256 i = 0; i < players.length; ++i) {\n            quitGame(gameId, players[i], onPlayerLeftCallback); //this will throw if game has started or doesn't exist\n        }\n\n        // Delete the game\n        gameId.deleteGame();\n    }\n\n    /**\n     * @dev Fulfills the rank requirement for a player to join a game. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Modifies:\n     *\n     * - Locks the rank token(s) of `player` in the rank token contract.\n     */\n    function fulfillRankRq(uint256 gameId, address player) internal {\n        InstanceState storage instance = instanceState();\n        GameState storage game = getGameState(gameId);\n        if (game.rank > 1) {\n            _fulfillRankRq(player, game.rank, instance.commonParams.rankTokenAddress);\n        }\n    }\n\n    /**\n     * @dev Emits rank rewards to the top three addresses in the leaderboard. `gameId` is the ID of the game. `leaderboard` is an array of addresses representing the leaderboard sorted in descending order. `rankTokenAddress` is the address of the rank token contract.\n     *\n     * Modifies:\n     *\n     * - Transfers rank tokens from this contract to the top three addresses in the leaderboard.\n     */\n    function emitRankReward(uint256 gameId, address[] memory leaderboard, address rankTokenAddress) private {\n        GameState storage game = getGameState(gameId);\n        IRankToken rankTokenContract = IRankToken(rankTokenAddress);\n        if (game.rank > 1) {\n            rankTokenContract.burn(leaderboard[0], game.rank, 1);\n        }\n        rankTokenContract.safeTransferFrom(address(this), leaderboard[0], game.rank + 1, 1, \"\");\n    }\n\n    /**\n     * @dev Emits rank rewards to the top addresses in the leaderboard for each rank in the game. `gameId` is the ID of the game. `leaderboard` is an array of addresses representing the leaderboard.\n     *\n     * Modifies:\n     *\n     * - Calls `emitRankReward` for the main rank and each additional rank in the game.\n     */\n    function emitRankRewards(uint256 gameId, address[] memory leaderboard) internal {\n        InstanceState storage instance = LibRankify.instanceState();\n        emitRankReward(gameId, leaderboard, instance.commonParams.rankTokenAddress);\n    }\n\n    /**\n     * @dev Releases a rank token for a player with a specific game rank. `player` is the address of the player. `gameRank` is the game rank of the player. `rankTokenAddress` is the address of the rank token contract.\n     *\n     * Modifies:\n     *\n     * - Unlocks one rank token of `gameRank` for `player` in the rank token contract.\n     */\n    function _releaseRankToken(address player, uint256 gameRank, address rankTokenAddress) private {\n        IRankToken rankToken = IRankToken(rankTokenAddress);\n        rankToken.unlock(player, gameRank, 1);\n    }\n\n    /**\n     * @dev Removes a player from a game and unlocks their rank tokens. `gameId` is the ID of the game. `player` is the address of the player to be removed.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - Removes `player` from the game.\n     * - If the game rank is greater than 1, unlocks the game rank token for `player` in the rank token contract.\n     */\n    function removeAndUnlockPlayer(uint256 gameId, address player) internal {\n        enforceGameExists(gameId);\n        gameId.removePlayer(player); //This will throw if game is in the process\n        InstanceState storage instance = instanceState();\n        GameState storage game = getGameState(gameId);\n        if (game.rank > 1) {\n            _releaseRankToken(player, game.rank, instance.commonParams.rankTokenAddress);\n        }\n    }\n\n    /**\n     * @dev Tries to make a move for a player in a game. `gameId` is the ID of the game. `player` is the address of the player.\n     * The \"move\" is considered to be a state when player has made all actions he could in the given turn.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns `false`.\n     * - Otherwise, makes a move for `player` and returns `true`.\n     */\n    function tryPlayerMove(uint256 gameId, address player) internal returns (bool) {\n        uint256 turn = gameId.getTurn();\n        GameState storage game = getGameState(gameId);\n        bool expectVote = true;\n        bool expectProposal = true;\n        if (turn == 1) expectVote = false; // Don't expect votes at first turn\n        // else if (gameId.isLastTurn()) expectProposal = false; // For now easiest solution is to keep collecting proposals as that is less complicated boundary case\n        if (game.numPrevProposals < game.voting.minQuadraticPositions) expectVote = false; // If there is not enough proposals then round is skipped votes cannot be filled\n        bool madeMove = true;\n        if (expectVote && !game.playerVoted[player]) madeMove = false;\n        if (expectProposal && game.proposalCommitmentHashes[player] == \"\") madeMove = false;\n        if (madeMove) gameId.playerMove(player);\n        return madeMove;\n    }\n\n    /**\n     * @dev Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. `gameId` is the ID of the game. `votesRevealed` is an array of revealed votes. `proposerIndices` is an array of proposer indices that links proposals to index in getPlayers().\n     *\n     * Returns:\n     *\n     * - An array of updated scores for each player.\n     * - An array of scores calculated for the current round.\n     */\n    function calculateScoresQuadratic(\n        uint256 gameId,\n        uint256[][] memory votesRevealed,\n        uint256[] memory proposerIndices\n    ) internal returns (uint256[] memory, uint256[] memory) {\n        address[] memory players = gameId.getPlayers();\n        uint256[] memory scores = new uint256[](players.length);\n        bool[] memory playerVoted = new bool[](players.length);\n        GameState storage game = getGameState(gameId);\n        // Convert mapping to array to pass it to libQuadratic\n        for (uint256 i = 0; i < players.length; ++i) {\n            playerVoted[i] = gameId._getState().isActive[players[i]];\n        }\n        uint256[] memory roundScores = game.voting.computeScoresByVPIndex(\n            votesRevealed,\n            playerVoted,\n            proposerIndices.length\n        );\n        for (uint256 playerIdx = 0; playerIdx < players.length; playerIdx++) {\n            //for each player\n            if (proposerIndices[playerIdx] < players.length) {\n                //if player proposal exists\n                scores[playerIdx] = gameId.getScore(players[playerIdx]) + roundScores[playerIdx];\n                gameId.setScore(players[playerIdx], scores[playerIdx]);\n            } else {\n                //Player did not propose\n            }\n        }\n        return (scores, roundScores);\n    }\n}\n"
    },
    "src/libraries/LibReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"hardhat/console.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nlibrary LibReentrancyGuard {\n    bytes32 constant TBG_STORAGE_POSITION = keccak256(\"reentrancy.guard.storage.position\");\n\n    struct ReentrancyGuardStruct {\n        bool _entered;\n    }\n\n    function reentrancyGuardStorage() internal pure returns (ReentrancyGuardStruct storage ds) {\n        bytes32 position = TBG_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "src/libraries/LibTurnBasedGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"hardhat/console.sol\";\n// import {EnumerableMap} from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {LibArray} from \"../libraries/LibArray.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IErrors} from \"../interfaces/IErrors.sol\";\n/**\n * @title LibTBG\n * @dev Library for managing turn-based games.\n * It is designed to be used as a base library for games, and provides the following functionality:\n * - setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking\n *\n * Limitations:\n * - It is assumed there is only one game per player\n * - It is assumed there is only on game master per game\n *\n * ***WARNING*** Some limitations:\n * - This library is still under development and its interfaces may change.\n * - getting game data (which has own storage assignment and can be encapsulated from library) however there is no storage slot collision checks in place\n *\n */\nlibrary LibTBG {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct Settings {\n        uint256 timePerTurn;\n        uint256 maxPlayerCnt;\n        uint256 minPlayerCnt;\n        uint256 timeToJoin;\n        uint256 maxTurns;\n        uint256 voteCredits;\n        address gameMaster;\n        bytes32 implementationStoragePointer;\n    }\n\n    struct State {\n        uint256 currentTurn;\n        uint256 turnStartedAt;\n        uint256 registrationOpenAt;\n        uint256 startedAt;\n        bool hasStarted;\n        bool hasEnded;\n        EnumerableSet.AddressSet players;\n        mapping(address => bool) madeMove;\n        mapping(address => bool) isActive;\n        uint256 numPlayersMadeMove;\n        uint256 numActivePlayers;\n        mapping(address => uint256) score;\n        bool isOvertime;\n        address[] leaderboard;\n    }\n\n    struct Instance {\n        Settings settings;\n        State state;\n    }\n\n    struct TBGStorageStruct {\n        mapping(uint256 => Instance) instances;\n        mapping(address => uint256) playerInGame;\n        uint256 totalGamesCreated;\n    }\n\n    bytes32 constant TBG_STORAGE_POSITION = keccak256(\"turn_based_game.storage.position\");\n    bytes32 constant IMPLEMENTATION_STORAGE_POSITION = keccak256(\"implementation.turn_based_game.storage.position\");\n\n    function TBGStorage() internal pure returns (TBGStorageStruct storage es) {\n        bytes32 position = TBG_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n\n    function _getInstance(uint256 gameId) internal view returns (Instance storage) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        return tbg.instances[gameId];\n    }\n\n    function _getState(uint256 gameId) internal view returns (State storage) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        return tbg.instances[gameId].state;\n    }\n\n    /**\n     * @dev Initializes the game with the provided settings. `settings` is the settings for the game.\n     *\n     * Requirements:\n     *\n     * - `settings.timePerTurn` must not be zero.\n     * - `settings.maxPlayerCnt` must not be zero.\n     * - `settings.minPlayerCnt` must be at least 2.\n     * - `settings.maxTurns` must not be zero.\n     * - `settings.timeToJoin` must not be zero.\n     * - `settings.maxPlayerCnt` must not be less than `settings.minPlayerCnt`.\n     * Modifies:\n     *\n     * - Sets the settings of the game to `settings`.\n     */\n\n    function init(uint256 gameId, Settings memory newSettings) private {\n        TBGStorageStruct storage tbg = TBGStorage();\n        Settings storage settings = tbg.instances[gameId].settings;\n        require(newSettings.timePerTurn != 0, IErrors.invalidConfiguration(\"LibTBG::init->settings.timePerTurn\"));\n        require(newSettings.maxPlayerCnt != 0, IErrors.invalidConfiguration(\"LibTBG::init->settings.maxPlayerCnt\"));\n        require(newSettings.minPlayerCnt > 1, IErrors.invalidConfiguration(\"LibTBG::init->settings.minPlayerCnt\"));\n        require(newSettings.maxTurns != 0, IErrors.invalidConfiguration(\"LibTBG::init->settings.maxTurns\"));\n        require(newSettings.timeToJoin != 0, IErrors.invalidConfiguration(\"LibTBG::init->timeToJoin\"));\n        require(\n            settings.minPlayerCnt < newSettings.maxPlayerCnt,\n            IErrors.invalidConfiguration(\"LibTBG::init->maxPlayerCnt\")\n        );\n        require(newSettings.gameMaster != address(0), IErrors.invalidConfiguration(\"LibTBG::init->gameMaster\"));\n        tbg.instances[gameId].settings = newSettings;\n    }\n\n    /**\n     * @dev Creates a new game with the provided game ID and game master. `gameId` is the ID of the game. `gm` is the address of the game master.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must not already exist.\n     * - `gm` must not be the zero address.\n     * - `gameId` must not be zero.\n     * - The game master of the game with `gameId` must be the zero address.\n     *\n     * Modifies:\n     *\n     * - Sets the game master of the game with `gameId` to `gm`.\n     * - Increments the total number of games created.\n     */\n    function createGame(uint256 gameId, Settings memory settings) internal {\n        require(!gameExists(gameId), \"createGame->Already exists\");\n        require(gameId != 0, \"createGame->gameId\");\n        init(gameId, settings);\n        TBGStorageStruct storage tbg = TBGStorage();\n        tbg.totalGamesCreated += 1;\n\n        //totalGamesCreated ensures nonce-like behavior:\n        //even if game would get deleted and re-created with same name, data storage would be different\n        tbg.instances[gameId].settings.implementationStoragePointer = keccak256(\n            abi.encode(gameId, tbg.totalGamesCreated, TBG_STORAGE_POSITION)\n        );\n    }\n\n    /**\n     * @dev Deletes a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - Sets the game master, current turn, hasEnded, hasStarted,\n     *   implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove,\n     *   players, registrationOpenAt, and turnStartedAt of the game with `gameId`\n     *   to their initial values.\n     * - Sets the score and madeMove of each player in the game with `gameId`\n     *   to their initial values.\n     */\n    function deleteGame(uint256 gameId) internal {\n        TBGStorageStruct storage tbg = TBGStorage();\n        address[] memory players = tbg.instances[gameId].state.players.values();\n        for (uint256 i = 0; i < players.length; ++i) {\n            tbg.instances[gameId].state.score[players[i]] = 0;\n            tbg.instances[gameId].state.madeMove[players[i]] = false;\n            tbg.instances[gameId].state.isActive[players[i]] = false;\n        }\n        delete tbg.instances[gameId].state.currentTurn;\n        delete tbg.instances[gameId].state.hasEnded;\n        delete tbg.instances[gameId].state.hasStarted;\n        delete tbg.instances[gameId].state.isOvertime;\n        delete tbg.instances[gameId].state.leaderboard;\n        delete tbg.instances[gameId].state.numPlayersMadeMove;\n        delete tbg.instances[gameId].state.players;\n        delete tbg.instances[gameId].state.registrationOpenAt;\n        delete tbg.instances[gameId].state.turnStartedAt;\n        delete tbg.instances[gameId].state.numActivePlayers;\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID can be joined. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game can be joined.\n     */\n    function canBeJoined(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        if (state.hasStarted || state.registrationOpenAt == 0) return false;\n        return true;\n    }\n\n    /**\n     * @dev Adds a player to a game with the provided game ID. `gameId` is the ID of the game. `participant` is the address of the player.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - `participant` must not already be in a game.\n     * - The number of players in the game with `gameId` must be less than the maximum number of players.\n     * - The game with `gameId` must be joinable.\n     *\n     * Modifies:\n     *\n     * - Adds `participant` to the players of the game with `gameId`.\n     * - Sets the madeMove of `participant` in the game with `gameId` to false.\n     * - Sets the game of `participant` to `gameId`.\n     */\n    function addPlayer(uint256 gameId, address participant) internal {\n        TBGStorageStruct storage tbg = TBGStorage();\n        State storage state = tbg.instances[gameId].state;\n        Settings storage settings = tbg.instances[gameId].settings;\n        require(gameExists(gameId), \"addPlayer->invalid game\");\n\n        require(tbg.playerInGame[participant] == 0, \"addPlayer->Player in game\");\n        require(state.players.length() < settings.maxPlayerCnt, \"addPlayer->party full\");\n\n        require(canBeJoined(gameId), \"addPlayer->cant join now\");\n        state.players.add(participant);\n        state.madeMove[participant] = false;\n        state.isActive[participant] = false;\n        tbg.playerInGame[participant] = gameId;\n    }\n\n    /**\n     * @dev Checks if a player is in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the player is in the game.\n     */\n    function isPlayerInGame(uint256 gameId, address player) internal view returns (bool) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        return tbg.playerInGame[player] == gameId ? true : false;\n    }\n\n    /**\n     * @dev Removes a player from a game with the provided game ID. `gameId` is the ID of the game. `participant` is the address of the player.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - `participant` must be in the game with `gameId`.\n     * - The game with `gameId` must not have started or must have ended.\n     *\n     * Modifies:\n     *\n     * - Sets the game of `participant` to 0.\n     * - Removes `participant` from the players of the game with `gameId`.\n     */\n    function removePlayer(uint256 gameId, address participant) internal {\n        TBGStorageStruct storage tbg = TBGStorage();\n        State storage state = tbg.instances[gameId].state;\n        require(gameExists(gameId), \"game does not exist\");\n        require(tbg.playerInGame[participant] == gameId, \"Not in the game\");\n        require(state.hasStarted == false || state.hasEnded == true, \"Cannot leave once started\");\n        tbg.playerInGame[participant] = 0;\n        state.players.remove(participant);\n    }\n\n    /**\n     * @dev Checks if the current turn in a game with the provided game ID has timed out. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - `gameId` must not be zero.\n     * - The game with `gameId` must have started.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the current turn has timed out.\n     */\n    function isTurnTimedOut(uint256 gameId) internal view returns (bool) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        State storage state = _getState(gameId);\n        assert(gameId != 0);\n        assert(state.hasStarted == true);\n        if (block.timestamp <= tbg.instances[gameId].settings.timePerTurn + state.turnStartedAt) return false;\n        return true;\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID exists. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game exists.\n     */\n    function gameExists(uint256 gameId) internal view returns (bool) {\n        Settings storage settings = getSettings(gameId);\n        if (settings.gameMaster != address(0)) return true;\n        return false;\n    }\n\n    /**\n     * @dev Enforces that a game with the provided game ID has started. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - `gameId` must not be zero.\n     * - The game with `gameId` must have started.\n     */\n    function enforceHasStarted(uint256 gameId) internal view {\n        State storage state = _getState(gameId);\n        assert(gameId != 0);\n        require(state.hasStarted, \"Game has not yet started\");\n    }\n\n    /**\n     * @dev Enforces that a game with the provided game ID has started. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - `gameId` must not be zero.\n     * - The game with `gameId` must have started.\n     *\n     */\n    function canEndTurn(uint256 gameId) internal view returns (bool) {\n        bool turnTimedOut = isTurnTimedOut(gameId);\n        State storage state = _getState(gameId);\n        if (!state.hasStarted || isGameOver(gameId)) return false;\n        if (turnTimedOut) return true;\n        return false;\n    }\n\n    /**\n     * @dev Checks if the current turn in a game with the provided game ID can end early. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the current turn can end early.\n     */\n    function canEndTurnEarly(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        if (!state.hasStarted || isGameOver(gameId)) return false;\n\n        uint256 activePlayersNotMoved = 0;\n        address[] memory players = state.players.values();\n        for (uint256 i = 0; i < players.length; i++) {\n            if (state.isActive[players[i]] && !state.madeMove[players[i]]) {\n                activePlayersNotMoved++;\n            }\n        }\n        return activePlayersNotMoved == 0 || canEndTurn(gameId);\n    }\n\n    /**\n     * @dev Modifier that requires the current turn in a game with the provided game ID to be able to end. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The current turn in the game with `gameId` must be able to end.\n     */\n    modifier onlyInTurnTime(uint256 gameId) {\n        require(isTurnTimedOut(gameId) == false, \"onlyInTurnTime -> turn timeout\");\n        _;\n    }\n\n    modifier onlyWhenTurnCanEnd(uint256 gameId) {\n        require(canEndTurn(gameId) == true, \"onlyWhenTurnCanEnd: Not everyone made a move yet and there still is time\");\n        _;\n    }\n\n    /**\n     * @dev Resets the states of the players in a game. `State` is the state.\n     *\n     * Modifies:\n     *\n     * - Sets the madeMove and score of each player in `game` to their initial values.\n     */\n    function _resetPlayerStates(State storage state) internal {\n        for (uint256 i = 0; i < state.players.length(); ++i) {\n            address player = state.players.at(i);\n            state.madeMove[player] = false;\n            state.score[player] = 0;\n        }\n    }\n\n    /**\n     * @dev Sets the score of a player in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player. `value` is the score.\n     *\n     * Requirements:\n     *\n     * - `player` must be in the game with `gameId`.\n     *\n     * Modifies:\n     *\n     * - Sets the score of `player` in the game with `gameId` to `value`.\n     */\n    function setScore(uint256 gameId, address player, uint256 value) internal {\n        State storage state = _getState(gameId);\n        require(isPlayerInGame(gameId, player), \"player not in a game\");\n        state.score[player] = value;\n    }\n\n    /**\n     * @dev Gets the score of a player in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Returns:\n     *\n     * - The score of `player` in the game with `gameId`.\n     */\n    function getScore(uint256 gameId, address player) internal view returns (uint256) {\n        State storage state = _getState(gameId);\n        return state.score[player];\n    }\n\n    /**\n     * @dev Gets the scores of the players in a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - An array of the addresses of the players in the game with `gameId`.\n     * - An array of the scores of the players in the game with `gameId`.\n     */\n    function getScores(uint256 gameId) internal view returns (address[] memory, uint256[] memory) {\n        address[] memory players = getPlayers(gameId);\n        uint256[] memory scores = new uint256[](players.length);\n        for (uint256 i = 0; i < players.length; ++i) {\n            scores[i] = getScore(gameId, players[i]);\n        }\n        return (players, scores);\n    }\n\n    /**\n     * @dev Opens registration for a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     *\n     * Modifies:\n     *\n     * - Sets the registrationOpenAt of the game with `gameId` to the current block timestamp.\n     */\n    function openRegistration(uint256 gameId) internal {\n        require(gameExists(gameId), \"game not found\");\n        State storage state = _getState(gameId);\n        state.registrationOpenAt = block.timestamp;\n    }\n\n    /**\n     * @dev Checks if registration is open for a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether registration is open for the game.\n     */\n    function isRegistrationOpen(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        TBGStorageStruct storage tbg = TBGStorage();\n        if (state.registrationOpenAt == 0) {\n            return false;\n        } else {\n            return\n                state.registrationOpenAt < block.timestamp + tbg.instances[gameId].settings.timeToJoin ? true : false;\n        }\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID can start. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game can start.\n     */\n    function canStart(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        TBGStorageStruct storage tbg = TBGStorage();\n        if (state.hasStarted) return false;\n        if (state.registrationOpenAt == 0) return false;\n        if (gameId == 0) return false;\n        if (block.timestamp <= state.registrationOpenAt + tbg.instances[gameId].settings.timeToJoin) return false;\n        if (state.players.length() < tbg.instances[gameId].settings.minPlayerCnt) return false;\n        return true;\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID can start early. `gameId` is the ID of the game.\n     * By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game can start early.\n     */\n    function canStartEarly(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        TBGStorageStruct storage tbg = TBGStorage();\n\n        if ((state.players.length() == tbg.instances[gameId].settings.maxPlayerCnt) || canStart(gameId)) return true;\n        return false;\n    }\n\n    /**\n     * @dev Internal function to perform common game start operations\n     * @param gameId The ID of the game to start\n     * @param state The game state storage reference\n     * @param tbg The TBG storage reference\n     */\n    function _performGameStart(uint256 gameId, State storage state, TBGStorageStruct storage tbg) private {\n        require(state.hasStarted == false, \"startGame->already started\");\n        require(state.registrationOpenAt != 0, \"startGame->Game registration was not yet open\");\n        require(gameId != 0, \"startGame->Game not found\");\n        require(state.players.length() >= tbg.instances[gameId].settings.minPlayerCnt, \"startGame->Not enough players\");\n\n        state.hasStarted = true;\n        state.hasEnded = false;\n        state.currentTurn = 1;\n        state.turnStartedAt = block.timestamp;\n        state.startedAt = block.timestamp;\n        _resetPlayerStates(state);\n\n        // Initialize all players as active\n        uint256 playerCount = state.players.length();\n        state.numActivePlayers = playerCount;\n        for (uint256 i = 0; i < playerCount; i++) {\n            address player = state.players.at(i);\n            state.isActive[player] = true;\n        }\n    }\n\n    /**\n     * @dev Starts a game with the provided game ID early. `gameId` is the ID of the game.\n     * By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - The game with `gameId` must not have started.\n     * - The game with `gameId` must have opened registration.\n     * - The number of players in the game with `gameId` must be greater than or equal to the minimum number of players.\n     * - The number of players in the game with `gameId` must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join.\n     *\n     * Modifies:\n     *\n     * - Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with `gameId` to their new values.\n     * - Resets the states of the players in the game with `gameId`.\n     */\n    function startGameEarly(uint256 gameId) internal {\n        State storage state = _getState(gameId);\n        TBGStorageStruct storage tbg = TBGStorage();\n\n        require(\n            (state.players.length() == tbg.instances[gameId].settings.maxPlayerCnt) ||\n                (block.timestamp > state.registrationOpenAt + tbg.instances[gameId].settings.timeToJoin),\n            \"startGame->Not enough players\"\n        );\n\n        _performGameStart(gameId, state, tbg);\n    }\n\n    /**\n     * @dev Starts a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must exist.\n     * - The game with `gameId` must not have started.\n     * - The game with `gameId` must have opened registration.\n     * - The current block timestamp must be greater than the registration open time plus the time to join.\n     *\n     * Modifies:\n     *\n     * - Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with `gameId` to their new values.\n     * - Resets the states of the players in the game with `gameId`.\n     */\n    function startGame(uint256 gameId) internal {\n        State storage state = _getState(gameId);\n        TBGStorageStruct storage tbg = TBGStorage();\n\n        require(\n            block.timestamp > state.registrationOpenAt + tbg.instances[gameId].settings.timeToJoin,\n            \"startGame->Still Can Join\"\n        );\n\n        _performGameStart(gameId, state, tbg);\n    }\n\n    /**\n     * @dev Gets the current turn of a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - The current turn of the game with `gameId`.\n     */\n    function getTurn(uint256 gameId) internal view returns (uint256) {\n        State storage state = _getState(gameId);\n        return state.currentTurn;\n    }\n\n    /**\n     * @dev Gets the game master of a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - The game master of the game with `gameId`.\n     */\n    function getGM(uint256 gameId) internal view returns (address) {\n        Settings storage settings = getSettings(gameId);\n        return settings.gameMaster;\n    }\n\n    /**\n     * @dev Checks if the current turn is the last turn in a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the current turn is the last turn in the game.\n     */\n    function isLastTurn(uint256 gameId) internal view returns (bool) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        State storage state = _getState(gameId);\n        if (state.currentTurn == tbg.instances[gameId].settings.maxTurns) return true;\n        else return false;\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID is over. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game is over.\n     */\n    function isGameOver(uint256 gameId) internal view returns (bool) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        State storage state = _getState(gameId);\n        if ((state.currentTurn > tbg.instances[gameId].settings.maxTurns) && !state.isOvertime) return true;\n        else return false;\n    }\n\n    /**\n     * @dev Enforces that a game with the provided game ID is not over. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must not be over.\n     */\n    function enforceIsNotOver(uint256 gameId) internal view {\n        require(!isGameOver(gameId), \"Game over\");\n    }\n\n    /**\n     * @dev Records a player's move in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must have started.\n     * - The game with `gameId` must not be over.\n     * - `player` must not have made a move in the current turn of the game with `gameId`.\n     * - `player` must be in the game with `gameId`.\n     *\n     * Modifies:\n     *\n     * - Sets the madeMove of `player` in the game with `gameId` to true.\n     * - Increments the numPlayersMadeMove of the game with `gameId`.\n     */\n    function playerMove(uint256 gameId, address player) internal onlyInTurnTime(gameId) {\n        State storage state = _getState(gameId);\n        enforceHasStarted(gameId);\n        enforceIsNotOver(gameId);\n        require(state.madeMove[player] == false, \"already made a move\");\n        TBGStorageStruct storage tbg = TBGStorage();\n        require(gameId == tbg.playerInGame[player], \"is not in the game\");\n        state.madeMove[player] = true;\n        state.numPlayersMadeMove += 1;\n\n        // Set player as active when they make a move\n        state.isActive[player] = true;\n        state.numActivePlayers++;\n    }\n\n    function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        return state.madeMove[player];\n    }\n\n    /**\n     * @dev Enforces that a player is in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\n     *\n     * Requirements:\n     *\n     * - `player` must be in the game with `gameId`.\n     */\n    function enforceIsPlayingGame(uint256 gameId, address player) internal view {\n        TBGStorageStruct storage tbg = TBGStorage();\n        require(gameId == tbg.playerInGame[player], \"is not in the game\");\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID has started. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game has started.\n     */\n    function hasStarted(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        return state.hasStarted;\n    }\n\n    /**\n     * @dev Gets the leaderboard of a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - An array of the addresses of the players in the game with `gameId`, sorted by score.\n     */\n    function getLeaderBoard(uint256 gameId) internal view returns (address[] memory) {\n        State storage state = _getState(gameId);\n        return state.leaderboard;\n    }\n\n    /**\n     * @dev Advances to the next turn in a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - The game with `gameId` must be able to end the current turn early. (all players have moved or the turn has timed out)\n     *\n     * Modifies:\n     *\n     * - Clears the current moves in the game with `gameId`.\n     * - Increments the currentTurn of the game with `gameId`.\n     * - Sets the turnStartedAt of the game with `gameId` to the current block timestamp.\n     * - If the current turn is the last turn or the game with `gameId` is in overtime, checks if the game is a tie and sets the isOvertime of the game with `gameId` to the result.\n     * - Sets the hasEnded of the game with `gameId` to whether the game is over.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the current turn is the last turn.\n     * - A boolean indicating whether the game is a tie.\n     * - A boolean indicating whether the game is over.\n     */\n    function nextTurn(uint256 gameId) internal returns (bool, bool, bool) {\n        require(canEndTurnEarly(gameId), \"nextTurn->CanEndEarly\");\n        State storage state = _getState(gameId);\n        state.currentTurn += 1;\n        state.turnStartedAt = block.timestamp;\n        bool _isLastTurn = isLastTurn(gameId);\n        if (_isLastTurn || state.isOvertime) {\n            bool _isTie = isTie(gameId);\n            state.isOvertime = _isTie;\n        }\n        state.hasEnded = isGameOver(gameId);\n\n        // Update player activity status for next turn\n        uint256 playerCount = state.players.length();\n        state.numActivePlayers = 0;\n\n        for (uint256 i = 0; i < playerCount; i++) {\n            address player = state.players.at(i);\n            // If player didn't make a move this turn, mark them as inactive\n            if (!state.madeMove[player]) {\n                // console.log('LibTBG::nextTurn - ','player inactive!');\n                state.isActive[player] = false;\n            } else {\n                // console.log('LibTBG::nextTurn - ','player active!');\n                state.numActivePlayers++;\n            }\n            state.madeMove[player] = false;\n        }\n        state.numPlayersMadeMove = 0;\n\n        (state.leaderboard, ) = sortByScore(gameId);\n        return (_isLastTurn, state.isOvertime, state.hasEnded);\n    }\n\n    /**\n     * @dev Gets the data storage pointer.\n     *\n     * Returns:\n     *\n     * - The data storage pointer.\n     */\n    function getDataStorage() internal pure returns (bytes32 pointer) {\n        return IMPLEMENTATION_STORAGE_POSITION;\n    }\n\n    /**\n     * @dev Gets the game data storage pointer of a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - The game data storage pointer of the game with `gameId`.\n     */\n    function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer) {\n        Settings storage settings = getSettings(gameId);\n        return settings.implementationStoragePointer;\n    }\n\n    /**\n     * @dev Gets the number of players in a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - The number of players in the game with `gameId`.\n     */\n    function getPlayersNumber(uint256 gameId) internal view returns (uint256) {\n        State storage state = _getState(gameId);\n        return state.players.length();\n    }\n\n    /**\n     * @dev Gets the players in a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - An array of the addresses of the players in the game with `gameId`.\n     */\n    function getPlayers(uint256 gameId) internal view returns (address[] memory) {\n        State storage state = _getState(gameId);\n        return state.players.values();\n    }\n\n    /**\n     * @dev Gets the game settings.\n     *\n     * Returns:\n     *\n     * - The game settings.\n     */\n    function getSettings(uint256 gameId) internal view returns (Settings storage) {\n        TBGStorageStruct storage tbg = TBGStorage();\n        return tbg.instances[gameId].settings;\n    }\n\n    /**\n     * @dev Enforces that a game with the provided game ID is in the pre-registration stage. `gameId` is the ID of the game.\n     *\n     * Requirements:\n     *\n     * - Registration must not be open for the game with `gameId`.\n     * - The game with `gameId` must not have started.\n     */\n    function enforceIsPreRegistrationStage(uint256 gameId) internal view {\n        require(!isRegistrationOpen(gameId), \"Cannot do when registration is open\");\n        require(!hasStarted(gameId), \"Cannot do when game started\");\n    }\n\n    /**\n     * @dev Adds overtime to a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Modifies:\n     *\n     * - Sets the isOvertime of the game with `gameId` to true.\n     */\n    function addOvertime(uint256 gameId) internal {\n        State storage state = _getState(gameId);\n        state.isOvertime = true;\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID is in overtime. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game is in overtime.\n     */\n    function isOvertime(uint256 gameId) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        return state.isOvertime;\n    }\n\n    /**\n     * @dev Resets the overtime of a game with the provided game ID. `gameId` is the ID of the game.\n     *\n     * Modifies:\n     *\n     * - Sets the isOvertime of the game with `gameId` to false.\n     */\n    function resetOvertime(uint256 gameId) internal {\n        State storage state = _getState(gameId);\n        state.isOvertime = false;\n    }\n\n    /**\n     * @dev Checks if a game with the provided game ID is a tie. `gameId` is the ID of the game.\n     * Tie being defined as at least two of the top `numWinners=1` players having the same score.\n     *\n     * Returns:\n     *\n     * - A boolean indicating whether the game is a tie.\n     */\n    function isTie(uint256 gameId) internal view returns (bool) {\n        (, uint256[] memory scores) = getScores(gameId);\n\n        LibArray.quickSort(scores, int256(0), int256(scores.length - 1));\n\n        if (scores[0] == scores[1]) {\n            return (true);\n        }\n\n        return (false);\n    }\n\n    /**\n     * @dev Gets the game ID of the game a player is in. `player` is the address of the player.\n     *\n     * Returns:\n     *\n     * - The game ID of the game `player` is in.\n     */\n    function getPlayersGame(address player) internal view returns (uint256) {\n        TBGStorageStruct storage tbg = TBGStorage();\n\n        return tbg.playerInGame[player];\n    }\n\n    /**\n     * @dev Sorts the players and scores arrays in descending order of scores using the quicksort algorithm. `players` is the array of player addresses. `scores` is the array of scores. `left` is the left index. `right` is the right index.\n     *\n     * Modifies:\n     *\n     * - Sorts the `players` and `scores` arrays in place.\n     */\n    function _quickSort(address[] memory players, uint256[] memory scores, int256 left, int256 right) private view {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = scores[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (scores[uint256(i)] > pivot) ++i;\n            while (pivot > scores[uint256(j)]) j--;\n            if (i <= j) {\n                (scores[uint256(i)], scores[uint256(j)]) = (scores[uint256(j)], scores[uint256(i)]);\n                (players[uint256(i)], players[uint256(j)]) = (players[uint256(j)], players[uint256(i)]);\n                ++i;\n                j--;\n            }\n        }\n        if (left < j) _quickSort(players, scores, left, j);\n        if (i < right) _quickSort(players, scores, i, right);\n    }\n\n    /**\n     * @dev Sorts the players in a game with the provided game ID by score in descending order. `gameId` is the ID of the game.\n     *\n     * Returns:\n     *\n     * - An array of the addresses of the players in the game with `gameId`, sorted by score.\n     * - An array of the scores of the players in the game with `gameId`, sorted in descending order.\n     */\n    function sortByScore(uint256 gameId) internal view returns (address[] memory, uint256[] memory) {\n        (address[] memory players, uint256[] memory scores) = getScores(gameId);\n        _quickSort(players, scores, 0, int256(scores.length - 1));\n        return (players, scores);\n    }\n\n    function isActive(uint256 gameId, address player) internal view returns (bool) {\n        State storage state = _getState(gameId);\n        return state.isActive[player];\n    }\n}\n"
    },
    "src/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\npragma solidity ^0.8.20;\n\n/**\n * @title MockERC20\n * @notice Mock ERC20 token for testing purposes\n * @dev Implements a basic ERC20 token with mint and burn capabilities,\n *      used for testing token interactions in the Rankify ecosystem\n * @author Peeramid Labs, 2024\n */\ncontract MockERC20 is ERC20Burnable, Ownable {\n    constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) Ownable(owner) {\n        require(owner != address(0), \"must specify owner of the contract\");\n        transferOwnership(owner);\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        require(to != address(0), \"MockERC20->mint: Address not specified\");\n        require(amount != 0, \"MockERC20->mint: amount not specified\");\n        _mint(to, amount);\n    }\n}\n"
    },
    "src/mocks/MockVendingMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: Tim Pechersky <@Peersky>\n\npragma solidity ^0.8.20;\n\nimport {LibCoinVending} from \"../libraries/LibCoinVending.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockVendingMachine is ReentrancyGuard {\n    constructor() {}\n\n    address[] public participants;\n\n    function createPosition(bytes32 position, LibCoinVending.ConfigPosition memory configuration) public {\n        LibCoinVending.configure(position, configuration);\n    }\n\n    function fund(bytes32 _positionName) public payable nonReentrant {\n        LibCoinVending.fund(_positionName);\n    }\n\n    function release(bytes32 _positionName, address payee, address beneficiary) public nonReentrant {\n        LibCoinVending.release(_positionName, payee, beneficiary, msg.sender);\n    }\n\n    function refund(bytes32 _positionName, address to) public nonReentrant {\n        LibCoinVending.refund(_positionName, to);\n    }\n\n    function refundBatch(bytes32 _positionName) public nonReentrant {\n        LibCoinVending.batchRefund(_positionName, participants);\n    }\n\n    function releaseAll(bytes32 _positionName, address payee, address beneficiary) public nonReentrant {\n        LibCoinVending.batchRelease(_positionName, payee, beneficiary, participants);\n    }\n\n    function onERC1155Received(\n        address operator,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public view returns (bytes4) {\n        if (operator == address(this)) {\n            return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n        }\n        return bytes4(\"\");\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external view returns (bytes4) {\n        if (operator == address(this)) {\n            return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n        }\n        return bytes4(\"\");\n    }\n\n    function onERC721Received(address operator, address, uint256, bytes calldata) external view returns (bytes4) {\n        if (operator == address(this)) {\n            return IERC721Receiver.onERC721Received.selector;\n        }\n        return bytes4(\"\");\n    }\n}\n"
    },
    "src/modifiers/OnlyOwnerDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"../vendor/diamond/libraries/LibDiamond.sol\";\n\n// import \"./interfaces/IERC173.sol\";\n\ncontract OnlyOwnerDiamond {\n    modifier onlyOwner() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "src/repos/Repo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@peeramid-labs/eds/src/repositories/OwnableRepository.sol\";\n\ncontract Repo is OwnableRepository {\n    constructor(address owner, bytes32 name, string memory contractURI) OwnableRepository(owner, name, contractURI) {}\n}\n"
    },
    "src/tokens/DistributableGovernanceERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity =0.8.28;\n\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n// import {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20MetadataUpgradeable.sol\"\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20VotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/utils/VotesUpgradeable.sol\";\nimport \"@peeramid-labs/eds/src/abstracts/ERC7746Middleware.sol\";\nimport \"@peeramid-labs/eds/src/libraries/LibMiddleware.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n/// @notice The settings for the initial mint of the token.\n/// @param receivers The receivers of the tokens.\n/// @param amounts The amounts of tokens to be minted for each receiver.\n/// @dev The lengths of `receivers` and `amounts` must match.\nstruct MintSettings {\n    address[] receivers;\n    uint256[] amounts;\n}\n\n/// @title IERC20MintableUpgradeable\n/// @notice Interface to allow minting of [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens.\ninterface IERC20MintableUpgradeable {\n    /// @notice Mints [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens for a receiving address.\n    /// @param _to The receiving address.\n    /// @param _amount The amount of tokens.\n    function mint(address _to, uint256 _amount) external;\n}\n\n/// @title DistributableGovernanceERC20\n/// @author Peeramid Labs, adapted version from Aragon Association\n/// @notice An [OpenZeppelin `Votes`](https://docs.openzeppelin.com/contracts/4.x/api/governance#Votes) compatible [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token that can be used for voting and is managed by a DAO.\ncontract DistributableGovernanceERC20 is\n    IERC20MintableUpgradeable,\n    Initializable,\n    ERC165Upgradeable,\n    ERC20VotesUpgradeable,\n    ERC7746Middleware,\n    ReentrancyGuardUpgradeable\n{\n    /// @notice Thrown if the number of receivers and amounts specified in the mint settings do not match.\n    /// @param receiversArrayLength The length of the `receivers` array.\n    /// @param amountsArrayLength The length of the `amounts` array.\n    error MintSettingsArrayLengthMismatch(uint256 receiversArrayLength, uint256 amountsArrayLength);\n\n    /// @notice Calls the initialize function.\n    /// @param _name The name of the [ERC-20](https://eips.ethereum.org/EIPS/eip-20) governance token.\n    /// @param _symbol The symbol of the [ERC-20](https://eips.ethereum.org/EIPS/eip-20) governance token.\n    /// @param _mintSettings The token mint settings struct containing the `receivers` and `amounts`.\n    constructor(string memory _name, string memory _symbol, MintSettings memory _mintSettings, address _accessManager) {\n        initialize(_name, _symbol, _mintSettings, _accessManager);\n    }\n\n    /// @notice Initializes the contract and mints tokens to a list of receivers.\n    /// @param _name The name of the [ERC-20](https://eips.ethereum.org/EIPS/eip-20) governance token.\n    /// @param _symbol The symbol of the [ERC-20](https://eips.ethereum.org/EIPS/eip-20) governance token.\n    /// @param _mintSettings The token mint settings struct containing the `receivers` and `amounts`.\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        MintSettings memory _mintSettings,\n        address accessManager\n    ) public initializer {\n        LibMiddleware.LayerStruct[] memory layers = new LibMiddleware.LayerStruct[](1);\n\n        // Set the layer for the sender\n        layers[0] = LibMiddleware.LayerStruct({layerAddess: accessManager, layerConfigData: \"\"});\n        LibMiddleware.setLayers(layers);\n\n        // Check mint settings\n        if (_mintSettings.receivers.length != _mintSettings.amounts.length) {\n            revert MintSettingsArrayLengthMismatch({\n                receiversArrayLength: _mintSettings.receivers.length,\n                amountsArrayLength: _mintSettings.amounts.length\n            });\n        }\n\n        __ERC20_init(_name, _symbol);\n\n        for (uint256 i; i < _mintSettings.receivers.length; ++i) {\n            _mint(_mintSettings.receivers[i], _mintSettings.amounts[i]);\n        }\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(ERC20Upgradeable).interfaceId ||\n            // interfaceId == type(ERC20PermitUpgradeable).interfaceId ||\n            interfaceId == type(IERC20Metadata).interfaceId ||\n            interfaceId == type(VotesUpgradeable).interfaceId ||\n            interfaceId == type(IERC20MintableUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Mints tokens to an address.\n    /// @param to The address receiving the tokens.\n    /// @param amount The amount of tokens to be minted.\n    function mint(\n        address to,\n        uint256 amount\n    ) external override nonReentrant ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        _mint(to, amount);\n    }\n\n    // https://forum.openzeppelin.com/t/self-delegation-in-erc20votes/17501/12?u=novaknole\n    /// @inheritdoc ERC20VotesUpgradeable\n    function _update(address from, address to, uint256 amount) internal override {\n        super._update(from, to, amount);\n\n        // Automatically turn on delegation on mint/transfer but only for the first time.\n        if (to != address(0) && numCheckpoints(to) == 0 && delegates(to) == address(0)) {\n            _delegate(to, to);\n        }\n    }\n}\n"
    },
    "src/tokens/Rankify.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Rankify is ERC20Burnable, Ownable {\n    constructor(address owner) ERC20(\"Rankify\", \"RFY\") Ownable(owner) {\n        require(owner != address(0), \"must specify owner of the contract\");\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        require(to != address(0), \"mint:Address not specified\");\n        require(amount != 0, \"mint: amount not specified\");\n        _mint(to, amount);\n    }\n}\n"
    },
    "src/tokens/RankToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IRankToken} from \"../interfaces/IRankToken.sol\";\nimport \"../abstracts/LockableERC1155.sol\";\nimport \"@peeramid-labs/eds/src/abstracts/ERC7746Middleware.sol\";\nimport \"@peeramid-labs/eds/src/libraries/LibMiddleware.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/interfaces/IERC1155.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n//ToDo: it was planned to make it track for highest token users hold (their rank), right now it's not implemented. Yet.\n\n/**\n * @title RankToken\n * @author Peersky\n * @notice RankToken is a composite ERC1155 token that is used to track user ranks\n */\ncontract RankToken is LockableERC1155, IRankToken, ERC7746Middleware {\n    struct Storage {\n        string _contractURI;\n    }\n\n    bytes32 constant RANK_TOKEN_STORAGE_POSITION = keccak256(\"rank.token.storage.position\");\n\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 position = LOCKABLE_TOKEN_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    constructor(string memory uri_, string memory cURI, address accessLayer) {\n        initialize(uri_, cURI, accessLayer);\n    }\n\n    function initialize(string memory uri_, string memory cURI, address accessLayer) public initializer {\n        // __Ownable_init(owner_);\n        _setURI(uri_);\n        getStorage()._contractURI = cURI;\n        LibMiddleware.LayerStruct[] memory layers = new LibMiddleware.LayerStruct[](1);\n\n        // Set the layer for the sender\n        layers[0] = LibMiddleware.LayerStruct({layerAddess: accessLayer, layerConfigData: \"\"});\n        LibMiddleware.setLayers(layers);\n    }\n\n    // function getRankingInstance() public view returns (address) {\n    //     return getStorage().rankingInstance;\n    // }\n\n    function contractURI() public view returns (string memory) {\n        return getStorage()._contractURI;\n    }\n\n    function setURI(string memory uri_) public ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        _setURI(uri_);\n    }\n\n    function setContractURI(string memory uri_) public ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        getStorage()._contractURI = uri_;\n    }\n\n    function _mintRank(address to, uint256 amount, uint256 level, bytes memory data) private {\n        require(to != address(0), \"RankToken->mint: Address not specified\");\n        require(amount != 0, \"RankToken->mint: amount not specified\");\n        require(level != 0, \"RankToken->mint: pool id not specified\");\n        // if (level > topRank) {\n        //     topRank = level;\n        //     emit Leader(to, level);\n        // }\n        _mint(to, level, amount, data);\n    }\n\n    function mint(\n        address to,\n        uint256 amount,\n        uint256 level,\n        bytes memory data\n    ) public ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        _mintRank(to, amount, level, data);\n    }\n\n    // function updateRankingInstance(address newRankingInstance) public onlyOwner {\n    //     require(newRankingInstance != address(0), \"must specify ranking instance\");\n    //     getStorage()._rankingInstance = newRankingInstance;\n    //     emit RankingInstanceUpdated(newRankingInstance);\n    // }\n\n    function lock(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) public override(LockableERC1155, ILockableERC1155) ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        super.lock(account, id, amount);\n    }\n\n    function unlock(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) public override(LockableERC1155, ILockableERC1155) ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        super.unlock(account, id, amount);\n    }\n\n    function batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        require(to != address(0), \"RankToken->mint: Address not specified\");\n        require(amounts.length != 0, \"RankToken->mint: amount not specified\");\n        require(ids.length != 0, \"RankToken->mint: pool id not specified\");\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal override {\n        super._update(from, to, ids, values);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC1155Upgradeable) returns (bool) {\n        return interfaceId == type(IRankToken).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public override(LockableERC1155, ILockableERC1155) ERC7746C(msg.sig, msg.sender, msg.data, 0) {\n        super.burn(account, id, value);\n    }\n}\n"
    },
    "src/vendor/aragon/interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// This is a copy of interfaces and structs from @aragon/osx package\n// This had to be done to accomodate difference in solidity version requirements\n\nstruct TokenSettings {\n    address addr;\n    string name;\n    string symbol;\n}\n\nstruct Tag {\n    uint8 release;\n    uint16 build;\n}\n\nenum VotingMode {\n    Standard,\n    EarlyExecution,\n    VoteReplacement\n}\n\nstruct VotingSettings {\n    VotingMode votingMode;\n    uint32 supportThreshold;\n    uint32 minParticipation;\n    uint64 minDuration;\n    uint256 minProposerVotingPower;\n}\n\nstruct Version {\n    Tag tag;\n    address pluginSetup;\n    bytes buildMetadata;\n}\n\ninterface IPluginRepo {\n    /// @notice Updates the metadata for release with content `@fromHex(_releaseMetadata)`.\n    /// @param _release The release number.\n    /// @param _releaseMetadata The release metadata URI.\n    function updateReleaseMetadata(uint8 _release, bytes calldata _releaseMetadata) external;\n\n    /// @notice Creates a new plugin version as the latest build for an existing release number or the first build for a new release number for the provided `PluginSetup` contract address and metadata.\n    /// @param _release The release number.\n    /// @param _pluginSetupAddress The address of the plugin setup contract.\n    /// @param _buildMetadata The build metadata URI.\n    /// @param _releaseMetadata The release metadata URI.\n    function createVersion(\n        uint8 _release,\n        address _pluginSetupAddress,\n        bytes calldata _buildMetadata,\n        bytes calldata _releaseMetadata\n    ) external;\n\n    function latestRelease() external view returns (uint8);\n\n    function getLatestVersion(uint8 _release) external view returns (Version memory);\n}\n\ninterface IDAOFactory {\n    struct PluginSetupRef {\n        Tag versionTag;\n        IPluginRepo pluginSetupRepo;\n    }\n\n    /// @notice The container for the DAO settings to be set during the DAO initialization.\n    /// @param trustedForwarder The address of the trusted forwarder required for meta transactions.\n    /// @param daoURI The DAO uri used with [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824).\n    /// @param subdomain The ENS subdomain to be registered for the DAO contract.\n    /// @param metadata The metadata of the DAO.\n    struct DAOSettings {\n        address trustedForwarder;\n        string daoURI;\n        string subdomain;\n        bytes metadata;\n    }\n\n    /// @notice The container with the information required to install a plugin on the DAO.\n    /// @param pluginSetupRef The `PluginSetupRepo` address of the plugin and the version tag.\n    /// @param data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.\n    struct PluginSettings {\n        PluginSetupRef pluginSetupRef;\n        bytes data;\n    }\n\n    function createDao(\n        DAOSettings memory daoSettings,\n        PluginSettings[] memory pluginSettings\n    ) external returns (address);\n}\n"
    },
    "src/vendor/diamond/DiamondClonable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\n// https://github.com/mudgen/diamond-3-hardhat\n\nimport {LibDiamond} from \"./libraries/LibDiamond.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\n\n/**\n * @title DiamondClonable\n * @notice A modified Diamond implementation that supports cloning for efficient proxy deployment\n * @dev Extends the Diamond pattern to allow the contract to be cloned, reducing gas costs\n *      for deploying multiple instances. Includes core Diamond functionality like cut operations\n *      and function delegation.\n * @author Adapted from Nick Mudge's Diamond implementation by Peeramid Labs, 2024\n */\ncontract DiamondClonable {\n    error functionDoesNotExist(bytes4 selector);\n    address private immutable cutFacet;\n\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        cutFacet = _diamondCutFacet;\n        addDiamondCutFacet(_contractOwner);\n    }\n\n    function addDiamondCutFacet(address _contractOwner) private {\n        LibDiamond.setContractOwner(_contractOwner);\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: cutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        if (facet == address(0)) {\n            if (msg.sig == IDiamondCut.diamondCut.selector) {\n                (IDiamondCut.FacetCut[] memory facets, address target, bytes memory data) = abi.decode(\n                    msg.data[4:],\n                    (IDiamondCut.FacetCut[], address, bytes)\n                );\n                // diamond was cloned, has no state\n                // Owner is inferred from msg.sender\n                addDiamondCutFacet(msg.sender);\n                LibDiamond.diamondCut(facets, target, data);\n                return;\n            } else {\n                revert functionDoesNotExist(msg.sig);\n            }\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/vendor/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/LibDiamond.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes memory _calldata) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    },
    "src/vendor/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IDiamondLoupe.sol\";\nimport \"../interfaces/IERC165.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; ++i) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[interfaceId];\n    }\n}\n"
    },
    "src/vendor/diamond/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external view override returns (address) {\n        return LibDiamond.contractOwner();\n    }\n}\n"
    },
    "src/vendor/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/******************************************************************************\\\n*  Adapted from\n*  Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "src/vendor/diamond/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/vendor/diamond/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/vendor/diamond/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    // Removed deue to duplicate abi generation in 8.20 compiler\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "src/vendor/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\n// https://github.com/mudgen/diamond-3-hardhat\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n    error DuplicateSignature(bytes4 _selector);\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            // this is removed in order to work with ethereum distribution system\n            // require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}