{
  "address": "0xbaF7c7C1eDDFBd391D9a5298867818f06E2C00Db",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "DomainActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32[]",
          "name": "changes",
          "type": "bytes32[]"
        }
      ],
      "name": "DomainChangesAreLive",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "DomainDeactivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "newFee",
          "type": "uint256"
        }
      ],
      "name": "DomainFeeChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "domainIndex",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "NewDomainName",
          "type": "bytes32"
        }
      ],
      "name": "DomainNameChangeRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "DomainTTLChangeRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "domainIndex",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "FreeRegistrationsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "registrar",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeRegistrationsNumber",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "referrerReward",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "referralDiscount",
          "type": "uint256"
        }
      ],
      "name": "InitializedDomain",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "discount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "freeNumber",
          "type": "uint256"
        }
      ],
      "name": "ReferralProgramChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "uint96",
              "name": "nonce",
              "type": "uint96"
            },
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            }
          ],
          "indexed": false,
          "internalType": "struct LibMultipass.Record",
          "name": "refferrer",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "uint96",
              "name": "nonce",
              "type": "uint96"
            },
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            }
          ],
          "indexed": false,
          "internalType": "struct LibMultipass.Record",
          "name": "newRecord",
          "type": "tuple"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "Referred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "uint96",
              "name": "nonce",
              "type": "uint96"
            },
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            }
          ],
          "indexed": false,
          "internalType": "struct LibMultipass.Record",
          "name": "NewRecord",
          "type": "tuple"
        }
      ],
      "name": "Registered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "registrar",
          "type": "address"
        }
      ],
      "name": "RegistrarChangeRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "uint96",
              "name": "nonce",
              "type": "uint96"
            },
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            }
          ],
          "indexed": true,
          "internalType": "struct LibMultipass.Record",
          "name": "newRecord",
          "type": "tuple"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "oldName",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "UserRecordModified",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32[]",
          "name": "changes",
          "type": "bytes32[]"
        }
      ],
      "name": "changesQeueCanceled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "fundsWithdawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "wallet",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        }
      ],
      "name": "nameDeleted",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "activateDomain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        }
      ],
      "name": "changeFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "referrerReward",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeRegistrations",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "referralDiscount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "changeReferralProgram",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "newRegistrar",
          "type": "address"
        }
      ],
      "name": "changeRegistrar",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "deactivateDomain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "targetDomain",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.NameQuery",
          "name": "query",
          "type": "tuple"
        }
      ],
      "name": "deleteName",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getContractState",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        }
      ],
      "name": "getDomainState",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "freeRegistrationsNumber",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "referrerReward",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "referralDiscount",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isActive",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "registrar",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "ttl",
              "type": "uint24"
            },
            {
              "internalType": "uint256",
              "name": "registerSize",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibMultipass.Domain",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getDomainStateByIdx",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "freeRegistrationsNumber",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "referrerReward",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "referralDiscount",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isActive",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "registrar",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "ttl",
              "type": "uint24"
            },
            {
              "internalType": "uint256",
              "name": "registerSize",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibMultipass.Domain",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "targetDomain",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.NameQuery",
          "name": "query",
          "type": "tuple"
        }
      ],
      "name": "getModifyPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "registrar",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "freeRegistrationsNumber",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "referrerReward",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "referralDiscount",
          "type": "uint256"
        }
      ],
      "name": "initializeDomain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "targetDomain",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.NameQuery",
          "name": "query",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "newName",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "registrarSignature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "signatureDeadline",
          "type": "uint256"
        }
      ],
      "name": "modifyUserName",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "uint96",
              "name": "nonce",
              "type": "uint96"
            },
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.Record",
          "name": "newRecord",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "domainName",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "registrarSignature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "signatureDeadline",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "targetDomain",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.NameQuery",
          "name": "referrer",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "referralCode",
          "type": "bytes"
        }
      ],
      "name": "register",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "targetDomain",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.NameQuery",
          "name": "query",
          "type": "tuple"
        }
      ],
      "name": "resolveRecord",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "uint96",
              "name": "nonce",
              "type": "uint96"
            },
            {
              "internalType": "bytes32",
              "name": "domainName",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibMultipass.Record",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "withrawFunds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4356212991e5a83b384b7b09be90e1b2d81e3455da733b1536b020adfc4c0884",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x6Cf8d74C7875de8C2FfB09228F4bf2A21b25e583",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "3050027",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x34c2e607d265276be78ca4c8b919f4bbe746881f09d2510de5ddc6a9cc585e43",
    "transactionHash": "0x4356212991e5a83b384b7b09be90e1b2d81e3455da733b1536b020adfc4c0884",
    "logs": [],
    "blockNumber": 1059,
    "cumulativeGasUsed": "3050027",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "d4243cadb17b72c1adc02b25740ca647",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"DomainActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32[]\",\"name\":\"changes\",\"type\":\"bytes32[]\"}],\"name\":\"DomainChangesAreLive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"DomainDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"DomainFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"domainIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"NewDomainName\",\"type\":\"bytes32\"}],\"name\":\"DomainNameChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DomainTTLChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"domainIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"FreeRegistrationsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeRegistrationsNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralDiscount\",\"type\":\"uint256\"}],\"name\":\"InitializedDomain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"freeNumber\",\"type\":\"uint256\"}],\"name\":\"ReferralProgramChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct LibMultipass.Record\",\"name\":\"refferrer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct LibMultipass.Record\",\"name\":\"newRecord\",\"type\":\"tuple\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"Referred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct LibMultipass.Record\",\"name\":\"NewRecord\",\"type\":\"tuple\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"RegistrarChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"indexed\":true,\"internalType\":\"struct LibMultipass.Record\",\"name\":\"newRecord\",\"type\":\"tuple\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"oldName\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"UserRecordModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32[]\",\"name\":\"changes\",\"type\":\"bytes32[]\"}],\"name\":\"changesQeueCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"fundsWithdawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"nameDeleted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"activateDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeRegistrations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralDiscount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"changeReferralProgram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newRegistrar\",\"type\":\"address\"}],\"name\":\"changeRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"deactivateDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"targetDomain\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.NameQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"name\":\"deleteName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"name\":\"getDomainState\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeRegistrationsNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralDiscount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"ttl\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"registerSize\",\"type\":\"uint256\"}],\"internalType\":\"struct LibMultipass.Domain\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDomainStateByIdx\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeRegistrationsNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralDiscount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"ttl\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"registerSize\",\"type\":\"uint256\"}],\"internalType\":\"struct LibMultipass.Domain\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"targetDomain\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.NameQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"name\":\"getModifyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"freeRegistrationsNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"referrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralDiscount\",\"type\":\"uint256\"}],\"name\":\"initializeDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"targetDomain\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.NameQuery\",\"name\":\"query\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"newName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"registrarSignature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"signatureDeadline\",\"type\":\"uint256\"}],\"name\":\"modifyUserName\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.Record\",\"name\":\"newRecord\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"registrarSignature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"signatureDeadline\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"targetDomain\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.NameQuery\",\"name\":\"referrer\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"referralCode\",\"type\":\"bytes\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"targetDomain\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.NameQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"name\":\"resolveRecord\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"domainName\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibMultipass.Record\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"activateDomain(bytes32)\":{\"details\":\"Activates LibMultipass.Domain name Requirements:  msg.sender is Owner  Emits an {DomainActivated} event.\"},\"changeFee(bytes32,uint256)\":{\"details\":\"Changes registrar address Requirements:  msg.sender is Owner  Emits an {DomainFeeChanged} event.\"},\"changeRegistrar(bytes32,address)\":{\"details\":\"Changes registrar address Requirements:  msg.sender is Owner  Emits an {RegistrarChangeRequested} event.\"},\"deactivateDomain(bytes32)\":{\"details\":\"Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements:  msg.sender is Owner OR registrar  Emits an {DomainDeactivated} event.\"},\"deleteName((bytes32,address,bytes32,bytes32,bytes32))\":{\"details\":\"deletes name Requirements:  msg.sender is Owner  Emits an {DomainTTLChangeRequested} event.\"},\"getBalance()\":{\"details\":\"returns balance of this contract\"},\"getContractState()\":{\"details\":\"returns contract state variables\",\"returns\":{\"_0\":\"(s_numDomains)\"}},\"getDomainState(bytes32)\":{\"details\":\"returns LibMultipass.Domain state variables\",\"params\":{\"domainName\":\"name of the LibMultipass.Domain\"},\"returns\":{\"_0\":\"(name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize)\"}},\"initializeDomain(address,uint256,uint256,bytes32,uint256,uint256)\":{\"details\":\"Initializes new LibMultipass.Domain and configures it's parameters Requirements:  registrar is not zero  domainName is not empty  domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names  domainName does not exist yet  onlyOwner  referrerReward+referralDiscount cannot be larger than fee\",\"params\":{\"domainName\":\"name of LibMultipass.Domain\",\"fee\":\"fee in base currency of network\",\"freeRegistrationsNumber\":\"number of registrations free of fee\",\"referralDiscount\":\"referral discount in base currency of network  Emits an {InitializedDomain} event.\",\"referrerReward\":\"referral fee share in base currency of network\",\"registrar\":\"address of registrar\"}},\"modifyUserName(bytes32,(bytes32,address,bytes32,bytes32,bytes32),bytes32,bytes,uint256)\":{\"details\":\"modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain\",\"params\":{\"domainName\":\"LibMultipass.Domain\",\"newName\":\"new name  Emits an {Modified} event.\"}},\"register((address,bytes32,bytes32,uint96,bytes32),bytes32,bytes,uint256,(bytes32,address,bytes32,bytes32,bytes32),bytes)\":{\"details\":\"registers new name under LibMultipass.Domain Requirements:  all arguments must be set  domainName must be active resolveRecord for given arguments should return no LibMultipass.Record  Emits an {registered} event.\"},\"resolveRecord((bytes32,address,bytes32,bytes32,bytes32))\":{\"details\":\"resolves LibMultipass.Record of name query in to status and identity \"},\"withrawFunds(address)\":{\"details\":\"Withraws funds stored in smart contract Requirements:  onlyOwner  Emits an {fundsWithdawn} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/facets/DNSFacet.sol\":\"DNSFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x3af3ca86df39aac39a0514c84459d691434a108d2151c8ce9d69f32e315cab80\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"src/abstracts/draft-EIP712Diamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../libraries/LibEIP712Storage.sol\\\";\\nimport \\\"../modifiers/OnlyOwnerDiamond.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 is OnlyOwnerDiamond {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\\n        if (address(this) == ss._CACHED_THIS && block.chainid == ss._CACHED_CHAIN_ID) {\\n            return ss._CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(ss._TYPE_HASH, ss._HASHED_NAME, ss._HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\",\"keccak256\":\"0x26b10c662581738d0d65e4df162d8355785d08913a3e939772894578039f1a54\",\"license\":\"MIT\"},\"src/facets/DNSFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n// import \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../abstracts/draft-EIP712Diamond.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IMultipass.sol\\\";\\nimport \\\"../libraries/LibMultipass.sol\\\";\\nimport \\\"../modifiers/OnlyOwnerDiamond.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../vendor/facets/OwnershipFacet.sol\\\";\\n\\n// Consider upgrade for https://eips.ethereum.org/EIPS/eip-4834\\n\\ncontract DNSFacet is EIP712, IMultipass {\\n    using ECDSA for bytes32;\\n    using LibMultipass for bytes32;\\n\\n    // using LibMultipass for LibMultipass.Record;\\n    using LibMultipass for LibMultipass.Record;\\n    using LibMultipass for bytes;\\n\\n    function _isValidSignature(\\n        bytes memory message,\\n        bytes memory signature,\\n        address account\\n    ) internal view returns (bool) {\\n        bytes32 typedHash = _hashTypedDataV4(keccak256(message));\\n        return SignatureChecker.isValidSignatureNow(account, typedHash, signature);\\n    }\\n\\n    function _validateRegistration(\\n        LibMultipass.Record memory newRecord,\\n        bytes32 domainName,\\n        bytes memory registrarSignature,\\n        uint256 signatureDeadline\\n    ) private view {\\n        LibMultipass.NameQuery memory query = LibMultipass.queryFromRecord(newRecord, domainName);\\n        //Check name query is legit\\n        require(LibMultipass._checkNotEmpty(query.id), \\\"_validateNameQuery-> new record id cannot be empty\\\");\\n        require(\\n            LibMultipass._checkNotEmpty(query.domainName),\\n            \\\"_validateNameQuery-> new record domain cannot be empty\\\"\\n        );\\n        require(query.wallet != address(0), \\\"_validateNameQuery-> new ecord address cannot be empty\\\");\\n\\n        //Check query does not resolves (name already exists)\\n        (bool nameExists, ) = LibMultipass.resolveRecord(query);\\n        require(nameExists == false, \\\"User already registered, use modify instead\\\");\\n        //Check LibMultipass.Domain is legit\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(query.domainName);\\n        require(_domain.properties.isActive, \\\"Multipass->register: domain is not active\\\");\\n\\n        //check signatures and time\\n        require(signatureDeadline > block.number, \\\"Multipass->register: Deadline is less than current block number\\\");\\n\\n        {\\n            bytes memory registrarMessage = abi.encode(\\n                LibMultipass._TYPEHASH,\\n                query.name,\\n                query.id,\\n                query.domainName,\\n                signatureDeadline,\\n                0\\n            );\\n\\n            require(\\n                _isValidSignature(registrarMessage, registrarSignature, _domain.properties.registrar),\\n                \\\"Multipass->register: Registrar signature is not valid\\\"\\n            );\\n        }\\n        {\\n            (bool status, ) = LibMultipass.resolveRecord(query);\\n            require(status == false, \\\"Multipass->register: applicant is already registered, use modify instread\\\");\\n        }\\n    }\\n\\n    function initializeDomain(\\n        address registrar,\\n        uint256 freeRegistrationsNumber,\\n        uint256 fee,\\n        bytes32 domainName,\\n        uint256 referrerReward,\\n        uint256 referralDiscount\\n    ) public override onlyOwner {\\n        require(registrar != address(0), \\\"Multipass->initializeDomain: You must provide a registrar address\\\");\\n        require(LibMultipass._checkNotEmpty(domainName), \\\"Multipass->initializeDomain: Domain name cannot be empty\\\");\\n        require(\\n            LibMultipass.resolveDomainIndex(domainName) == 0,\\n            \\\"Multipass->initializeDomain: Domain name already exists\\\"\\n        );\\n        (bool status, uint256 result) = SafeMath.tryAdd(referrerReward, referralDiscount);\\n        require(status == true, \\\"Multipass->initializeDomain: referrerReward + referralDiscount overflow\\\");\\n        require(result <= fee, \\\"Multipass->initializeDomain: referral values are higher then fee itself\\\");\\n\\n        LibMultipass._initializeDomain(\\n            registrar,\\n            freeRegistrationsNumber,\\n            fee,\\n            domainName,\\n            referrerReward,\\n            referralDiscount\\n        );\\n        emit InitializedDomain(registrar, freeRegistrationsNumber, fee, domainName, referrerReward, referralDiscount);\\n    }\\n\\n    function _enforseDomainNameIsValid(bytes32 domainName) private view {\\n        require(domainName._checkNotEmpty(), \\\"activateDomain->Please specify LibMultipass.Domain name\\\");\\n        require(domainName.resolveDomainIndex() != 0, \\\"Domain does not exist\\\");\\n    }\\n\\n    function activateDomain(bytes32 domainName) public override onlyOwner {\\n        _enforseDomainNameIsValid(domainName);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        _domain.properties.isActive = true;\\n        emit DomainActivated(domainName);\\n    }\\n\\n    function deactivateDomain(bytes32 domainName) public override onlyOwner {\\n        _enforseDomainNameIsValid(domainName);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        _domain.properties.isActive = false;\\n    }\\n\\n    function changeFee(bytes32 domainName, uint256 fee) public override onlyOwner {\\n        _enforseDomainNameIsValid(domainName);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        uint256 _referrerReward = _domain.properties.referrerReward;\\n        uint256 _referralDiscount = _domain.properties.referralDiscount;\\n        require(\\n            _referralDiscount + _referrerReward <= fee,\\n            \\\"Multipass->changeFee: referral rewards would become too high\\\"\\n        );\\n        _domain.properties.fee = fee;\\n        emit DomainFeeChanged(domainName, fee);\\n    }\\n\\n    function changeRegistrar(bytes32 domainName, address newRegistrar) public override onlyOwner {\\n        _enforseDomainNameIsValid(domainName);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        require(newRegistrar != address(0), \\\"new registrar cannot be zero\\\");\\n        _domain.properties.registrar = newRegistrar;\\n    }\\n\\n    function deleteName(\\n        LibMultipass.NameQuery memory query // bytes32 domainName, // address wallet, // bytes32 username, // bytes32 id\\n    ) public override onlyOwner {\\n        _enforseDomainNameIsValid(query.domainName);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(query.domainName);\\n        query.targetDomain = \\\"\\\";\\n        (bool status, LibMultipass.Record memory r) = resolveRecord(query);\\n        require(status == true, \\\"Multipass->deleteName: name not resolved\\\");\\n        _domain.addressToId[r.wallet] = bytes32(0);\\n        _domain.idToAddress[r.id] = address(0);\\n        _domain.idToName[r.id] = bytes32(0);\\n        _domain.nameToId[r.name] = bytes32(0);\\n        _domain.nonce[r.id] += 1;\\n        _domain.properties.registerSize--;\\n\\n        emit nameDeleted(_domain.properties.name, r.wallet, r.id, r.name);\\n    }\\n\\n    function changeReferralProgram(\\n        uint256 referrerReward,\\n        uint256 freeRegistrations,\\n        uint256 referralDiscount,\\n        bytes32 domainName\\n    ) public override onlyOwner {\\n        _enforseDomainNameIsValid(domainName);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        (bool status, uint256 result) = SafeMath.tryAdd(referrerReward, referralDiscount);\\n        require(status == true, \\\"Multipass->changeReferralProgram: referrerReward + referralDiscount overflow\\\");\\n        require(\\n            result <= _domain.properties.fee,\\n            \\\"Multipass->changeReferralProgram: referral values are higher then the fee itself\\\"\\n        );\\n        _domain.properties.referrerReward = referrerReward;\\n        _domain.properties.referralDiscount = referralDiscount;\\n        _domain.properties.freeRegistrationsNumber = freeRegistrations;\\n        emit ReferralProgramChanged(domainName, referrerReward, referralDiscount, freeRegistrations);\\n    }\\n\\n    /**\\n    @dev resolves LibMultipass.Record of name query in to status and identity */\\n    function resolveRecord(\\n        LibMultipass.NameQuery memory query\\n    ) public view override returns (bool, LibMultipass.Record memory) {\\n        return LibMultipass.resolveRecord(query);\\n    }\\n\\n    function register(\\n        LibMultipass.Record memory newRecord,\\n        bytes32 domainName,\\n        bytes memory registrarSignature,\\n        uint256 signatureDeadline,\\n        LibMultipass.NameQuery memory referrer,\\n        bytes memory referralCode\\n    ) public payable override {\\n        _enforseDomainNameIsValid(domainName);\\n        _validateRegistration(newRecord, domainName, registrarSignature, signatureDeadline);\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        (bool hasValidReferrer, LibMultipass.Record memory referrerRecord) = LibMultipass.resolveRecord(referrer);\\n        uint256 referrersShare = 0;\\n        if (!LibMultipass.shouldRegisterForFree(_domain)) {\\n            referrersShare = hasValidReferrer ? _domain.properties.referrerReward : 0;\\n            uint256 valueToPay = SafeMath.sub(\\n                _domain.properties.fee,\\n                hasValidReferrer ? _domain.properties.referralDiscount : 0\\n            );\\n            require(msg.value >= valueToPay, \\\"Multipass->register: Payment value is not enough\\\");\\n        }\\n        LibMultipass._registerNew(newRecord, _domain);\\n        emit Registered(_domain.properties.name, newRecord);\\n        if (hasValidReferrer) {\\n            bytes memory refferalMessage = abi.encode(LibMultipass._TYPEHASH_REFERRAL, referrerRecord.wallet);\\n            require(\\n                _isValidSignature(refferalMessage, referralCode, referrerRecord.wallet),\\n                \\\"Multipass->register: Referral code is not valid\\\"\\n            );\\n            require(\\n                payable(referrerRecord.wallet).send(referrersShare),\\n                \\\"Multipass->register: Failed to send referral reward\\\"\\n            );\\n            require(referrerRecord.wallet != newRecord.wallet, \\\"Cannot refer yourself\\\");\\n            emit Referred(referrerRecord, newRecord, domainName);\\n        }\\n    }\\n\\n    function getModifyPrice(LibMultipass.NameQuery memory query) public view override returns (uint256) {\\n        (bool userExists, LibMultipass.Record memory record) = LibMultipass.resolveRecord(query);\\n        require(userExists == true, \\\"getModifyPrice->user not found \\\");\\n        return LibMultipass._getModifyPrice(record);\\n    }\\n\\n    function modifyUserName(\\n        bytes32 domainName,\\n        LibMultipass.NameQuery memory query,\\n        bytes32 newName,\\n        bytes memory registrarSignature,\\n        uint256 signatureDeadline\\n    ) public payable override {\\n        _enforseDomainNameIsValid(domainName);\\n        query.targetDomain = domainName;\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        require(_domain.properties.isActive, \\\"Multipass->modifyUserName: LibMultipass.Domain is not active\\\");\\n        require(newName != bytes32(0), \\\"Multipass->modifyUserName: Name cannot be empty\\\");\\n        require(\\n            signatureDeadline >= block.number,\\n            \\\"Multipass->modifyUserName: Signature deadline must be greater than current block number\\\"\\n        );\\n\\n        (bool userExists, LibMultipass.Record memory userRecord) = LibMultipass.resolveRecord(query);\\n        LibMultipass.Record memory newRecord = userRecord;\\n        bytes32 oldName = newRecord.name;\\n        newRecord.name = newName;\\n        require(userExists == true, \\\"user does not exist, use register() instead\\\");\\n        bytes memory registrarMessage = abi.encode(\\n            LibMultipass._TYPEHASH,\\n            newRecord.name,\\n            newRecord.id,\\n            newRecord.domainName,\\n            signatureDeadline,\\n            userRecord.nonce\\n        );\\n        require(\\n            _isValidSignature(registrarMessage, registrarSignature, _domain.properties.registrar),\\n            \\\"Multipass->modifyUserName: Not a valid signature\\\"\\n        );\\n\\n        uint256 _fee = LibMultipass._getModifyPrice(newRecord);\\n\\n        require(msg.value >= _fee, \\\"Multipass->modifyUserName: Not enough payment\\\");\\n        require(_domain.nonce[userRecord.id] == userRecord.nonce, \\\"Multipass->modifyUserName: invalid nonce\\\");\\n        require(_domain.nameToId[newName] == bytes32(0), \\\"OveMultipass->modifyUserName: new name already exists\\\");\\n\\n        LibMultipass._setRecord(_domain, newRecord);\\n        _domain.nameToId[_domain.idToName[newRecord.id]] = bytes32(0);\\n\\n        emit UserRecordModified(newRecord, oldName, domainName);\\n    }\\n\\n    function getBalance() external view override returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function getDomainState(bytes32 domainName) external view override returns (LibMultipass.Domain memory) {\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(domainName);\\n        return _domain.properties;\\n    }\\n\\n    function getDomainStateByIdx(uint256 index) external view returns (LibMultipass.Domain memory) {\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorageByIdx(index);\\n        return _domain.properties;\\n    }\\n\\n    function getContractState() external view override returns (uint256) {\\n        return LibMultipass._getContractState();\\n    }\\n\\n    function withrawFunds(address to) public override onlyOwner {\\n        payable(to).transfer(address(this).balance);\\n    }\\n}\\n\",\"keccak256\":\"0xb427f71c7593aa981e403badf0743866ace5606678606b96f89d4a1d5a38da29\",\"license\":\"MIT\"},\"src/interfaces/IMultipass.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../libraries/LibMultipass.sol\\\";\\n\\ninterface IMultipass {\\n    function resolveRecord(\\n        LibMultipass.NameQuery memory query\\n    ) external view returns (bool, LibMultipass.Record memory);\\n\\n    /** @dev same as resolveRecord but returns username, id and LibMultipass.Domain as string */\\n    // function resolveRecordToString(LibMultipass.NameQuery memory query)\\n    //     external\\n    //     view\\n    //     returns (\\n    //         bool,\\n    //         LibMultipass.Record memory\\n    //     );\\n\\n    /**\\n     * @dev Initializes new LibMultipass.Domain and configures it's parameters\\n     *\\n     * Requirements:\\n     *  registrar is not zero\\n     *  domainName is not empty\\n     *  domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names\\n     *  domainName does not exist yet\\n     *  onlyOwner\\n     *  referrerReward+referralDiscount cannot be larger than fee\\n     *  @param registrar address of registrar\\n     *  @param freeRegistrationsNumber number of registrations free of fee\\n     *  @param fee fee in base currency of network\\n     *  @param domainName name of LibMultipass.Domain\\n     *  @param referrerReward referral fee share in base currency of network\\n     *  @param referralDiscount referral discount in base currency of network\\n     *\\n     *  Emits an {InitializedDomain} event.\\n     */\\n    function initializeDomain(\\n        address registrar,\\n        uint256 freeRegistrationsNumber,\\n        uint256 fee,\\n        bytes32 domainName,\\n        uint256 referrerReward,\\n        uint256 referralDiscount\\n    ) external;\\n\\n    /**\\n     * @dev Activates LibMultipass.Domain name\\n     *\\n     * Requirements:\\n     *  msg.sender is Owner\\n     *\\n     *\\n     *  Emits an {DomainActivated} event.\\n     */\\n    function activateDomain(bytes32 domainName) external;\\n\\n    /**\\n     * @dev Deactivates LibMultipass.Domain name\\n     *\\n     * Deactivated LibMultipass.Domain cannot mutate names and will return zeros\\n     *\\n     * Requirements:\\n     *  msg.sender is Owner OR registrar\\n     *\\n     *\\n     *  Emits an {DomainDeactivated} event.\\n     */\\n\\n    function deactivateDomain(bytes32 domainName) external;\\n\\n    /**\\n     * @dev Changes registrar address\\n     *\\n     * Requirements:\\n     *  msg.sender is Owner\\n     *\\n     *  Emits an {DomainFeeChanged} event.\\n     */\\n    function changeFee(bytes32 domainName, uint256 fee) external;\\n\\n    /**\\n     * @dev Changes registrar address\\n     *\\n     * Requirements:\\n     *  msg.sender is Owner\\n     *\\n     *  Emits an {RegistrarChangeRequested} event.\\n     */\\n    function changeRegistrar(bytes32 domainName, address newRegistrar) external;\\n\\n    /**\\n     * @dev deletes name\\n     *\\n     * Requirements:\\n     *  msg.sender is Owner\\n     *\\n     *  Emits an {DomainTTLChangeRequested} event.\\n     */\\n    function deleteName(LibMultipass.NameQuery memory query) external;\\n\\n    /**\\n     * @dev executes all pending changes to LibMultipass.Domain that fulfill TTL\\n     *\\n     * Requirements:\\n     *  domainName must be set\\n     *  referrerFeeShare+referralDiscount cannot be larger than 2^32\\n     *\\n     *\\n     *  Emits an {ReferralProgramChangeRequested} event.\\n     */\\n    function changeReferralProgram(\\n        uint256 referrerFeeShare,\\n        uint256 referralDiscount,\\n        uint256 freeRegistrations,\\n        bytes32 domainName\\n    ) external;\\n\\n    /**\\n     * @dev registers new name under LibMultipass.Domain\\n     *\\n     * Requirements:\\n     *  all arguments must be set\\n     *  domainName must be active\\n     * resolveRecord for given arguments should return no LibMultipass.Record\\n     *\\n     *\\n     *  Emits an {registered} event.\\n     */\\n    function register(\\n        LibMultipass.Record memory newRecord,\\n        bytes32 domainName,\\n        bytes memory registrarSignature,\\n        uint256 signatureDeadline,\\n        LibMultipass.NameQuery memory referrer,\\n        bytes memory referralCode\\n    ) external payable;\\n\\n    /**\\n     * @dev modifies exsisting LibMultipass.Record\\n     *\\n     * Requirements:\\n     * resolveRecord for given arguments should return valid LibMultipass.Record\\n     * LibMultipass.Domain must be active\\n     * newAddress and newName should be set and be unique in current LibMultipass.Domain\\n     *\\n     * @param domainName LibMultipass.Domain\\n     * @param newName new name\\n     *\\n     *  Emits an {Modified} event.\\n     */\\n    function modifyUserName(\\n        bytes32 domainName,\\n        LibMultipass.NameQuery memory query,\\n        bytes32 newName,\\n        bytes memory registrarSignature,\\n        uint256 signatureDeadline\\n    ) external payable;\\n\\n    /**\\n     * @dev returns balance of this contract\\n     */\\n    function getBalance() external view returns (uint256);\\n\\n    /**\\n     * @dev returns LibMultipass.Domain state variables\\n     * @param domainName name of the LibMultipass.Domain\\n     * @return (name,\\n      fee,\\n      freeRegistrationsNumber,\\n       referrerReward,\\n       referralDiscount,\\n       isActive,\\n       registrar,\\n       ttl,\\n        registerSize)\\n     */\\n    function getDomainState(bytes32 domainName) external view returns (LibMultipass.Domain memory);\\n\\n    /**\\n     * @dev returns contract state variables\\n\\n     * @return (s_numDomains)\\n     */\\n    function getContractState() external view returns (uint256);\\n\\n    /**\\n     * @dev Withraws funds stored in smart contract\\n     *\\n     * Requirements:\\n     *  onlyOwner\\n     *\\n     *  Emits an {fundsWithdawn} event.\\n     */\\n    function withrawFunds(address to) external;\\n\\n    function getModifyPrice(LibMultipass.NameQuery memory query) external view returns (uint256);\\n\\n    event fundsWithdawn(uint256 indexed amount, address indexed account);\\n\\n    // event InitializedDomain(uint256 indexed index, bytes32 indexed domainName);\\n    event InitializedDomain(\\n        address indexed registrar,\\n        uint256 freeRegistrationsNumber,\\n        uint256 indexed fee,\\n        bytes32 indexed domainName,\\n        uint256 referrerReward,\\n        uint256 referralDiscount\\n    );\\n    event DomainActivated(bytes32 indexed domainName);\\n    event DomainDeactivated(bytes32 indexed domainName);\\n\\n    event DomainFeeChanged(bytes32 indexed domainName, uint256 indexed newFee);\\n    event FreeRegistrationsChanged(uint256 indexed domainIndex, uint256 indexed newAmount);\\n\\n    event RegistrarChangeRequested(bytes32 indexed domainName, address indexed registrar);\\n    event DomainNameChangeRequested(uint256 indexed domainIndex, bytes32 indexed NewDomainName);\\n    event nameDeleted(bytes32 indexed domainName, address indexed wallet, bytes32 indexed id, bytes32 name);\\n    event DomainTTLChangeRequested(bytes32 indexed domainName, uint256 amount);\\n    event ReferralProgramChanged(\\n        bytes32 indexed domainName,\\n        uint256 reward,\\n        uint256 discount,\\n        uint256 indexed freeNumber\\n    );\\n    event DomainChangesAreLive(bytes32 indexed domainName, bytes32[] indexed changes);\\n    event changesQeueCanceled(bytes32 indexed domainName, bytes32[] indexed changes);\\n\\n    event Registered(bytes32 indexed domainName, LibMultipass.Record NewRecord);\\n\\n    event Referred(LibMultipass.Record refferrer, LibMultipass.Record newRecord, bytes32 indexed domainName);\\n\\n    event UserRecordModified(\\n        LibMultipass.Record indexed newRecord,\\n        bytes32 indexed oldName,\\n        bytes32 indexed domainName\\n    );\\n}\\n\",\"keccak256\":\"0x4721d78c12b605d64e514fe1f9fc430a43e177f651642a5a72939d8a8513fd32\",\"license\":\"MIT\"},\"src/libraries/LibEIP712Storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport {IDiamondCut} from \\\"../vendor/interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibEIP712WithStorage {\\n    bytes32 constant EIP712_STORAGE_POSITION = keccak256(\\\"EIP.712.STORAGE.POSITION\\\");\\n\\n    struct LibEIP712WithStorageStorage {\\n        bytes32 _CACHED_DOMAIN_SEPARATOR;\\n        uint256 _CACHED_CHAIN_ID;\\n        address _CACHED_THIS;\\n        bytes32 _HASHED_NAME;\\n        bytes32 _HASHED_VERSION;\\n        bytes32 _TYPE_HASH;\\n    }\\n\\n    function EIP712WithStorage() internal pure returns (LibEIP712WithStorageStorage storage ds) {\\n        bytes32 position = EIP712_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x630caa1a57dddf5e609dc42a371b4c17c9544a6100e4018bbfd257e6bf91b5d5\",\"license\":\"MIT\"},\"src/libraries/LibMultipass.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// import \\\"./LibDiamondOwner.sol\\\";\\n// import { IMultipass } from \\\"../interfaces/sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary LibMultipass {\\n    /**\\n     * @dev resolves user from any given argument\\n     * Requirements:\\n     *  domainName must be given and must be initialized\\n     *  id OR username OR address must be given\\n     * This method first tries to resolve by address, then by user id and finally by username\\n     * @param domainName domain name\\n     * @param wallet adress of user\\n     * @param id user id\\n     * @param username username\\n     * @param targetDomain if this is set to valid domain name, then after sucessfull resolving account at domainName,\\n     *                       this method will rerun with resolving user properties in targetDomain\\n     */\\n    struct NameQuery {\\n        bytes32 domainName;\\n        address wallet;\\n        bytes32 name;\\n        bytes32 id;\\n        bytes32 targetDomain;\\n    }\\n\\n    /**\\n     * @dev The domain name of the registrar.\\n     * @param registrar is the address private key of which is owned by signing server (e.g. Discord bot server)\\n     * @param name is unique string that is used to find this domain within domains.\\n     * @param freeRegistrationsNumber is the number of free registrations for this domain\\n\\n     * @param fee amount of payment requried to register name in the domain\\n     * @param ttl time to live for changes in the domain properties\\n     * @param isActive when is false domain name will not respond to any changes and will not return any address\\n    **/\\n    struct Domain {\\n        bytes32 name; //32bytes\\n        uint256 fee; //32bytes\\n        uint256 freeRegistrationsNumber; //32bytes\\n        uint256 referrerReward; //32bytes\\n        uint256 referralDiscount; //32bytes\\n        bool isActive; //1byte\\n        address registrar; //20 bytes\\n        uint24 ttl; //3 bytes (not being used for now)\\n        uint256 registerSize; //32bytes\\n    }\\n\\n    //  struct NameQueryBytes32 {\\n    //     string domainName;\\n    //     address wallet;\\n    //     bytes32 name;\\n    //     bytes32 id;\\n    //     string targetDomain;\\n    // }\\n    struct Record {\\n        address wallet;\\n        bytes32 name;\\n        bytes32 id;\\n        uint96 nonce;\\n        bytes32 domainName;\\n    }\\n\\n    // struct RecordBytes32 {\\n    //     address wallet;\\n    //     bytes32 name;\\n    //     bytes32 id;\\n    //     uint96 nonce;\\n    // }\\n\\n    bytes32 constant MULTIPASS_STORAGE_POSITION = keccak256(\\\"multipass.diamond.storage.position\\\");\\n\\n    /**\\n     * @dev The domain name of the registrar.\\n     * @param properties - domain configuration\\n     * @param idToAddress is mapping from unique identificator to an address\\n     * @param registerSize is number of registered users for this domain\\n     * @param nonce is incremented each time Record changes in addressToId map\\n     * @param nameToId is mapping from names to unique identificator. While each name required to be unique,\\n                        names might change on the domain, so we keep records to user identificators as immutable property of user\\n     * @param addressToId is mapping from an address to unique identificator\\n     * @param idToName is mapping from identificator to a name\\n    **/\\n    struct DomainNameService {\\n        Domain properties; //128 bytes\\n        mapping(bytes32 => address) idToAddress; //N*20bytes\\n        mapping(bytes32 => uint96) nonce; //N*12bytes\\n        mapping(address => bytes32) addressToId; //N*32 bytes\\n        mapping(bytes32 => bytes32) nameToId; //N*32 bytes\\n        mapping(bytes32 => bytes32) idToName; //N*32 bytes\\n        //Total: 128+N*160 Bytes\\n    }\\n\\n    struct MultipassStorageStruct {\\n        mapping(uint256 => DomainNameService) domains;\\n        mapping(bytes32 => uint256) domainNameToIndex; //helper to get domain index by name\\n        uint256 numDomains;\\n    }\\n\\n    function MultipassStorage() internal pure returns (MultipassStorageStruct storage es) {\\n        bytes32 position = MULTIPASS_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n\\n    bytes32 internal constant _TYPEHASH =\\n        keccak256(\\\"registerName(bytes32 name,bytes32 id,bytes32 domainName,uint256 deadline,uint96 nonce)\\\");\\n    bytes32 internal constant _TYPEHASH_REFERRAL = keccak256(\\\"proofOfReferrer(address referrerAddress)\\\");\\n\\n    // function _stringToBytes32(string memory source) internal pure returns (bytes32 result) {\\n    //     uint256 length = bytes(source).length;\\n    //     require(length <= 32, \\\"_stringToBytes32->String longer than 32 bytes\\\");\\n    //     bytes memory tempEmptyStringTest = abi.encodePacked(source);\\n    //     if (tempEmptyStringTest.length == 0) {\\n    //         return 0x0;\\n    //     }\\n    //     assembly {\\n    //         result := mload(add(source,32))\\n    //     }\\n    // }\\n\\n    function _checkStringFits32b(string memory value) internal pure returns (bool) {\\n        if (bytes(value).length <= 32) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _checkNotEmpty(bytes32 value) internal pure returns (bool) {\\n        if (value == \\\"\\\") {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function resolveDomainIndex(bytes32 domainName) internal view returns (uint256) {\\n        MultipassStorageStruct storage s = MultipassStorage();\\n        return s.domainNameToIndex[domainName];\\n    }\\n\\n    function _getDomainStorage(bytes32 domainName) internal view returns (DomainNameService storage) {\\n        MultipassStorageStruct storage s = MultipassStorage();\\n\\n        return s.domains[resolveDomainIndex(domainName)];\\n    }\\n\\n    function _initializeDomain(\\n        address registrar,\\n        uint256 freeRegistrationsNumber,\\n        uint256 fee,\\n        bytes32 domainName,\\n        uint256 referrerReward,\\n        uint256 referralDiscount\\n    ) internal {\\n        LibMultipass.MultipassStorageStruct storage ms = LibMultipass.MultipassStorage();\\n\\n        uint256 domainIndex = ms.numDomains + 1;\\n        LibMultipass.DomainNameService storage _domain = ms.domains[domainIndex];\\n        _domain.properties.registrar = registrar;\\n        _domain.properties.freeRegistrationsNumber = freeRegistrationsNumber;\\n        _domain.properties.fee = fee;\\n        _domain.properties.name = domainName;\\n        _domain.properties.referrerReward = referrerReward;\\n        _domain.properties.referralDiscount = referralDiscount;\\n        ms.numDomains++;\\n        ms.domainNameToIndex[domainName] = domainIndex;\\n    }\\n\\n    function _getModifyPrice(LibMultipass.Record memory userRecord) internal view returns (uint256) {\\n        LibMultipass.DomainNameService storage _domain = LibMultipass._getDomainStorage(userRecord.domainName);\\n        uint256 feeCoefficient = SafeMath.div(_domain.properties.fee, 10);\\n        uint256 nonceCoefficient = SafeMath.mul(userRecord.nonce, userRecord.nonce);\\n        return SafeMath.add(SafeMath.mul(feeCoefficient, nonceCoefficient), _domain.properties.fee);\\n    }\\n\\n    function _resolveRecord(NameQuery memory query) private view returns (bool, Record memory) {\\n        if ((query.wallet == address(0)) && (query.id == bytes32(0)) && (query.name == bytes32(0))) {\\n            Record memory rv;\\n            return (false, rv);\\n        }\\n\\n        MultipassStorageStruct storage s = MultipassStorage();\\n        DomainNameService storage _domain = s.domains[s.domainNameToIndex[query.domainName]];\\n        DomainNameService storage _targetDomain = s.domains[\\n            s.domainNameToIndex[query.targetDomain == bytes32(0) ? query.domainName : query.targetDomain]\\n        ];\\n        address _wallet;\\n        {\\n            // resolve wallet\\n            if (query.wallet != address(0)) {\\n                _wallet = query.wallet;\\n            } else if (query.id != bytes32(0)) {\\n                _wallet = _domain.idToAddress[query.id];\\n            } else if (query.name != bytes32(0)) {\\n                bytes32 _id = _domain.nameToId[query.name];\\n                _wallet = _domain.idToAddress[_id];\\n            }\\n        }\\n\\n        //from wallet find and return record\\n        return _resolveFromAddress(_wallet, _targetDomain);\\n    }\\n\\n    /**\\n    @dev resolves Record of name query in to status and identity */\\n    function resolveRecord(NameQuery memory query) internal view returns (bool, Record memory) {\\n        return _resolveRecord(query);\\n    }\\n\\n    /** @dev this function bears no security checks, it will ignore nonce in arg and will increment\\n     *   nonce value stored in domain instread\\n     */\\n    function _setRecord(DomainNameService storage domain, Record memory record) internal {\\n        domain.addressToId[record.wallet] = record.id;\\n        domain.idToAddress[record.id] = record.wallet;\\n        domain.idToName[record.id] = record.name;\\n        domain.nameToId[record.name] = record.id;\\n        domain.nonce[record.id] += 1;\\n    }\\n\\n    function _resolveFromAddress(\\n        address _address,\\n        DomainNameService storage _domain\\n    ) private view returns (bool, Record memory) {\\n        Record memory resolved;\\n\\n        resolved.id = _domain.addressToId[_address];\\n        resolved.name = _domain.idToName[resolved.id];\\n        resolved.nonce = _domain.nonce[resolved.id];\\n        resolved.wallet = _address;\\n        resolved.domainName = _domain.properties.name;\\n\\n        if (resolved.id == bytes32(0)) {\\n            return (false, resolved);\\n        }\\n        return (true, resolved);\\n    }\\n\\n    function queryFromRecord(Record memory _record, bytes32 _domainName) internal pure returns (NameQuery memory) {\\n        NameQuery memory _query;\\n        _query.id = _record.id;\\n        _query.domainName = _domainName;\\n        _query.name = _record.name;\\n        _query.wallet = _record.wallet;\\n        return _query;\\n    }\\n\\n    function shouldRegisterForFree(DomainNameService storage domain) internal view returns (bool) {\\n        return domain.properties.freeRegistrationsNumber > domain.properties.registerSize ? true : false;\\n    }\\n\\n    function _registerNew(Record memory newRecord, DomainNameService storage domain) internal {\\n        _setRecord(domain, newRecord);\\n        domain.properties.registerSize += 1;\\n    }\\n\\n    function _getContractState() internal view returns (uint256) {\\n        LibMultipass.MultipassStorageStruct storage ms = LibMultipass.MultipassStorage();\\n        return ms.numDomains;\\n    }\\n\\n    function _getDomainStorageByIdx(uint256 index) internal view returns (DomainNameService storage) {\\n        MultipassStorageStruct storage s = MultipassStorage();\\n\\n        return s.domains[index];\\n    }\\n\\n    using LibMultipass for NameQuery;\\n}\\n\",\"keccak256\":\"0xa78664392ce7dea7131ecfbe5ed95cb4f8b60c066caa9aa0c509e255f8c1583e\",\"license\":\"MIT\"},\"src/modifiers/OnlyOwnerDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"../vendor/libraries/LibDiamond.sol\\\";\\n\\n// import \\\"./interfaces/IERC173.sol\\\";\\n\\ncontract OnlyOwnerDiamond {\\n    modifier onlyOwner() {\\n        LibDiamond.enforceIsContractOwner();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x998a3e35ca9f029367850b6f69be6a8ec98f26e1c7772d7958b918cea6a8dc26\",\"license\":\"MIT\"},\"src/vendor/facets/OwnershipFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\";\\n\\ncontract OwnershipFacet is IERC173 {\\n    function transferOwnership(address _newOwner) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.setContractOwner(_newOwner);\\n    }\\n\\n    function owner() external view override returns (address owner_) {\\n        owner_ = LibDiamond.contractOwner();\\n    }\\n}\\n\",\"keccak256\":\"0x516314d2d92d787b662aec63e93ae30637108772e2bc0ac1c3b3b6d57f1f5987\",\"license\":\"MIT\"},\"src/vendor/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/******************************************************************************\\\\\\n*  Adapted from\\n*  Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x238f7bcdbbedfac48b94cbc9d4a15e16fb5c9c09fb41a8c72e2a7ff48c81f24b\",\"license\":\"MIT\"},\"src/vendor/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    // Removed deue to duplicate abi generation in 8.20 compiler\\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x8fd517ec0fdb014cb7d32a0b46894899e7e1113dba0e62d1b85c492a3c70a2c0\",\"license\":\"MIT\"},\"src/vendor/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x4b729c72650a32af6dddb4bb743488bf477770252cf84d5660e78f49164b35b2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50613676806100206000396000f3fe6080604052600436106100f35760003560e01c8063a5def8b71161008a578063d9eb0fd111610059578063d9eb0fd11461027f578063de12c65a1461029f578063eb924472146102bf578063f8a7e791146102d257600080fd5b8063a5def8b71461020c578063b0ffc3421461022c578063bdfa11301461024c578063ca55d6e41461025f57600080fd5b806375b83e5e116100c657806375b83e5e1461017c5780637916692c1461019c5780637f4e4849146101c9578063898c2bd7146101de57600080fd5b80630b07a3d1146100f857806312065fe01461011a5780636608ef421461013c578063743790ed1461015c575b600080fd5b34801561010457600080fd5b50610118610113366004612e26565b6102f2565b005b34801561012657600080fd5b50475b6040519081526020015b60405180910390f35b34801561014857600080fd5b50610118610157366004612e63565b61036d565b34801561016857600080fd5b50610118610177366004612ead565b610788565b34801561018857600080fd5b50610118610197366004612e26565b610871565b3480156101a857600080fd5b506101bc6101b7366004612e26565b6108ba565b6040516101339190612ed9565b3480156101d557600080fd5b506101296109ae565b3480156101ea57600080fd5b506101fe6101f936600461300d565b6109dd565b604051610133929190613029565b34801561021857600080fd5b5061012961022736600461300d565b610a19565b34801561023857600080fd5b5061011861024736600461308e565b610aa9565b61011861025a36600461316b565b610ca6565b34801561026b57600080fd5b5061011861027a3660046131d7565b61135f565b34801561028b57600080fd5b5061011861029a3660046131f9565b61145d565b3480156102ab57600080fd5b506101bc6102ba366004612e26565b6114ab565b6101186102cd366004613214565b611528565b3480156102de57600080fd5b506101186102ed36600461300d565b6118ff565b6102fa611b35565b61030381611c00565b600061030e82611d2f565b6005810180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905560405190915082907f12ba12d5905656d674e5e6eb43518e8037aa5c2d412275fed1d6c87b3579f8f490600090a25050565b610375611b35565b73ffffffffffffffffffffffffffffffffffffffff8616610443576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a20596f7560448201527f206d7573742070726f766964652061207265676973747261722061646472657360648201527f7300000000000000000000000000000000000000000000000000000000000000608482015260a4015b60405180910390fd5b61044c83611d9f565b6104d8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a20446f6d60448201527f61696e206e616d652063616e6e6f7420626520656d7074790000000000000000606482015260840161043a565b60008381527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb09602052604090205415610593576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603760248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a20446f6d60448201527f61696e206e616d6520616c726561647920657869737473000000000000000000606482015260840161043a565b6000806105a08484611dbe565b909250905060018215151461065d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604760248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a2072656660448201527f6572726572526577617264202b20726566657272616c446973636f756e74206f60648201527f766572666c6f7700000000000000000000000000000000000000000000000000608482015260a40161043a565b85811115610713576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604760248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a2072656660448201527f657272616c2076616c7565732061726520686967686572207468656e2066656560648201527f20697473656c6600000000000000000000000000000000000000000000000000608482015260a40161043a565b610721888888888888611de7565b60408051888152602081018690529081018490528590879073ffffffffffffffffffffffffffffffffffffffff8b16907fbe3801c0181d8af90729c68d92bf7b5f04bd95932ab4bd4364d75bafe12a65389060600160405180910390a45050505050505050565b610790611b35565b61079982611c00565b60006107a483611d2f565b905073ffffffffffffffffffffffffffffffffffffffff8216610823576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6e6577207265676973747261722063616e6e6f74206265207a65726f00000000604482015260640161043a565b600501805473ffffffffffffffffffffffffffffffffffffffff909216610100027fffffffffffffffffffffff0000000000000000000000000000000000000000ff90921691909117905550565b610879611b35565b61088281611c00565b600061088d82611d2f565b60050180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001690555050565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081018290529061090c83611d2f565b604080516101208101825282548152600183015460208201526002830154918101919091526003820154606082015260048201546080820152600582015460ff8116151560a083015261010080820473ffffffffffffffffffffffffffffffffffffffff1660c0840152750100000000000000000000000000000000000000000090910462ffffff1660e0830152600690920154918101919091529392505050565b60006109d87f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0a5490565b905090565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052610a1083611ee3565b91509150915091565b6000806000610a2784611ee3565b9092509050600182151514610a98576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f6765744d6f6469667950726963652d3e75736572206e6f7420666f756e642000604482015260640161043a565b610aa181611f16565b949350505050565b610ab1611b35565b610aba81611c00565b6000610ac582611d2f565b9050600080610ad48786611dbe565b9092509050600182151514610b91576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604c60248201527f4d756c7469706173732d3e6368616e6765526566657272616c50726f6772616d60448201527f3a207265666572726572526577617264202b20726566657272616c446973636f60648201527f756e74206f766572666c6f770000000000000000000000000000000000000000608482015260a40161043a565b6001830154811115610c4b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605060248201527f4d756c7469706173732d3e6368616e6765526566657272616c50726f6772616d60448201527f3a20726566657272616c2076616c75657320617265206869676865722074686560648201527f6e207468652066656520697473656c6600000000000000000000000000000000608482015260a40161043a565b6003830187905560048301859055600283018690556040805188815260208101879052879186917fa9e253dabd6e5f02d60f00939674a88ef4de2ad412ea1dc78ce69a31a4216a94910160405180910390a350505050505050565b610caf85611c00565b608084018590526000610cc186611d2f565b600581015490915060ff16610d58576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603c60248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204c69624d7560448201527f6c7469706173732e446f6d61696e206973206e6f742061637469766500000000606482015260840161043a565b83610de5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204e616d652060448201527f63616e6e6f7420626520656d7074790000000000000000000000000000000000606482015260840161043a565b43821015610e9b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605760248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a205369676e6160448201527f7475726520646561646c696e65206d757374206265206772656174657220746860648201527f616e2063757272656e7420626c6f636b206e756d626572000000000000000000608482015260a40161043a565b600080610ea787611ee3565b6020810180519089905291935091508190600184151514610f4a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f7573657220646f6573206e6f742065786973742c20757365207265676973746560448201527f72282920696e7374656164000000000000000000000000000000000000000000606482015260840161043a565b60007f829c23f309973881020b4844a250746aaa001c672df3f7b11a665572e05517998360200151846040015185608001518a8860600151604051602001610fc89695949392919095865260208601949094526040850192909252606084015260808301526bffffffffffffffffffffffff1660a082015260c00190565b604051602081830303815290604052905061100b81898860000160050160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16611f81565b611097576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204e6f74206160448201527f2076616c6964207369676e617475726500000000000000000000000000000000606482015260840161043a565b60006110a284611f16565b905080341015611134576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204e6f74206560448201527f6e6f756768207061796d656e7400000000000000000000000000000000000000606482015260840161043a565b6060850151604080870151600090815260088a0160205220546bffffffffffffffffffffffff9081169116146111ec576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a20696e76616c60448201527f6964206e6f6e6365000000000000000000000000000000000000000000000000606482015260840161043a565b60008a8152600a880160205260409020541561128a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4f76654d756c7469706173732d3e6d6f64696679557365724e616d653a206e6560448201527f77206e616d6520616c7265616479206578697374730000000000000000000000606482015260840161043a565b6112948785611fac565b6040808501516000908152600b89016020908152828220548252600a8a01905281812055518c90849061132190879073ffffffffffffffffffffffffffffffffffffffff825116815260208201516020820152604082015160408201526bffffffffffffffffffffffff606083015116606082015260808201516080820152600060a08201905092915050565b604051908190038120907f02d9a5627e4bd1785c150ee39c4c50a61974b9064d5ce32fe39cf6f6053efcae90600090a4505050505050505050505050565b611367611b35565b61137082611c00565b600061137b83611d2f565b600381015460048201549192509083611394838361333a565b1115611422576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603c60248201527f4d756c7469706173732d3e6368616e67654665653a20726566657272616c207260448201527f65776172647320776f756c64206265636f6d6520746f6f206869676800000000606482015260840161043a565b60018301849055604051849086907f850b5f3a1167567889ff23ccba717cf63dc8e533b3ce66ebe7f9036ea50d397490600090a35050505050565b611465611b35565b60405173ffffffffffffffffffffffffffffffffffffffff8216904780156108fc02916000818181858888f193505050501580156114a7573d6000803e3d6000fd5b5050565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081018290529061090c8360009081527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb086020526040902090565b61153185611c00565b61153d8686868661209e565b600061154886611d2f565b905060008061155685611ee3565b915091506000611565846126b5565b611634578261157557600061157b565b60038401545b905060006115a08560000160010154856115965760006126d0565b60048701546126d0565b905080341015611632576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4d756c7469706173732d3e72656769737465723a205061796d656e742076616c60448201527f7565206973206e6f7420656e6f75676800000000000000000000000000000000606482015260840161043a565b505b61163e8a856126dc565b83546040517f21c225a8ca89ef7aa4ecf2b902d3266d4f7cfa1c0b8b6747df607375bf7638c590611670908d9061334d565b60405180910390a282156118f3578151604080517f216da2d1b8943b28c3c65d1a24b58fdf6dfd051d8f0667966ebf5d8ae37ceb76602082015273ffffffffffffffffffffffffffffffffffffffff909216828201528051808303820181526060909201905282516116e59082908890611f81565b611771576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4d756c7469706173732d3e72656769737465723a20526566657272616c20636f60448201527f6465206973206e6f742076616c69640000000000000000000000000000000000606482015260840161043a565b825160405173ffffffffffffffffffffffffffffffffffffffff9091169083156108fc029084906000818181858888f19350505050611832576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603360248201527f4d756c7469706173732d3e72656769737465723a204661696c656420746f207360448201527f656e6420726566657272616c2072657761726400000000000000000000000000606482015260840161043a565b8a51835173ffffffffffffffffffffffffffffffffffffffff9182169116036118b7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f43616e6e6f7420726566657220796f757273656c660000000000000000000000604482015260640161043a565b897f3afc2c4d6013c0d5dff05b266fa6eed468f77af1096838b66c1b92f34d0e904e848d6040516118e99291906133aa565b60405180910390a2505b50505050505050505050565b611907611b35565b805161191290611c00565b60006119218260000151611d2f565b60006080840181905290915080611937846109dd565b90925090506001821515146119ce576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4d756c7469706173732d3e64656c6574654e616d653a206e616d65206e6f742060448201527f7265736f6c766564000000000000000000000000000000000000000000000000606482015260840161043a565b805173ffffffffffffffffffffffffffffffffffffffff16600090815260098401602090815260408083208390558084018051845260078701835281842080547fffffffffffffffffffffffff000000000000000000000000000000000000000016905580518452600b87018352818420849055828501518452600a87018352818420849055518352600886019091528120805460019290611a7f9084906bffffffffffffffffffffffff16613462565b92506101000a8154816bffffffffffffffffffffffff02191690836bffffffffffffffffffffffff160217905550826000016006016000815480929190611ac59061348e565b91905055508060400151816000015173ffffffffffffffffffffffffffffffffffffffff1684600001600001547fee56310501c49a670570d1edf7adfbe3fb90b4ae92c631470d3d4b059b7ab7a78460200151604051611b2791815260200190565b60405180910390a450505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6004015473ffffffffffffffffffffffffffffffffffffffff163314611bfe576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60448201527f6572000000000000000000000000000000000000000000000000000000000000606482015260840161043a565b565b611c0981611d9f565b611c95576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603760248201527f6163746976617465446f6d61696e2d3e506c656173652073706563696679204c60448201527f69624d756c7469706173732e446f6d61696e206e616d65000000000000000000606482015260840161043a565b60008181527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb096020526040902054600003611d2c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f446f6d61696e20646f6573206e6f742065786973740000000000000000000000604482015260640161043a565b50565b60007f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb088082611d898560009081527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb09602052604090205490565b8152602001908152602001600020915050919050565b600081600003611db157506000919050565b506001919050565b919050565b60008083830184811015611dd9576000809250925050611de0565b6001925090505b9250929050565b7f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0a547f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0890600090611e3990600161333a565b60008181526020849052604081206005810180547fffffffffffffffffffffff0000000000000000000000000000000000000000ff1661010073ffffffffffffffffffffffffffffffffffffffff8e160217905560028082018b9055600182018a9055888255600382018890556004820187905585018054939450909291611ec0836134c3565b909155505050600094855260019091016020526040909320929092555050505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052610a1083612707565b600080611f268360800151611d2f565b90506000611f3c8260000160010154600a61291a565b6060850151909150600090611f5f906bffffffffffffffffffffffff1680612926565b9050611f78611f6e8383612926565b6001850154612932565b95945050505050565b600080611f94858051906020012061293e565b9050611fa1838286612986565b9150505b9392505050565b60408181018051835173ffffffffffffffffffffffffffffffffffffffff90811660009081526009870160209081528582209390935585518451825260078801845285822080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169190931617909155818501805184518352600b8801845285832055835190518252600a87018352848220559151825260088501905290812080546001929061206c9084906bffffffffffffffffffffffff16613462565b92506101000a8154816bffffffffffffffffffffffff02191690836bffffffffffffffffffffffff1602179055505050565b6040805160a08082018352600080835260208084018290528385018290526060808501839052608094850183905285519384018652828452838201838152848701848152918501848152958501939093529489015193849052878352880151909352865173ffffffffffffffffffffffffffffffffffffffff1690925261212490611d9f565b6121b0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f5f76616c69646174654e616d6551756572792d3e206e6577207265636f72642060448201527f69642063616e6e6f7420626520656d7074790000000000000000000000000000606482015260840161043a565b80516121bb90611d9f565b612247576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f5f76616c69646174654e616d6551756572792d3e206e6577207265636f72642060448201527f646f6d61696e2063616e6e6f7420626520656d70747900000000000000000000606482015260840161043a565b602081015173ffffffffffffffffffffffffffffffffffffffff166122ee576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f5f76616c69646174654e616d6551756572792d3e206e65772065636f7264206160448201527f6464726573732063616e6e6f7420626520656d70747900000000000000000000606482015260840161043a565b60006122f982611ee3565b509050801561238a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f5573657220616c726561647920726567697374657265642c20757365206d6f6460448201527f69667920696e7374656164000000000000000000000000000000000000000000606482015260840161043a565b60006123998360000151611d2f565b600581015490915060ff16612430576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4d756c7469706173732d3e72656769737465723a20646f6d61696e206973206e60448201527f6f74206163746976650000000000000000000000000000000000000000000000606482015260840161043a565b4384116124bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603f60248201527f4d756c7469706173732d3e72656769737465723a20446561646c696e6520697360448201527f206c657373207468616e2063757272656e7420626c6f636b206e756d62657200606482015260840161043a565b604080840151606080860151865184517f829c23f309973881020b4844a250746aaa001c672df3f7b11a665572e055179960208201529485019390935290830152608082015260a08101859052600060c082018190529060e001604051602081830303815290604052905061255c81878460000160050160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16611f81565b6125e8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4d756c7469706173732d3e72656769737465723a20526567697374726172207360448201527f69676e6174757265206973206e6f742076616c69640000000000000000000000606482015260840161043a565b5060006125f484611ee3565b50905080156126ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604960248201527f4d756c7469706173732d3e72656769737465723a206170706c6963616e74206960448201527f7320616c726561647920726567697374657265642c20757365206d6f6469667960648201527f20696e7374726561640000000000000000000000000000000000000000000000608482015260a40161043a565b5050505050505050565b6006810154600282015460009110611db15760005b92915050565b6000611fa582846134fb565b6126e68183611fac565b60018160000160060160008282546126fe919061333a565b90915550505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052602083015173ffffffffffffffffffffffffffffffffffffffff1615801561275b57506060830151155b801561276957506040830151155b156127a15750506040805160a08101825260008082526020820181905291810182905260608101829052608081018290529092909150565b825160009081527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb09602081815260408084205484527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0891829052832060808701519193909290918491839182901561281d578960800151612820565b89515b8152602001908152602001600020548152602001908152602001600020905060008073ffffffffffffffffffffffffffffffffffffffff16876020015173ffffffffffffffffffffffffffffffffffffffff161461288357506020860151612903565b6060870151156128bf57506060860151600090815260078301602052604090205473ffffffffffffffffffffffffffffffffffffffff16612903565b60408701511561290357506040808701516000908152600a84016020908152828220548252600785019052205473ffffffffffffffffffffffffffffffffffffffff165b61290d8183612a01565b9550955050505050915091565b6000611fa5828461350e565b6000611fa58284613549565b6000611fa5828461333a565b60006126ca61294b612abe565b836040517f19010000000000000000000000000000000000000000000000000000000000008152600281019290925260228201526042902090565b60008060006129958585612b98565b909250905060008160048111156129ae576129ae613560565b1480156129e657508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b806129f757506129f7868686612bda565b9695505050505050565b6040805160a0808201835260008083526020808401829052838501829052606080850183905260808086018490528651948501875283855284830184815285880185815292860185815291860185815273ffffffffffffffffffffffffffffffffffffffff8b1680875260098b018652898720548086528752600b8b018652898720549092528351865260088a01909452968420546bffffffffffffffffffffffff169052948352855490529251611dd957600092509050611de0565b7fe5b6a7afa77789577f2802f0da58895f660e5798c5c11b2ea18b0a53bd65d3a9546000907fe5b6a7afa77789577f2802f0da58895f660e5798c5c11b2ea18b0a53bd65d3a79073ffffffffffffffffffffffffffffffffffffffff1630148015612b2c5750806001015446145b15612b375754919050565b612b928160050154826003015483600401546040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b91505090565b6000808251604103612bce5760208301516040840151606085015160001a612bc287828585612d37565b94509450505050611de0565b50600090506002611de0565b60008060008573ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8686604051602401612c119291906135b3565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051612c9a919061360b565b600060405180830381855afa9150503d8060008114612cd5576040519150601f19603f3d011682016040523d82523d6000602084013e612cda565b606091505b5091509150818015612cee57506020815110155b80156129f7575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090612d2c9083016020908101908401613627565b149695505050505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115612d6e5750600090506003612e1d565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015612dc2573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116612e1657600060019250925050612e1d565b9150600090505b94509492505050565b600060208284031215612e3857600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114611db957600080fd5b60008060008060008060c08789031215612e7c57600080fd5b612e8587612e3f565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b60008060408385031215612ec057600080fd5b82359150612ed060208401612e3f565b90509250929050565b600061012082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a0830151151560a083015273ffffffffffffffffffffffffffffffffffffffff60c08401511660c083015260e0830151612f5060e084018262ffffff169052565b5061010092830151919092015290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715612fb257612fb2612f60565b60405290565b600060a08284031215612fca57600080fd5b612fd2612f8f565b905081358152612fe460208301612e3f565b602082015260408201356040820152606082013560608201526080820135608082015292915050565b600060a0828403121561301f57600080fd5b611fa58383612fb8565b821515815260c08101611fa5602083018473ffffffffffffffffffffffffffffffffffffffff815116825260208101516020830152604081015160408301526bffffffffffffffffffffffff6060820151166060830152608081015160808301525050565b600080600080608085870312156130a457600080fd5b5050823594602084013594506040840135936060013592509050565b600082601f8301126130d157600080fd5b813567ffffffffffffffff808211156130ec576130ec612f60565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561313257613132612f60565b8160405283815286602085880101111561314b57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806000806000610120868803121561318457600080fd5b853594506131958760208801612fb8565b935060c0860135925060e086013567ffffffffffffffff8111156131b857600080fd5b6131c4888289016130c0565b9598949750929561010001359392505050565b600080604083850312156131ea57600080fd5b50508035926020909101359150565b60006020828403121561320b57600080fd5b611fa582612e3f565b6000806000806000808688036101c081121561322f57600080fd5b60a081121561323d57600080fd5b50613246612f8f565b61324f88612e3f565b8152602088013560208201526040880135604082015260608801356bffffffffffffffffffffffff8116811461328457600080fd5b606082015260808881013590820152955060a0870135945060c087013567ffffffffffffffff808211156132b757600080fd5b6132c38a838b016130c0565b955060e089013594506132da8a6101008b01612fb8565b93506101a08901359150808211156132f157600080fd5b506132fe89828a016130c0565b9150509295509295509295565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156126ca576126ca61330b565b60a081016126ca828473ffffffffffffffffffffffffffffffffffffffff815116825260208101516020830152604081015160408301526bffffffffffffffffffffffff6060820151166060830152608081015160808301525050565b6101408101613408828573ffffffffffffffffffffffffffffffffffffffff815116825260208101516020830152604081015160408301526bffffffffffffffffffffffff6060820151166060830152608081015160808301525050565b825173ffffffffffffffffffffffffffffffffffffffff1660a0830152602083015160c0830152604083015160e083015260608301516bffffffffffffffffffffffff166101008301526080830151610120830152611fa5565b6bffffffffffffffffffffffff8181168382160190808211156134875761348761330b565b5092915050565b60008161349d5761349d61330b565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036134f4576134f461330b565b5060010190565b818103818111156126ca576126ca61330b565b600082613544577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b80820281158282048414176126ca576126ca61330b565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60005b838110156135aa578181015183820152602001613592565b50506000910152565b82815260406020820152600082518060408401526135d881606085016020870161358f565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b6000825161361d81846020870161358f565b9190910192915050565b60006020828403121561363957600080fd5b505191905056fea2646970667358221220270fc0b423977733c504b736d0c666cfdf032abd46d386032e7861c31e1f2fe964736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106100f35760003560e01c8063a5def8b71161008a578063d9eb0fd111610059578063d9eb0fd11461027f578063de12c65a1461029f578063eb924472146102bf578063f8a7e791146102d257600080fd5b8063a5def8b71461020c578063b0ffc3421461022c578063bdfa11301461024c578063ca55d6e41461025f57600080fd5b806375b83e5e116100c657806375b83e5e1461017c5780637916692c1461019c5780637f4e4849146101c9578063898c2bd7146101de57600080fd5b80630b07a3d1146100f857806312065fe01461011a5780636608ef421461013c578063743790ed1461015c575b600080fd5b34801561010457600080fd5b50610118610113366004612e26565b6102f2565b005b34801561012657600080fd5b50475b6040519081526020015b60405180910390f35b34801561014857600080fd5b50610118610157366004612e63565b61036d565b34801561016857600080fd5b50610118610177366004612ead565b610788565b34801561018857600080fd5b50610118610197366004612e26565b610871565b3480156101a857600080fd5b506101bc6101b7366004612e26565b6108ba565b6040516101339190612ed9565b3480156101d557600080fd5b506101296109ae565b3480156101ea57600080fd5b506101fe6101f936600461300d565b6109dd565b604051610133929190613029565b34801561021857600080fd5b5061012961022736600461300d565b610a19565b34801561023857600080fd5b5061011861024736600461308e565b610aa9565b61011861025a36600461316b565b610ca6565b34801561026b57600080fd5b5061011861027a3660046131d7565b61135f565b34801561028b57600080fd5b5061011861029a3660046131f9565b61145d565b3480156102ab57600080fd5b506101bc6102ba366004612e26565b6114ab565b6101186102cd366004613214565b611528565b3480156102de57600080fd5b506101186102ed36600461300d565b6118ff565b6102fa611b35565b61030381611c00565b600061030e82611d2f565b6005810180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905560405190915082907f12ba12d5905656d674e5e6eb43518e8037aa5c2d412275fed1d6c87b3579f8f490600090a25050565b610375611b35565b73ffffffffffffffffffffffffffffffffffffffff8616610443576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a20596f7560448201527f206d7573742070726f766964652061207265676973747261722061646472657360648201527f7300000000000000000000000000000000000000000000000000000000000000608482015260a4015b60405180910390fd5b61044c83611d9f565b6104d8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a20446f6d60448201527f61696e206e616d652063616e6e6f7420626520656d7074790000000000000000606482015260840161043a565b60008381527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb09602052604090205415610593576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603760248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a20446f6d60448201527f61696e206e616d6520616c726561647920657869737473000000000000000000606482015260840161043a565b6000806105a08484611dbe565b909250905060018215151461065d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604760248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a2072656660448201527f6572726572526577617264202b20726566657272616c446973636f756e74206f60648201527f766572666c6f7700000000000000000000000000000000000000000000000000608482015260a40161043a565b85811115610713576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604760248201527f4d756c7469706173732d3e696e697469616c697a65446f6d61696e3a2072656660448201527f657272616c2076616c7565732061726520686967686572207468656e2066656560648201527f20697473656c6600000000000000000000000000000000000000000000000000608482015260a40161043a565b610721888888888888611de7565b60408051888152602081018690529081018490528590879073ffffffffffffffffffffffffffffffffffffffff8b16907fbe3801c0181d8af90729c68d92bf7b5f04bd95932ab4bd4364d75bafe12a65389060600160405180910390a45050505050505050565b610790611b35565b61079982611c00565b60006107a483611d2f565b905073ffffffffffffffffffffffffffffffffffffffff8216610823576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6e6577207265676973747261722063616e6e6f74206265207a65726f00000000604482015260640161043a565b600501805473ffffffffffffffffffffffffffffffffffffffff909216610100027fffffffffffffffffffffff0000000000000000000000000000000000000000ff90921691909117905550565b610879611b35565b61088281611c00565b600061088d82611d2f565b60050180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001690555050565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081018290529061090c83611d2f565b604080516101208101825282548152600183015460208201526002830154918101919091526003820154606082015260048201546080820152600582015460ff8116151560a083015261010080820473ffffffffffffffffffffffffffffffffffffffff1660c0840152750100000000000000000000000000000000000000000090910462ffffff1660e0830152600690920154918101919091529392505050565b60006109d87f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0a5490565b905090565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052610a1083611ee3565b91509150915091565b6000806000610a2784611ee3565b9092509050600182151514610a98576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f6765744d6f6469667950726963652d3e75736572206e6f7420666f756e642000604482015260640161043a565b610aa181611f16565b949350505050565b610ab1611b35565b610aba81611c00565b6000610ac582611d2f565b9050600080610ad48786611dbe565b9092509050600182151514610b91576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604c60248201527f4d756c7469706173732d3e6368616e6765526566657272616c50726f6772616d60448201527f3a207265666572726572526577617264202b20726566657272616c446973636f60648201527f756e74206f766572666c6f770000000000000000000000000000000000000000608482015260a40161043a565b6001830154811115610c4b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605060248201527f4d756c7469706173732d3e6368616e6765526566657272616c50726f6772616d60448201527f3a20726566657272616c2076616c75657320617265206869676865722074686560648201527f6e207468652066656520697473656c6600000000000000000000000000000000608482015260a40161043a565b6003830187905560048301859055600283018690556040805188815260208101879052879186917fa9e253dabd6e5f02d60f00939674a88ef4de2ad412ea1dc78ce69a31a4216a94910160405180910390a350505050505050565b610caf85611c00565b608084018590526000610cc186611d2f565b600581015490915060ff16610d58576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603c60248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204c69624d7560448201527f6c7469706173732e446f6d61696e206973206e6f742061637469766500000000606482015260840161043a565b83610de5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204e616d652060448201527f63616e6e6f7420626520656d7074790000000000000000000000000000000000606482015260840161043a565b43821015610e9b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605760248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a205369676e6160448201527f7475726520646561646c696e65206d757374206265206772656174657220746860648201527f616e2063757272656e7420626c6f636b206e756d626572000000000000000000608482015260a40161043a565b600080610ea787611ee3565b6020810180519089905291935091508190600184151514610f4a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f7573657220646f6573206e6f742065786973742c20757365207265676973746560448201527f72282920696e7374656164000000000000000000000000000000000000000000606482015260840161043a565b60007f829c23f309973881020b4844a250746aaa001c672df3f7b11a665572e05517998360200151846040015185608001518a8860600151604051602001610fc89695949392919095865260208601949094526040850192909252606084015260808301526bffffffffffffffffffffffff1660a082015260c00190565b604051602081830303815290604052905061100b81898860000160050160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16611f81565b611097576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204e6f74206160448201527f2076616c6964207369676e617475726500000000000000000000000000000000606482015260840161043a565b60006110a284611f16565b905080341015611134576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a204e6f74206560448201527f6e6f756768207061796d656e7400000000000000000000000000000000000000606482015260840161043a565b6060850151604080870151600090815260088a0160205220546bffffffffffffffffffffffff9081169116146111ec576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4d756c7469706173732d3e6d6f64696679557365724e616d653a20696e76616c60448201527f6964206e6f6e6365000000000000000000000000000000000000000000000000606482015260840161043a565b60008a8152600a880160205260409020541561128a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4f76654d756c7469706173732d3e6d6f64696679557365724e616d653a206e6560448201527f77206e616d6520616c7265616479206578697374730000000000000000000000606482015260840161043a565b6112948785611fac565b6040808501516000908152600b89016020908152828220548252600a8a01905281812055518c90849061132190879073ffffffffffffffffffffffffffffffffffffffff825116815260208201516020820152604082015160408201526bffffffffffffffffffffffff606083015116606082015260808201516080820152600060a08201905092915050565b604051908190038120907f02d9a5627e4bd1785c150ee39c4c50a61974b9064d5ce32fe39cf6f6053efcae90600090a4505050505050505050505050565b611367611b35565b61137082611c00565b600061137b83611d2f565b600381015460048201549192509083611394838361333a565b1115611422576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603c60248201527f4d756c7469706173732d3e6368616e67654665653a20726566657272616c207260448201527f65776172647320776f756c64206265636f6d6520746f6f206869676800000000606482015260840161043a565b60018301849055604051849086907f850b5f3a1167567889ff23ccba717cf63dc8e533b3ce66ebe7f9036ea50d397490600090a35050505050565b611465611b35565b60405173ffffffffffffffffffffffffffffffffffffffff8216904780156108fc02916000818181858888f193505050501580156114a7573d6000803e3d6000fd5b5050565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081018290529061090c8360009081527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb086020526040902090565b61153185611c00565b61153d8686868661209e565b600061154886611d2f565b905060008061155685611ee3565b915091506000611565846126b5565b611634578261157557600061157b565b60038401545b905060006115a08560000160010154856115965760006126d0565b60048701546126d0565b905080341015611632576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4d756c7469706173732d3e72656769737465723a205061796d656e742076616c60448201527f7565206973206e6f7420656e6f75676800000000000000000000000000000000606482015260840161043a565b505b61163e8a856126dc565b83546040517f21c225a8ca89ef7aa4ecf2b902d3266d4f7cfa1c0b8b6747df607375bf7638c590611670908d9061334d565b60405180910390a282156118f3578151604080517f216da2d1b8943b28c3c65d1a24b58fdf6dfd051d8f0667966ebf5d8ae37ceb76602082015273ffffffffffffffffffffffffffffffffffffffff909216828201528051808303820181526060909201905282516116e59082908890611f81565b611771576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4d756c7469706173732d3e72656769737465723a20526566657272616c20636f60448201527f6465206973206e6f742076616c69640000000000000000000000000000000000606482015260840161043a565b825160405173ffffffffffffffffffffffffffffffffffffffff9091169083156108fc029084906000818181858888f19350505050611832576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603360248201527f4d756c7469706173732d3e72656769737465723a204661696c656420746f207360448201527f656e6420726566657272616c2072657761726400000000000000000000000000606482015260840161043a565b8a51835173ffffffffffffffffffffffffffffffffffffffff9182169116036118b7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f43616e6e6f7420726566657220796f757273656c660000000000000000000000604482015260640161043a565b897f3afc2c4d6013c0d5dff05b266fa6eed468f77af1096838b66c1b92f34d0e904e848d6040516118e99291906133aa565b60405180910390a2505b50505050505050505050565b611907611b35565b805161191290611c00565b60006119218260000151611d2f565b60006080840181905290915080611937846109dd565b90925090506001821515146119ce576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4d756c7469706173732d3e64656c6574654e616d653a206e616d65206e6f742060448201527f7265736f6c766564000000000000000000000000000000000000000000000000606482015260840161043a565b805173ffffffffffffffffffffffffffffffffffffffff16600090815260098401602090815260408083208390558084018051845260078701835281842080547fffffffffffffffffffffffff000000000000000000000000000000000000000016905580518452600b87018352818420849055828501518452600a87018352818420849055518352600886019091528120805460019290611a7f9084906bffffffffffffffffffffffff16613462565b92506101000a8154816bffffffffffffffffffffffff02191690836bffffffffffffffffffffffff160217905550826000016006016000815480929190611ac59061348e565b91905055508060400151816000015173ffffffffffffffffffffffffffffffffffffffff1684600001600001547fee56310501c49a670570d1edf7adfbe3fb90b4ae92c631470d3d4b059b7ab7a78460200151604051611b2791815260200190565b60405180910390a450505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6004015473ffffffffffffffffffffffffffffffffffffffff163314611bfe576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60448201527f6572000000000000000000000000000000000000000000000000000000000000606482015260840161043a565b565b611c0981611d9f565b611c95576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603760248201527f6163746976617465446f6d61696e2d3e506c656173652073706563696679204c60448201527f69624d756c7469706173732e446f6d61696e206e616d65000000000000000000606482015260840161043a565b60008181527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb096020526040902054600003611d2c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f446f6d61696e20646f6573206e6f742065786973740000000000000000000000604482015260640161043a565b50565b60007f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb088082611d898560009081527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb09602052604090205490565b8152602001908152602001600020915050919050565b600081600003611db157506000919050565b506001919050565b919050565b60008083830184811015611dd9576000809250925050611de0565b6001925090505b9250929050565b7f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0a547f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0890600090611e3990600161333a565b60008181526020849052604081206005810180547fffffffffffffffffffffff0000000000000000000000000000000000000000ff1661010073ffffffffffffffffffffffffffffffffffffffff8e160217905560028082018b9055600182018a9055888255600382018890556004820187905585018054939450909291611ec0836134c3565b909155505050600094855260019091016020526040909320929092555050505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052610a1083612707565b600080611f268360800151611d2f565b90506000611f3c8260000160010154600a61291a565b6060850151909150600090611f5f906bffffffffffffffffffffffff1680612926565b9050611f78611f6e8383612926565b6001850154612932565b95945050505050565b600080611f94858051906020012061293e565b9050611fa1838286612986565b9150505b9392505050565b60408181018051835173ffffffffffffffffffffffffffffffffffffffff90811660009081526009870160209081528582209390935585518451825260078801845285822080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169190931617909155818501805184518352600b8801845285832055835190518252600a87018352848220559151825260088501905290812080546001929061206c9084906bffffffffffffffffffffffff16613462565b92506101000a8154816bffffffffffffffffffffffff02191690836bffffffffffffffffffffffff1602179055505050565b6040805160a08082018352600080835260208084018290528385018290526060808501839052608094850183905285519384018652828452838201838152848701848152918501848152958501939093529489015193849052878352880151909352865173ffffffffffffffffffffffffffffffffffffffff1690925261212490611d9f565b6121b0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f5f76616c69646174654e616d6551756572792d3e206e6577207265636f72642060448201527f69642063616e6e6f7420626520656d7074790000000000000000000000000000606482015260840161043a565b80516121bb90611d9f565b612247576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f5f76616c69646174654e616d6551756572792d3e206e6577207265636f72642060448201527f646f6d61696e2063616e6e6f7420626520656d70747900000000000000000000606482015260840161043a565b602081015173ffffffffffffffffffffffffffffffffffffffff166122ee576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f5f76616c69646174654e616d6551756572792d3e206e65772065636f7264206160448201527f6464726573732063616e6e6f7420626520656d70747900000000000000000000606482015260840161043a565b60006122f982611ee3565b509050801561238a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f5573657220616c726561647920726567697374657265642c20757365206d6f6460448201527f69667920696e7374656164000000000000000000000000000000000000000000606482015260840161043a565b60006123998360000151611d2f565b600581015490915060ff16612430576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4d756c7469706173732d3e72656769737465723a20646f6d61696e206973206e60448201527f6f74206163746976650000000000000000000000000000000000000000000000606482015260840161043a565b4384116124bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603f60248201527f4d756c7469706173732d3e72656769737465723a20446561646c696e6520697360448201527f206c657373207468616e2063757272656e7420626c6f636b206e756d62657200606482015260840161043a565b604080840151606080860151865184517f829c23f309973881020b4844a250746aaa001c672df3f7b11a665572e055179960208201529485019390935290830152608082015260a08101859052600060c082018190529060e001604051602081830303815290604052905061255c81878460000160050160019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16611f81565b6125e8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4d756c7469706173732d3e72656769737465723a20526567697374726172207360448201527f69676e6174757265206973206e6f742076616c69640000000000000000000000606482015260840161043a565b5060006125f484611ee3565b50905080156126ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604960248201527f4d756c7469706173732d3e72656769737465723a206170706c6963616e74206960448201527f7320616c726561647920726567697374657265642c20757365206d6f6469667960648201527f20696e7374726561640000000000000000000000000000000000000000000000608482015260a40161043a565b5050505050505050565b6006810154600282015460009110611db15760005b92915050565b6000611fa582846134fb565b6126e68183611fac565b60018160000160060160008282546126fe919061333a565b90915550505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052602083015173ffffffffffffffffffffffffffffffffffffffff1615801561275b57506060830151155b801561276957506040830151155b156127a15750506040805160a08101825260008082526020820181905291810182905260608101829052608081018290529092909150565b825160009081527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb09602081815260408084205484527f942042f0915323d42178db3492cec6b17698133c921389900ae2a4ec284adb0891829052832060808701519193909290918491839182901561281d578960800151612820565b89515b8152602001908152602001600020548152602001908152602001600020905060008073ffffffffffffffffffffffffffffffffffffffff16876020015173ffffffffffffffffffffffffffffffffffffffff161461288357506020860151612903565b6060870151156128bf57506060860151600090815260078301602052604090205473ffffffffffffffffffffffffffffffffffffffff16612903565b60408701511561290357506040808701516000908152600a84016020908152828220548252600785019052205473ffffffffffffffffffffffffffffffffffffffff165b61290d8183612a01565b9550955050505050915091565b6000611fa5828461350e565b6000611fa58284613549565b6000611fa5828461333a565b60006126ca61294b612abe565b836040517f19010000000000000000000000000000000000000000000000000000000000008152600281019290925260228201526042902090565b60008060006129958585612b98565b909250905060008160048111156129ae576129ae613560565b1480156129e657508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b806129f757506129f7868686612bda565b9695505050505050565b6040805160a0808201835260008083526020808401829052838501829052606080850183905260808086018490528651948501875283855284830184815285880185815292860185815291860185815273ffffffffffffffffffffffffffffffffffffffff8b1680875260098b018652898720548086528752600b8b018652898720549092528351865260088a01909452968420546bffffffffffffffffffffffff169052948352855490529251611dd957600092509050611de0565b7fe5b6a7afa77789577f2802f0da58895f660e5798c5c11b2ea18b0a53bd65d3a9546000907fe5b6a7afa77789577f2802f0da58895f660e5798c5c11b2ea18b0a53bd65d3a79073ffffffffffffffffffffffffffffffffffffffff1630148015612b2c5750806001015446145b15612b375754919050565b612b928160050154826003015483600401546040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b91505090565b6000808251604103612bce5760208301516040840151606085015160001a612bc287828585612d37565b94509450505050611de0565b50600090506002611de0565b60008060008573ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8686604051602401612c119291906135b3565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051612c9a919061360b565b600060405180830381855afa9150503d8060008114612cd5576040519150601f19603f3d011682016040523d82523d6000602084013e612cda565b606091505b5091509150818015612cee57506020815110155b80156129f7575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090612d2c9083016020908101908401613627565b149695505050505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115612d6e5750600090506003612e1d565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015612dc2573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116612e1657600060019250925050612e1d565b9150600090505b94509492505050565b600060208284031215612e3857600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114611db957600080fd5b60008060008060008060c08789031215612e7c57600080fd5b612e8587612e3f565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b60008060408385031215612ec057600080fd5b82359150612ed060208401612e3f565b90509250929050565b600061012082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a0830151151560a083015273ffffffffffffffffffffffffffffffffffffffff60c08401511660c083015260e0830151612f5060e084018262ffffff169052565b5061010092830151919092015290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715612fb257612fb2612f60565b60405290565b600060a08284031215612fca57600080fd5b612fd2612f8f565b905081358152612fe460208301612e3f565b602082015260408201356040820152606082013560608201526080820135608082015292915050565b600060a0828403121561301f57600080fd5b611fa58383612fb8565b821515815260c08101611fa5602083018473ffffffffffffffffffffffffffffffffffffffff815116825260208101516020830152604081015160408301526bffffffffffffffffffffffff6060820151166060830152608081015160808301525050565b600080600080608085870312156130a457600080fd5b5050823594602084013594506040840135936060013592509050565b600082601f8301126130d157600080fd5b813567ffffffffffffffff808211156130ec576130ec612f60565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561313257613132612f60565b8160405283815286602085880101111561314b57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806000806000610120868803121561318457600080fd5b853594506131958760208801612fb8565b935060c0860135925060e086013567ffffffffffffffff8111156131b857600080fd5b6131c4888289016130c0565b9598949750929561010001359392505050565b600080604083850312156131ea57600080fd5b50508035926020909101359150565b60006020828403121561320b57600080fd5b611fa582612e3f565b6000806000806000808688036101c081121561322f57600080fd5b60a081121561323d57600080fd5b50613246612f8f565b61324f88612e3f565b8152602088013560208201526040880135604082015260608801356bffffffffffffffffffffffff8116811461328457600080fd5b606082015260808881013590820152955060a0870135945060c087013567ffffffffffffffff808211156132b757600080fd5b6132c38a838b016130c0565b955060e089013594506132da8a6101008b01612fb8565b93506101a08901359150808211156132f157600080fd5b506132fe89828a016130c0565b9150509295509295509295565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156126ca576126ca61330b565b60a081016126ca828473ffffffffffffffffffffffffffffffffffffffff815116825260208101516020830152604081015160408301526bffffffffffffffffffffffff6060820151166060830152608081015160808301525050565b6101408101613408828573ffffffffffffffffffffffffffffffffffffffff815116825260208101516020830152604081015160408301526bffffffffffffffffffffffff6060820151166060830152608081015160808301525050565b825173ffffffffffffffffffffffffffffffffffffffff1660a0830152602083015160c0830152604083015160e083015260608301516bffffffffffffffffffffffff166101008301526080830151610120830152611fa5565b6bffffffffffffffffffffffff8181168382160190808211156134875761348761330b565b5092915050565b60008161349d5761349d61330b565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036134f4576134f461330b565b5060010190565b818103818111156126ca576126ca61330b565b600082613544577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b80820281158282048414176126ca576126ca61330b565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60005b838110156135aa578181015183820152602001613592565b50506000910152565b82815260406020820152600082518060408401526135d881606085016020870161358f565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b6000825161361d81846020870161358f565b9190910192915050565b60006020828403121561363957600080fd5b505191905056fea2646970667358221220270fc0b423977733c504b736d0c666cfdf032abd46d386032e7861c31e1f2fe964736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "activateDomain(bytes32)": {
        "details": "Activates LibMultipass.Domain name Requirements:  msg.sender is Owner  Emits an {DomainActivated} event."
      },
      "changeFee(bytes32,uint256)": {
        "details": "Changes registrar address Requirements:  msg.sender is Owner  Emits an {DomainFeeChanged} event."
      },
      "changeRegistrar(bytes32,address)": {
        "details": "Changes registrar address Requirements:  msg.sender is Owner  Emits an {RegistrarChangeRequested} event."
      },
      "deactivateDomain(bytes32)": {
        "details": "Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements:  msg.sender is Owner OR registrar  Emits an {DomainDeactivated} event."
      },
      "deleteName((bytes32,address,bytes32,bytes32,bytes32))": {
        "details": "deletes name Requirements:  msg.sender is Owner  Emits an {DomainTTLChangeRequested} event."
      },
      "getBalance()": {
        "details": "returns balance of this contract"
      },
      "getContractState()": {
        "details": "returns contract state variables",
        "returns": {
          "_0": "(s_numDomains)"
        }
      },
      "getDomainState(bytes32)": {
        "details": "returns LibMultipass.Domain state variables",
        "params": {
          "domainName": "name of the LibMultipass.Domain"
        },
        "returns": {
          "_0": "(name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize)"
        }
      },
      "initializeDomain(address,uint256,uint256,bytes32,uint256,uint256)": {
        "details": "Initializes new LibMultipass.Domain and configures it's parameters Requirements:  registrar is not zero  domainName is not empty  domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names  domainName does not exist yet  onlyOwner  referrerReward+referralDiscount cannot be larger than fee",
        "params": {
          "domainName": "name of LibMultipass.Domain",
          "fee": "fee in base currency of network",
          "freeRegistrationsNumber": "number of registrations free of fee",
          "referralDiscount": "referral discount in base currency of network  Emits an {InitializedDomain} event.",
          "referrerReward": "referral fee share in base currency of network",
          "registrar": "address of registrar"
        }
      },
      "modifyUserName(bytes32,(bytes32,address,bytes32,bytes32,bytes32),bytes32,bytes,uint256)": {
        "details": "modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain",
        "params": {
          "domainName": "LibMultipass.Domain",
          "newName": "new name  Emits an {Modified} event."
        }
      },
      "register((address,bytes32,bytes32,uint96,bytes32),bytes32,bytes,uint256,(bytes32,address,bytes32,bytes32,bytes32),bytes)": {
        "details": "registers new name under LibMultipass.Domain Requirements:  all arguments must be set  domainName must be active resolveRecord for given arguments should return no LibMultipass.Record  Emits an {registered} event."
      },
      "resolveRecord((bytes32,address,bytes32,bytes32,bytes32))": {
        "details": "resolves LibMultipass.Record of name query in to status and identity "
      },
      "withrawFunds(address)": {
        "details": "Withraws funds stored in smart contract Requirements:  onlyOwner  Emits an {fundsWithdawn} event."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}